(() => {
    var __webpack_modules__ = {
        228: module => {
            function _arrayLikeToArray(arr, len) {
                if (len == null || len > arr.length) len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) {
                    arr2[i] = arr[i];
                }
                return arr2;
            }
            module.exports = _arrayLikeToArray;
        },
        646: (module, __unused_webpack_exports, __webpack_require__) => {
            var arrayLikeToArray = __webpack_require__(228);
            function _arrayWithoutHoles(arr) {
                if (Array.isArray(arr)) return arrayLikeToArray(arr);
            }
            module.exports = _arrayWithoutHoles;
        },
        926: module => {
            function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
                try {
                    var info = gen[key](arg);
                    var value = info.value;
                } catch (error) {
                    reject(error);
                    return;
                }
                if (info.done) {
                    resolve(value);
                } else {
                    Promise.resolve(value).then(_next, _throw);
                }
            }
            function _asyncToGenerator(fn) {
                return function() {
                    var self = this, args = arguments;
                    return new Promise((function(resolve, reject) {
                        var gen = fn.apply(self, args);
                        function _next(value) {
                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
                        }
                        function _throw(err) {
                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
                        }
                        _next(undefined);
                    }));
                };
            }
            module.exports = _asyncToGenerator;
        },
        860: module => {
            function _iterableToArray(iter) {
                if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
            }
            module.exports = _iterableToArray;
        },
        206: module => {
            function _nonIterableSpread() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            module.exports = _nonIterableSpread;
        },
        319: (module, __unused_webpack_exports, __webpack_require__) => {
            var arrayWithoutHoles = __webpack_require__(646);
            var iterableToArray = __webpack_require__(860);
            var unsupportedIterableToArray = __webpack_require__(379);
            var nonIterableSpread = __webpack_require__(206);
            function _toConsumableArray(arr) {
                return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
            }
            module.exports = _toConsumableArray;
        },
        379: (module, __unused_webpack_exports, __webpack_require__) => {
            var arrayLikeToArray = __webpack_require__(228);
            function _unsupportedIterableToArray(o, minLen) {
                if (!o) return;
                if (typeof o === "string") return arrayLikeToArray(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor) n = o.constructor.name;
                if (n === "Map" || n === "Set") return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
            }
            module.exports = _unsupportedIterableToArray;
        },
        757: (module, __unused_webpack_exports, __webpack_require__) => {
            module.exports = __webpack_require__(666);
        },
        854: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            __webpack_require__.d(__webpack_exports__, {
                apply: () => apply
            });
            var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(319);
            var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
            var methodLookup = {};
            function apply(calls) {
                return calls.map((function(call) {
                    var identifier = call.identifier;
                    var args = call.args;
                    try {
                        if (!(identifier in methodLookup)) {
                            methodLookup[identifier] = eval(identifier);
                        }
                        var f = methodLookup[identifier];
                        if (args == null) {
                            f();
                        } else {
                            f.apply(void 0, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(args));
                        }
                        return null;
                    } catch (e) {
                        return e.message;
                    }
                }));
            }
        },
        486: function(module, exports, __webpack_require__) {
            module = __webpack_require__.nmd(module);
            var __WEBPACK_AMD_DEFINE_RESULT__;
            /**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */            (function() {
                var undefined;
                var VERSION = "4.17.20";
                var LARGE_ARRAY_SIZE = 200;
                var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function";
                var HASH_UNDEFINED = "__lodash_hash_undefined__";
                var MAX_MEMOIZE_SIZE = 500;
                var PLACEHOLDER = "__lodash_placeholder__";
                var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
                var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
                var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
                var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
                var HOT_COUNT = 800, HOT_SPAN = 16;
                var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
                var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
                var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
                var wrapFlags = [ [ "ary", WRAP_ARY_FLAG ], [ "bind", WRAP_BIND_FLAG ], [ "bindKey", WRAP_BIND_KEY_FLAG ], [ "curry", WRAP_CURRY_FLAG ], [ "curryRight", WRAP_CURRY_RIGHT_FLAG ], [ "flip", WRAP_FLIP_FLAG ], [ "partial", WRAP_PARTIAL_FLAG ], [ "partialRight", WRAP_PARTIAL_RIGHT_FLAG ], [ "rearg", WRAP_REARG_FLAG ] ];
                var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
                var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
                var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
                var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
                var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
                var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
                var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
                var reTrim = /^\s+|\s+$/g, reTrimStart = /^\s+/, reTrimEnd = /\s+$/;
                var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
                var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
                var reEscapeChar = /\\(\\)?/g;
                var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
                var reFlags = /\w*$/;
                var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
                var reIsBinary = /^0b[01]+$/i;
                var reIsHostCtor = /^\[object .+?Constructor\]$/;
                var reIsOctal = /^0o[0-7]+$/i;
                var reIsUint = /^(?:0|[1-9]\d*)$/;
                var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
                var reNoMatch = /($^)/;
                var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
                var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
                var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
                var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [ rsNonAstral, rsRegional, rsSurrPair ].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [ rsDingbat, rsRegional, rsSurrPair ].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [ rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral ].join("|") + ")";
                var reApos = RegExp(rsApos, "g");
                var reComboMark = RegExp(rsCombo, "g");
                var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
                var reUnicodeWord = RegExp([ rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [ rsBreak, rsUpper, "$" ].join("|") + ")", rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [ rsBreak, rsUpper + rsMiscLower, "$" ].join("|") + ")", rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower, rsUpper + "+" + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji ].join("|"), "g");
                var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
                var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
                var contextProps = [ "Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout" ];
                var templateCounter = -1;
                var typedArrayTags = {};
                typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
                typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
                var cloneableTags = {};
                cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
                cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
                var deburredLetters = {
                    "À": "A",
                    "Á": "A",
                    "Â": "A",
                    "Ã": "A",
                    "Ä": "A",
                    "Å": "A",
                    "à": "a",
                    "á": "a",
                    "â": "a",
                    "ã": "a",
                    "ä": "a",
                    "å": "a",
                    "Ç": "C",
                    "ç": "c",
                    "Ð": "D",
                    "ð": "d",
                    "È": "E",
                    "É": "E",
                    "Ê": "E",
                    "Ë": "E",
                    "è": "e",
                    "é": "e",
                    "ê": "e",
                    "ë": "e",
                    "Ì": "I",
                    "Í": "I",
                    "Î": "I",
                    "Ï": "I",
                    "ì": "i",
                    "í": "i",
                    "î": "i",
                    "ï": "i",
                    "Ñ": "N",
                    "ñ": "n",
                    "Ò": "O",
                    "Ó": "O",
                    "Ô": "O",
                    "Õ": "O",
                    "Ö": "O",
                    "Ø": "O",
                    "ò": "o",
                    "ó": "o",
                    "ô": "o",
                    "õ": "o",
                    "ö": "o",
                    "ø": "o",
                    "Ù": "U",
                    "Ú": "U",
                    "Û": "U",
                    "Ü": "U",
                    "ù": "u",
                    "ú": "u",
                    "û": "u",
                    "ü": "u",
                    "Ý": "Y",
                    "ý": "y",
                    "ÿ": "y",
                    "Æ": "Ae",
                    "æ": "ae",
                    "Þ": "Th",
                    "þ": "th",
                    "ß": "ss",
                    "Ā": "A",
                    "Ă": "A",
                    "Ą": "A",
                    "ā": "a",
                    "ă": "a",
                    "ą": "a",
                    "Ć": "C",
                    "Ĉ": "C",
                    "Ċ": "C",
                    "Č": "C",
                    "ć": "c",
                    "ĉ": "c",
                    "ċ": "c",
                    "č": "c",
                    "Ď": "D",
                    "Đ": "D",
                    "ď": "d",
                    "đ": "d",
                    "Ē": "E",
                    "Ĕ": "E",
                    "Ė": "E",
                    "Ę": "E",
                    "Ě": "E",
                    "ē": "e",
                    "ĕ": "e",
                    "ė": "e",
                    "ę": "e",
                    "ě": "e",
                    "Ĝ": "G",
                    "Ğ": "G",
                    "Ġ": "G",
                    "Ģ": "G",
                    "ĝ": "g",
                    "ğ": "g",
                    "ġ": "g",
                    "ģ": "g",
                    "Ĥ": "H",
                    "Ħ": "H",
                    "ĥ": "h",
                    "ħ": "h",
                    "Ĩ": "I",
                    "Ī": "I",
                    "Ĭ": "I",
                    "Į": "I",
                    "İ": "I",
                    "ĩ": "i",
                    "ī": "i",
                    "ĭ": "i",
                    "į": "i",
                    "ı": "i",
                    "Ĵ": "J",
                    "ĵ": "j",
                    "Ķ": "K",
                    "ķ": "k",
                    "ĸ": "k",
                    "Ĺ": "L",
                    "Ļ": "L",
                    "Ľ": "L",
                    "Ŀ": "L",
                    "Ł": "L",
                    "ĺ": "l",
                    "ļ": "l",
                    "ľ": "l",
                    "ŀ": "l",
                    "ł": "l",
                    "Ń": "N",
                    "Ņ": "N",
                    "Ň": "N",
                    "Ŋ": "N",
                    "ń": "n",
                    "ņ": "n",
                    "ň": "n",
                    "ŋ": "n",
                    "Ō": "O",
                    "Ŏ": "O",
                    "Ő": "O",
                    "ō": "o",
                    "ŏ": "o",
                    "ő": "o",
                    "Ŕ": "R",
                    "Ŗ": "R",
                    "Ř": "R",
                    "ŕ": "r",
                    "ŗ": "r",
                    "ř": "r",
                    "Ś": "S",
                    "Ŝ": "S",
                    "Ş": "S",
                    "Š": "S",
                    "ś": "s",
                    "ŝ": "s",
                    "ş": "s",
                    "š": "s",
                    "Ţ": "T",
                    "Ť": "T",
                    "Ŧ": "T",
                    "ţ": "t",
                    "ť": "t",
                    "ŧ": "t",
                    "Ũ": "U",
                    "Ū": "U",
                    "Ŭ": "U",
                    "Ů": "U",
                    "Ű": "U",
                    "Ų": "U",
                    "ũ": "u",
                    "ū": "u",
                    "ŭ": "u",
                    "ů": "u",
                    "ű": "u",
                    "ų": "u",
                    "Ŵ": "W",
                    "ŵ": "w",
                    "Ŷ": "Y",
                    "ŷ": "y",
                    "Ÿ": "Y",
                    "Ź": "Z",
                    "Ż": "Z",
                    "Ž": "Z",
                    "ź": "z",
                    "ż": "z",
                    "ž": "z",
                    "Ĳ": "IJ",
                    "ĳ": "ij",
                    "Œ": "Oe",
                    "œ": "oe",
                    "ŉ": "'n",
                    "ſ": "s"
                };
                var htmlEscapes = {
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    '"': "&quot;",
                    "'": "&#39;"
                };
                var htmlUnescapes = {
                    "&amp;": "&",
                    "&lt;": "<",
                    "&gt;": ">",
                    "&quot;": '"',
                    "&#39;": "'"
                };
                var stringEscapes = {
                    "\\": "\\",
                    "'": "'",
                    "\n": "n",
                    "\r": "r",
                    "\u2028": "u2028",
                    "\u2029": "u2029"
                };
                var freeParseFloat = parseFloat, freeParseInt = parseInt;
                var freeGlobal = typeof __webpack_require__.g == "object" && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;
                var freeSelf = typeof self == "object" && self && self.Object === Object && self;
                var root = freeGlobal || freeSelf || Function("return this")();
                var freeExports = true && exports && !exports.nodeType && exports;
                var freeModule = freeExports && "object" == "object" && module && !module.nodeType && module;
                var moduleExports = freeModule && freeModule.exports === freeExports;
                var freeProcess = moduleExports && freeGlobal.process;
                var nodeUtil = function() {
                    try {
                        var types = freeModule && freeModule.require && freeModule.require("util").types;
                        if (types) {
                            return types;
                        }
                        return freeProcess && freeProcess.binding && freeProcess.binding("util");
                    } catch (e) {}
                }();
                var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
                function apply(func, thisArg, args) {
                    switch (args.length) {
                      case 0:
                        return func.call(thisArg);

                      case 1:
                        return func.call(thisArg, args[0]);

                      case 2:
                        return func.call(thisArg, args[0], args[1]);

                      case 3:
                        return func.call(thisArg, args[0], args[1], args[2]);
                    }
                    return func.apply(thisArg, args);
                }
                function arrayAggregator(array, setter, iteratee, accumulator) {
                    var index = -1, length = array == null ? 0 : array.length;
                    while (++index < length) {
                        var value = array[index];
                        setter(accumulator, value, iteratee(value), array);
                    }
                    return accumulator;
                }
                function arrayEach(array, iteratee) {
                    var index = -1, length = array == null ? 0 : array.length;
                    while (++index < length) {
                        if (iteratee(array[index], index, array) === false) {
                            break;
                        }
                    }
                    return array;
                }
                function arrayEachRight(array, iteratee) {
                    var length = array == null ? 0 : array.length;
                    while (length--) {
                        if (iteratee(array[length], length, array) === false) {
                            break;
                        }
                    }
                    return array;
                }
                function arrayEvery(array, predicate) {
                    var index = -1, length = array == null ? 0 : array.length;
                    while (++index < length) {
                        if (!predicate(array[index], index, array)) {
                            return false;
                        }
                    }
                    return true;
                }
                function arrayFilter(array, predicate) {
                    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
                    while (++index < length) {
                        var value = array[index];
                        if (predicate(value, index, array)) {
                            result[resIndex++] = value;
                        }
                    }
                    return result;
                }
                function arrayIncludes(array, value) {
                    var length = array == null ? 0 : array.length;
                    return !!length && baseIndexOf(array, value, 0) > -1;
                }
                function arrayIncludesWith(array, value, comparator) {
                    var index = -1, length = array == null ? 0 : array.length;
                    while (++index < length) {
                        if (comparator(value, array[index])) {
                            return true;
                        }
                    }
                    return false;
                }
                function arrayMap(array, iteratee) {
                    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
                    while (++index < length) {
                        result[index] = iteratee(array[index], index, array);
                    }
                    return result;
                }
                function arrayPush(array, values) {
                    var index = -1, length = values.length, offset = array.length;
                    while (++index < length) {
                        array[offset + index] = values[index];
                    }
                    return array;
                }
                function arrayReduce(array, iteratee, accumulator, initAccum) {
                    var index = -1, length = array == null ? 0 : array.length;
                    if (initAccum && length) {
                        accumulator = array[++index];
                    }
                    while (++index < length) {
                        accumulator = iteratee(accumulator, array[index], index, array);
                    }
                    return accumulator;
                }
                function arrayReduceRight(array, iteratee, accumulator, initAccum) {
                    var length = array == null ? 0 : array.length;
                    if (initAccum && length) {
                        accumulator = array[--length];
                    }
                    while (length--) {
                        accumulator = iteratee(accumulator, array[length], length, array);
                    }
                    return accumulator;
                }
                function arraySome(array, predicate) {
                    var index = -1, length = array == null ? 0 : array.length;
                    while (++index < length) {
                        if (predicate(array[index], index, array)) {
                            return true;
                        }
                    }
                    return false;
                }
                var asciiSize = baseProperty("length");
                function asciiToArray(string) {
                    return string.split("");
                }
                function asciiWords(string) {
                    return string.match(reAsciiWord) || [];
                }
                function baseFindKey(collection, predicate, eachFunc) {
                    var result;
                    eachFunc(collection, (function(value, key, collection) {
                        if (predicate(value, key, collection)) {
                            result = key;
                            return false;
                        }
                    }));
                    return result;
                }
                function baseFindIndex(array, predicate, fromIndex, fromRight) {
                    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
                    while (fromRight ? index-- : ++index < length) {
                        if (predicate(array[index], index, array)) {
                            return index;
                        }
                    }
                    return -1;
                }
                function baseIndexOf(array, value, fromIndex) {
                    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
                }
                function baseIndexOfWith(array, value, fromIndex, comparator) {
                    var index = fromIndex - 1, length = array.length;
                    while (++index < length) {
                        if (comparator(array[index], value)) {
                            return index;
                        }
                    }
                    return -1;
                }
                function baseIsNaN(value) {
                    return value !== value;
                }
                function baseMean(array, iteratee) {
                    var length = array == null ? 0 : array.length;
                    return length ? baseSum(array, iteratee) / length : NAN;
                }
                function baseProperty(key) {
                    return function(object) {
                        return object == null ? undefined : object[key];
                    };
                }
                function basePropertyOf(object) {
                    return function(key) {
                        return object == null ? undefined : object[key];
                    };
                }
                function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
                    eachFunc(collection, (function(value, index, collection) {
                        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
                    }));
                    return accumulator;
                }
                function baseSortBy(array, comparer) {
                    var length = array.length;
                    array.sort(comparer);
                    while (length--) {
                        array[length] = array[length].value;
                    }
                    return array;
                }
                function baseSum(array, iteratee) {
                    var result, index = -1, length = array.length;
                    while (++index < length) {
                        var current = iteratee(array[index]);
                        if (current !== undefined) {
                            result = result === undefined ? current : result + current;
                        }
                    }
                    return result;
                }
                function baseTimes(n, iteratee) {
                    var index = -1, result = Array(n);
                    while (++index < n) {
                        result[index] = iteratee(index);
                    }
                    return result;
                }
                function baseToPairs(object, props) {
                    return arrayMap(props, (function(key) {
                        return [ key, object[key] ];
                    }));
                }
                function baseUnary(func) {
                    return function(value) {
                        return func(value);
                    };
                }
                function baseValues(object, props) {
                    return arrayMap(props, (function(key) {
                        return object[key];
                    }));
                }
                function cacheHas(cache, key) {
                    return cache.has(key);
                }
                function charsStartIndex(strSymbols, chrSymbols) {
                    var index = -1, length = strSymbols.length;
                    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
                    return index;
                }
                function charsEndIndex(strSymbols, chrSymbols) {
                    var index = strSymbols.length;
                    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
                    return index;
                }
                function countHolders(array, placeholder) {
                    var length = array.length, result = 0;
                    while (length--) {
                        if (array[length] === placeholder) {
                            ++result;
                        }
                    }
                    return result;
                }
                var deburrLetter = basePropertyOf(deburredLetters);
                var escapeHtmlChar = basePropertyOf(htmlEscapes);
                function escapeStringChar(chr) {
                    return "\\" + stringEscapes[chr];
                }
                function getValue(object, key) {
                    return object == null ? undefined : object[key];
                }
                function hasUnicode(string) {
                    return reHasUnicode.test(string);
                }
                function hasUnicodeWord(string) {
                    return reHasUnicodeWord.test(string);
                }
                function iteratorToArray(iterator) {
                    var data, result = [];
                    while (!(data = iterator.next()).done) {
                        result.push(data.value);
                    }
                    return result;
                }
                function mapToArray(map) {
                    var index = -1, result = Array(map.size);
                    map.forEach((function(value, key) {
                        result[++index] = [ key, value ];
                    }));
                    return result;
                }
                function overArg(func, transform) {
                    return function(arg) {
                        return func(transform(arg));
                    };
                }
                function replaceHolders(array, placeholder) {
                    var index = -1, length = array.length, resIndex = 0, result = [];
                    while (++index < length) {
                        var value = array[index];
                        if (value === placeholder || value === PLACEHOLDER) {
                            array[index] = PLACEHOLDER;
                            result[resIndex++] = index;
                        }
                    }
                    return result;
                }
                function setToArray(set) {
                    var index = -1, result = Array(set.size);
                    set.forEach((function(value) {
                        result[++index] = value;
                    }));
                    return result;
                }
                function setToPairs(set) {
                    var index = -1, result = Array(set.size);
                    set.forEach((function(value) {
                        result[++index] = [ value, value ];
                    }));
                    return result;
                }
                function strictIndexOf(array, value, fromIndex) {
                    var index = fromIndex - 1, length = array.length;
                    while (++index < length) {
                        if (array[index] === value) {
                            return index;
                        }
                    }
                    return -1;
                }
                function strictLastIndexOf(array, value, fromIndex) {
                    var index = fromIndex + 1;
                    while (index--) {
                        if (array[index] === value) {
                            return index;
                        }
                    }
                    return index;
                }
                function stringSize(string) {
                    return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
                }
                function stringToArray(string) {
                    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
                }
                var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
                function unicodeSize(string) {
                    var result = reUnicode.lastIndex = 0;
                    while (reUnicode.test(string)) {
                        ++result;
                    }
                    return result;
                }
                function unicodeToArray(string) {
                    return string.match(reUnicode) || [];
                }
                function unicodeWords(string) {
                    return string.match(reUnicodeWord) || [];
                }
                var runInContext = function runInContext(context) {
                    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
                    var Array = context.Array, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
                    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
                    var coreJsData = context["__core-js_shared__"];
                    var funcToString = funcProto.toString;
                    var hasOwnProperty = objectProto.hasOwnProperty;
                    var idCounter = 0;
                    var maskSrcKey = function() {
                        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                        return uid ? "Symbol(src)_1." + uid : "";
                    }();
                    var nativeObjectToString = objectProto.toString;
                    var objectCtorString = funcToString.call(Object);
                    var oldDash = root._;
                    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
                    var Buffer = moduleExports ? context.Buffer : undefined, Symbol = context.Symbol, Uint8Array = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined, symIterator = Symbol ? Symbol.iterator : undefined, symToStringTag = Symbol ? Symbol.toStringTag : undefined;
                    var defineProperty = function() {
                        try {
                            var func = getNative(Object, "defineProperty");
                            func({}, "", {});
                            return func;
                        } catch (e) {}
                    }();
                    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date && Date.now !== root.Date.now && Date.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
                    var nativeCeil = Math.ceil, nativeFloor = Math.floor, nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max, nativeMin = Math.min, nativeNow = Date.now, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeReverse = arrayProto.reverse;
                    var DataView = getNative(context, "DataView"), Map = getNative(context, "Map"), Promise = getNative(context, "Promise"), Set = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object, "create");
                    var metaMap = WeakMap && new WeakMap;
                    var realNames = {};
                    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
                    var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
                    function lodash(value) {
                        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                            if (value instanceof LodashWrapper) {
                                return value;
                            }
                            if (hasOwnProperty.call(value, "__wrapped__")) {
                                return wrapperClone(value);
                            }
                        }
                        return new LodashWrapper(value);
                    }
                    var baseCreate = function() {
                        function object() {}
                        return function(proto) {
                            if (!isObject(proto)) {
                                return {};
                            }
                            if (objectCreate) {
                                return objectCreate(proto);
                            }
                            object.prototype = proto;
                            var result = new object;
                            object.prototype = undefined;
                            return result;
                        };
                    }();
                    function baseLodash() {}
                    function LodashWrapper(value, chainAll) {
                        this.__wrapped__ = value;
                        this.__actions__ = [];
                        this.__chain__ = !!chainAll;
                        this.__index__ = 0;
                        this.__values__ = undefined;
                    }
                    lodash.templateSettings = {
                        escape: reEscape,
                        evaluate: reEvaluate,
                        interpolate: reInterpolate,
                        variable: "",
                        imports: {
                            _: lodash
                        }
                    };
                    lodash.prototype = baseLodash.prototype;
                    lodash.prototype.constructor = lodash;
                    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
                    LodashWrapper.prototype.constructor = LodashWrapper;
                    function LazyWrapper(value) {
                        this.__wrapped__ = value;
                        this.__actions__ = [];
                        this.__dir__ = 1;
                        this.__filtered__ = false;
                        this.__iteratees__ = [];
                        this.__takeCount__ = MAX_ARRAY_LENGTH;
                        this.__views__ = [];
                    }
                    function lazyClone() {
                        var result = new LazyWrapper(this.__wrapped__);
                        result.__actions__ = copyArray(this.__actions__);
                        result.__dir__ = this.__dir__;
                        result.__filtered__ = this.__filtered__;
                        result.__iteratees__ = copyArray(this.__iteratees__);
                        result.__takeCount__ = this.__takeCount__;
                        result.__views__ = copyArray(this.__views__);
                        return result;
                    }
                    function lazyReverse() {
                        if (this.__filtered__) {
                            var result = new LazyWrapper(this);
                            result.__dir__ = -1;
                            result.__filtered__ = true;
                        } else {
                            result = this.clone();
                            result.__dir__ *= -1;
                        }
                        return result;
                    }
                    function lazyValue() {
                        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
                        if (!isArr || !isRight && arrLength == length && takeCount == length) {
                            return baseWrapperValue(array, this.__actions__);
                        }
                        var result = [];
                        outer: while (length-- && resIndex < takeCount) {
                            index += dir;
                            var iterIndex = -1, value = array[index];
                            while (++iterIndex < iterLength) {
                                var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value);
                                if (type == LAZY_MAP_FLAG) {
                                    value = computed;
                                } else if (!computed) {
                                    if (type == LAZY_FILTER_FLAG) {
                                        continue outer;
                                    } else {
                                        break outer;
                                    }
                                }
                            }
                            result[resIndex++] = value;
                        }
                        return result;
                    }
                    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
                    LazyWrapper.prototype.constructor = LazyWrapper;
                    function Hash(entries) {
                        var index = -1, length = entries == null ? 0 : entries.length;
                        this.clear();
                        while (++index < length) {
                            var entry = entries[index];
                            this.set(entry[0], entry[1]);
                        }
                    }
                    function hashClear() {
                        this.__data__ = nativeCreate ? nativeCreate(null) : {};
                        this.size = 0;
                    }
                    function hashDelete(key) {
                        var result = this.has(key) && delete this.__data__[key];
                        this.size -= result ? 1 : 0;
                        return result;
                    }
                    function hashGet(key) {
                        var data = this.__data__;
                        if (nativeCreate) {
                            var result = data[key];
                            return result === HASH_UNDEFINED ? undefined : result;
                        }
                        return hasOwnProperty.call(data, key) ? data[key] : undefined;
                    }
                    function hashHas(key) {
                        var data = this.__data__;
                        return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
                    }
                    function hashSet(key, value) {
                        var data = this.__data__;
                        this.size += this.has(key) ? 0 : 1;
                        data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
                        return this;
                    }
                    Hash.prototype.clear = hashClear;
                    Hash.prototype["delete"] = hashDelete;
                    Hash.prototype.get = hashGet;
                    Hash.prototype.has = hashHas;
                    Hash.prototype.set = hashSet;
                    function ListCache(entries) {
                        var index = -1, length = entries == null ? 0 : entries.length;
                        this.clear();
                        while (++index < length) {
                            var entry = entries[index];
                            this.set(entry[0], entry[1]);
                        }
                    }
                    function listCacheClear() {
                        this.__data__ = [];
                        this.size = 0;
                    }
                    function listCacheDelete(key) {
                        var data = this.__data__, index = assocIndexOf(data, key);
                        if (index < 0) {
                            return false;
                        }
                        var lastIndex = data.length - 1;
                        if (index == lastIndex) {
                            data.pop();
                        } else {
                            splice.call(data, index, 1);
                        }
                        --this.size;
                        return true;
                    }
                    function listCacheGet(key) {
                        var data = this.__data__, index = assocIndexOf(data, key);
                        return index < 0 ? undefined : data[index][1];
                    }
                    function listCacheHas(key) {
                        return assocIndexOf(this.__data__, key) > -1;
                    }
                    function listCacheSet(key, value) {
                        var data = this.__data__, index = assocIndexOf(data, key);
                        if (index < 0) {
                            ++this.size;
                            data.push([ key, value ]);
                        } else {
                            data[index][1] = value;
                        }
                        return this;
                    }
                    ListCache.prototype.clear = listCacheClear;
                    ListCache.prototype["delete"] = listCacheDelete;
                    ListCache.prototype.get = listCacheGet;
                    ListCache.prototype.has = listCacheHas;
                    ListCache.prototype.set = listCacheSet;
                    function MapCache(entries) {
                        var index = -1, length = entries == null ? 0 : entries.length;
                        this.clear();
                        while (++index < length) {
                            var entry = entries[index];
                            this.set(entry[0], entry[1]);
                        }
                    }
                    function mapCacheClear() {
                        this.size = 0;
                        this.__data__ = {
                            hash: new Hash,
                            map: new (Map || ListCache),
                            string: new Hash
                        };
                    }
                    function mapCacheDelete(key) {
                        var result = getMapData(this, key)["delete"](key);
                        this.size -= result ? 1 : 0;
                        return result;
                    }
                    function mapCacheGet(key) {
                        return getMapData(this, key).get(key);
                    }
                    function mapCacheHas(key) {
                        return getMapData(this, key).has(key);
                    }
                    function mapCacheSet(key, value) {
                        var data = getMapData(this, key), size = data.size;
                        data.set(key, value);
                        this.size += data.size == size ? 0 : 1;
                        return this;
                    }
                    MapCache.prototype.clear = mapCacheClear;
                    MapCache.prototype["delete"] = mapCacheDelete;
                    MapCache.prototype.get = mapCacheGet;
                    MapCache.prototype.has = mapCacheHas;
                    MapCache.prototype.set = mapCacheSet;
                    function SetCache(values) {
                        var index = -1, length = values == null ? 0 : values.length;
                        this.__data__ = new MapCache;
                        while (++index < length) {
                            this.add(values[index]);
                        }
                    }
                    function setCacheAdd(value) {
                        this.__data__.set(value, HASH_UNDEFINED);
                        return this;
                    }
                    function setCacheHas(value) {
                        return this.__data__.has(value);
                    }
                    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
                    SetCache.prototype.has = setCacheHas;
                    function Stack(entries) {
                        var data = this.__data__ = new ListCache(entries);
                        this.size = data.size;
                    }
                    function stackClear() {
                        this.__data__ = new ListCache;
                        this.size = 0;
                    }
                    function stackDelete(key) {
                        var data = this.__data__, result = data["delete"](key);
                        this.size = data.size;
                        return result;
                    }
                    function stackGet(key) {
                        return this.__data__.get(key);
                    }
                    function stackHas(key) {
                        return this.__data__.has(key);
                    }
                    function stackSet(key, value) {
                        var data = this.__data__;
                        if (data instanceof ListCache) {
                            var pairs = data.__data__;
                            if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                                pairs.push([ key, value ]);
                                this.size = ++data.size;
                                return this;
                            }
                            data = this.__data__ = new MapCache(pairs);
                        }
                        data.set(key, value);
                        this.size = data.size;
                        return this;
                    }
                    Stack.prototype.clear = stackClear;
                    Stack.prototype["delete"] = stackDelete;
                    Stack.prototype.get = stackGet;
                    Stack.prototype.has = stackHas;
                    Stack.prototype.set = stackSet;
                    function arrayLikeKeys(value, inherited) {
                        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
                        for (var key in value) {
                            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
                                result.push(key);
                            }
                        }
                        return result;
                    }
                    function arraySample(array) {
                        var length = array.length;
                        return length ? array[baseRandom(0, length - 1)] : undefined;
                    }
                    function arraySampleSize(array, n) {
                        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
                    }
                    function arrayShuffle(array) {
                        return shuffleSelf(copyArray(array));
                    }
                    function assignMergeValue(object, key, value) {
                        if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
                            baseAssignValue(object, key, value);
                        }
                    }
                    function assignValue(object, key, value) {
                        var objValue = object[key];
                        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
                            baseAssignValue(object, key, value);
                        }
                    }
                    function assocIndexOf(array, key) {
                        var length = array.length;
                        while (length--) {
                            if (eq(array[length][0], key)) {
                                return length;
                            }
                        }
                        return -1;
                    }
                    function baseAggregator(collection, setter, iteratee, accumulator) {
                        baseEach(collection, (function(value, key, collection) {
                            setter(accumulator, value, iteratee(value), collection);
                        }));
                        return accumulator;
                    }
                    function baseAssign(object, source) {
                        return object && copyObject(source, keys(source), object);
                    }
                    function baseAssignIn(object, source) {
                        return object && copyObject(source, keysIn(source), object);
                    }
                    function baseAssignValue(object, key, value) {
                        if (key == "__proto__" && defineProperty) {
                            defineProperty(object, key, {
                                configurable: true,
                                enumerable: true,
                                value: value,
                                writable: true
                            });
                        } else {
                            object[key] = value;
                        }
                    }
                    function baseAt(object, paths) {
                        var index = -1, length = paths.length, result = Array(length), skip = object == null;
                        while (++index < length) {
                            result[index] = skip ? undefined : get(object, paths[index]);
                        }
                        return result;
                    }
                    function baseClamp(number, lower, upper) {
                        if (number === number) {
                            if (upper !== undefined) {
                                number = number <= upper ? number : upper;
                            }
                            if (lower !== undefined) {
                                number = number >= lower ? number : lower;
                            }
                        }
                        return number;
                    }
                    function baseClone(value, bitmask, customizer, key, object, stack) {
                        var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
                        if (customizer) {
                            result = object ? customizer(value, key, object, stack) : customizer(value);
                        }
                        if (result !== undefined) {
                            return result;
                        }
                        if (!isObject(value)) {
                            return value;
                        }
                        var isArr = isArray(value);
                        if (isArr) {
                            result = initCloneArray(value);
                            if (!isDeep) {
                                return copyArray(value, result);
                            }
                        } else {
                            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                            if (isBuffer(value)) {
                                return cloneBuffer(value, isDeep);
                            }
                            if (tag == objectTag || tag == argsTag || isFunc && !object) {
                                result = isFlat || isFunc ? {} : initCloneObject(value);
                                if (!isDeep) {
                                    return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
                                }
                            } else {
                                if (!cloneableTags[tag]) {
                                    return object ? value : {};
                                }
                                result = initCloneByTag(value, tag, isDeep);
                            }
                        }
                        stack || (stack = new Stack);
                        var stacked = stack.get(value);
                        if (stacked) {
                            return stacked;
                        }
                        stack.set(value, result);
                        if (isSet(value)) {
                            value.forEach((function(subValue) {
                                result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
                            }));
                        } else if (isMap(value)) {
                            value.forEach((function(subValue, key) {
                                result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
                            }));
                        }
                        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
                        var props = isArr ? undefined : keysFunc(value);
                        arrayEach(props || value, (function(subValue, key) {
                            if (props) {
                                key = subValue;
                                subValue = value[key];
                            }
                            assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
                        }));
                        return result;
                    }
                    function baseConforms(source) {
                        var props = keys(source);
                        return function(object) {
                            return baseConformsTo(object, source, props);
                        };
                    }
                    function baseConformsTo(object, source, props) {
                        var length = props.length;
                        if (object == null) {
                            return !length;
                        }
                        object = Object(object);
                        while (length--) {
                            var key = props[length], predicate = source[key], value = object[key];
                            if (value === undefined && !(key in object) || !predicate(value)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    function baseDelay(func, wait, args) {
                        if (typeof func != "function") {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        return setTimeout((function() {
                            func.apply(undefined, args);
                        }), wait);
                    }
                    function baseDifference(array, values, iteratee, comparator) {
                        var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
                        if (!length) {
                            return result;
                        }
                        if (iteratee) {
                            values = arrayMap(values, baseUnary(iteratee));
                        }
                        if (comparator) {
                            includes = arrayIncludesWith;
                            isCommon = false;
                        } else if (values.length >= LARGE_ARRAY_SIZE) {
                            includes = cacheHas;
                            isCommon = false;
                            values = new SetCache(values);
                        }
                        outer: while (++index < length) {
                            var value = array[index], computed = iteratee == null ? value : iteratee(value);
                            value = comparator || value !== 0 ? value : 0;
                            if (isCommon && computed === computed) {
                                var valuesIndex = valuesLength;
                                while (valuesIndex--) {
                                    if (values[valuesIndex] === computed) {
                                        continue outer;
                                    }
                                }
                                result.push(value);
                            } else if (!includes(values, computed, comparator)) {
                                result.push(value);
                            }
                        }
                        return result;
                    }
                    var baseEach = createBaseEach(baseForOwn);
                    var baseEachRight = createBaseEach(baseForOwnRight, true);
                    function baseEvery(collection, predicate) {
                        var result = true;
                        baseEach(collection, (function(value, index, collection) {
                            result = !!predicate(value, index, collection);
                            return result;
                        }));
                        return result;
                    }
                    function baseExtremum(array, iteratee, comparator) {
                        var index = -1, length = array.length;
                        while (++index < length) {
                            var value = array[index], current = iteratee(value);
                            if (current != null && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) {
                                var computed = current, result = value;
                            }
                        }
                        return result;
                    }
                    function baseFill(array, value, start, end) {
                        var length = array.length;
                        start = toInteger(start);
                        if (start < 0) {
                            start = -start > length ? 0 : length + start;
                        }
                        end = end === undefined || end > length ? length : toInteger(end);
                        if (end < 0) {
                            end += length;
                        }
                        end = start > end ? 0 : toLength(end);
                        while (start < end) {
                            array[start++] = value;
                        }
                        return array;
                    }
                    function baseFilter(collection, predicate) {
                        var result = [];
                        baseEach(collection, (function(value, index, collection) {
                            if (predicate(value, index, collection)) {
                                result.push(value);
                            }
                        }));
                        return result;
                    }
                    function baseFlatten(array, depth, predicate, isStrict, result) {
                        var index = -1, length = array.length;
                        predicate || (predicate = isFlattenable);
                        result || (result = []);
                        while (++index < length) {
                            var value = array[index];
                            if (depth > 0 && predicate(value)) {
                                if (depth > 1) {
                                    baseFlatten(value, depth - 1, predicate, isStrict, result);
                                } else {
                                    arrayPush(result, value);
                                }
                            } else if (!isStrict) {
                                result[result.length] = value;
                            }
                        }
                        return result;
                    }
                    var baseFor = createBaseFor();
                    var baseForRight = createBaseFor(true);
                    function baseForOwn(object, iteratee) {
                        return object && baseFor(object, iteratee, keys);
                    }
                    function baseForOwnRight(object, iteratee) {
                        return object && baseForRight(object, iteratee, keys);
                    }
                    function baseFunctions(object, props) {
                        return arrayFilter(props, (function(key) {
                            return isFunction(object[key]);
                        }));
                    }
                    function baseGet(object, path) {
                        path = castPath(path, object);
                        var index = 0, length = path.length;
                        while (object != null && index < length) {
                            object = object[toKey(path[index++])];
                        }
                        return index && index == length ? object : undefined;
                    }
                    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                        var result = keysFunc(object);
                        return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
                    }
                    function baseGetTag(value) {
                        if (value == null) {
                            return value === undefined ? undefinedTag : nullTag;
                        }
                        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
                    }
                    function baseGt(value, other) {
                        return value > other;
                    }
                    function baseHas(object, key) {
                        return object != null && hasOwnProperty.call(object, key);
                    }
                    function baseHasIn(object, key) {
                        return object != null && key in Object(object);
                    }
                    function baseInRange(number, start, end) {
                        return number >= nativeMin(start, end) && number < nativeMax(start, end);
                    }
                    function baseIntersection(arrays, iteratee, comparator) {
                        var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
                        while (othIndex--) {
                            var array = arrays[othIndex];
                            if (othIndex && iteratee) {
                                array = arrayMap(array, baseUnary(iteratee));
                            }
                            maxLength = nativeMin(array.length, maxLength);
                            caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined;
                        }
                        array = arrays[0];
                        var index = -1, seen = caches[0];
                        outer: while (++index < length && result.length < maxLength) {
                            var value = array[index], computed = iteratee ? iteratee(value) : value;
                            value = comparator || value !== 0 ? value : 0;
                            if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
                                othIndex = othLength;
                                while (--othIndex) {
                                    var cache = caches[othIndex];
                                    if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
                                        continue outer;
                                    }
                                }
                                if (seen) {
                                    seen.push(computed);
                                }
                                result.push(value);
                            }
                        }
                        return result;
                    }
                    function baseInverter(object, setter, iteratee, accumulator) {
                        baseForOwn(object, (function(value, key, object) {
                            setter(accumulator, iteratee(value), key, object);
                        }));
                        return accumulator;
                    }
                    function baseInvoke(object, path, args) {
                        path = castPath(path, object);
                        object = parent(object, path);
                        var func = object == null ? object : object[toKey(last(path))];
                        return func == null ? undefined : apply(func, object, args);
                    }
                    function baseIsArguments(value) {
                        return isObjectLike(value) && baseGetTag(value) == argsTag;
                    }
                    function baseIsArrayBuffer(value) {
                        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
                    }
                    function baseIsDate(value) {
                        return isObjectLike(value) && baseGetTag(value) == dateTag;
                    }
                    function baseIsEqual(value, other, bitmask, customizer, stack) {
                        if (value === other) {
                            return true;
                        }
                        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
                            return value !== value && other !== other;
                        }
                        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
                    }
                    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
                        objTag = objTag == argsTag ? objectTag : objTag;
                        othTag = othTag == argsTag ? objectTag : othTag;
                        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
                        if (isSameTag && isBuffer(object)) {
                            if (!isBuffer(other)) {
                                return false;
                            }
                            objIsArr = true;
                            objIsObj = false;
                        }
                        if (isSameTag && !objIsObj) {
                            stack || (stack = new Stack);
                            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
                        }
                        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                            if (objIsWrapped || othIsWrapped) {
                                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                                stack || (stack = new Stack);
                                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                            }
                        }
                        if (!isSameTag) {
                            return false;
                        }
                        stack || (stack = new Stack);
                        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
                    }
                    function baseIsMap(value) {
                        return isObjectLike(value) && getTag(value) == mapTag;
                    }
                    function baseIsMatch(object, source, matchData, customizer) {
                        var index = matchData.length, length = index, noCustomizer = !customizer;
                        if (object == null) {
                            return !length;
                        }
                        object = Object(object);
                        while (index--) {
                            var data = matchData[index];
                            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                                return false;
                            }
                        }
                        while (++index < length) {
                            data = matchData[index];
                            var key = data[0], objValue = object[key], srcValue = data[1];
                            if (noCustomizer && data[2]) {
                                if (objValue === undefined && !(key in object)) {
                                    return false;
                                }
                            } else {
                                var stack = new Stack;
                                if (customizer) {
                                    var result = customizer(objValue, srcValue, key, object, source, stack);
                                }
                                if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                    function baseIsNative(value) {
                        if (!isObject(value) || isMasked(value)) {
                            return false;
                        }
                        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                        return pattern.test(toSource(value));
                    }
                    function baseIsRegExp(value) {
                        return isObjectLike(value) && baseGetTag(value) == regexpTag;
                    }
                    function baseIsSet(value) {
                        return isObjectLike(value) && getTag(value) == setTag;
                    }
                    function baseIsTypedArray(value) {
                        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
                    }
                    function baseIteratee(value) {
                        if (typeof value == "function") {
                            return value;
                        }
                        if (value == null) {
                            return identity;
                        }
                        if (typeof value == "object") {
                            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
                        }
                        return property(value);
                    }
                    function baseKeys(object) {
                        if (!isPrototype(object)) {
                            return nativeKeys(object);
                        }
                        var result = [];
                        for (var key in Object(object)) {
                            if (hasOwnProperty.call(object, key) && key != "constructor") {
                                result.push(key);
                            }
                        }
                        return result;
                    }
                    function baseKeysIn(object) {
                        if (!isObject(object)) {
                            return nativeKeysIn(object);
                        }
                        var isProto = isPrototype(object), result = [];
                        for (var key in object) {
                            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                                result.push(key);
                            }
                        }
                        return result;
                    }
                    function baseLt(value, other) {
                        return value < other;
                    }
                    function baseMap(collection, iteratee) {
                        var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
                        baseEach(collection, (function(value, key, collection) {
                            result[++index] = iteratee(value, key, collection);
                        }));
                        return result;
                    }
                    function baseMatches(source) {
                        var matchData = getMatchData(source);
                        if (matchData.length == 1 && matchData[0][2]) {
                            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
                        }
                        return function(object) {
                            return object === source || baseIsMatch(object, source, matchData);
                        };
                    }
                    function baseMatchesProperty(path, srcValue) {
                        if (isKey(path) && isStrictComparable(srcValue)) {
                            return matchesStrictComparable(toKey(path), srcValue);
                        }
                        return function(object) {
                            var objValue = get(object, path);
                            return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
                        };
                    }
                    function baseMerge(object, source, srcIndex, customizer, stack) {
                        if (object === source) {
                            return;
                        }
                        baseFor(source, (function(srcValue, key) {
                            stack || (stack = new Stack);
                            if (isObject(srcValue)) {
                                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
                            } else {
                                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined;
                                if (newValue === undefined) {
                                    newValue = srcValue;
                                }
                                assignMergeValue(object, key, newValue);
                            }
                        }), keysIn);
                    }
                    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
                        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
                        if (stacked) {
                            assignMergeValue(object, key, stacked);
                            return;
                        }
                        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined;
                        var isCommon = newValue === undefined;
                        if (isCommon) {
                            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                            newValue = srcValue;
                            if (isArr || isBuff || isTyped) {
                                if (isArray(objValue)) {
                                    newValue = objValue;
                                } else if (isArrayLikeObject(objValue)) {
                                    newValue = copyArray(objValue);
                                } else if (isBuff) {
                                    isCommon = false;
                                    newValue = cloneBuffer(srcValue, true);
                                } else if (isTyped) {
                                    isCommon = false;
                                    newValue = cloneTypedArray(srcValue, true);
                                } else {
                                    newValue = [];
                                }
                            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                                newValue = objValue;
                                if (isArguments(objValue)) {
                                    newValue = toPlainObject(objValue);
                                } else if (!isObject(objValue) || isFunction(objValue)) {
                                    newValue = initCloneObject(srcValue);
                                }
                            } else {
                                isCommon = false;
                            }
                        }
                        if (isCommon) {
                            stack.set(srcValue, newValue);
                            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                            stack["delete"](srcValue);
                        }
                        assignMergeValue(object, key, newValue);
                    }
                    function baseNth(array, n) {
                        var length = array.length;
                        if (!length) {
                            return;
                        }
                        n += n < 0 ? length : 0;
                        return isIndex(n, length) ? array[n] : undefined;
                    }
                    function baseOrderBy(collection, iteratees, orders) {
                        if (iteratees.length) {
                            iteratees = arrayMap(iteratees, (function(iteratee) {
                                if (isArray(iteratee)) {
                                    return function(value) {
                                        return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
                                    };
                                }
                                return iteratee;
                            }));
                        } else {
                            iteratees = [ identity ];
                        }
                        var index = -1;
                        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                        var result = baseMap(collection, (function(value, key, collection) {
                            var criteria = arrayMap(iteratees, (function(iteratee) {
                                return iteratee(value);
                            }));
                            return {
                                criteria: criteria,
                                index: ++index,
                                value: value
                            };
                        }));
                        return baseSortBy(result, (function(object, other) {
                            return compareMultiple(object, other, orders);
                        }));
                    }
                    function basePick(object, paths) {
                        return basePickBy(object, paths, (function(value, path) {
                            return hasIn(object, path);
                        }));
                    }
                    function basePickBy(object, paths, predicate) {
                        var index = -1, length = paths.length, result = {};
                        while (++index < length) {
                            var path = paths[index], value = baseGet(object, path);
                            if (predicate(value, path)) {
                                baseSet(result, castPath(path, object), value);
                            }
                        }
                        return result;
                    }
                    function basePropertyDeep(path) {
                        return function(object) {
                            return baseGet(object, path);
                        };
                    }
                    function basePullAll(array, values, iteratee, comparator) {
                        var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;
                        if (array === values) {
                            values = copyArray(values);
                        }
                        if (iteratee) {
                            seen = arrayMap(array, baseUnary(iteratee));
                        }
                        while (++index < length) {
                            var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
                            while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
                                if (seen !== array) {
                                    splice.call(seen, fromIndex, 1);
                                }
                                splice.call(array, fromIndex, 1);
                            }
                        }
                        return array;
                    }
                    function basePullAt(array, indexes) {
                        var length = array ? indexes.length : 0, lastIndex = length - 1;
                        while (length--) {
                            var index = indexes[length];
                            if (length == lastIndex || index !== previous) {
                                var previous = index;
                                if (isIndex(index)) {
                                    splice.call(array, index, 1);
                                } else {
                                    baseUnset(array, index);
                                }
                            }
                        }
                        return array;
                    }
                    function baseRandom(lower, upper) {
                        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
                    }
                    function baseRange(start, end, step, fromRight) {
                        var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
                        while (length--) {
                            result[fromRight ? length : ++index] = start;
                            start += step;
                        }
                        return result;
                    }
                    function baseRepeat(string, n) {
                        var result = "";
                        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
                            return result;
                        }
                        do {
                            if (n % 2) {
                                result += string;
                            }
                            n = nativeFloor(n / 2);
                            if (n) {
                                string += string;
                            }
                        } while (n);
                        return result;
                    }
                    function baseRest(func, start) {
                        return setToString(overRest(func, start, identity), func + "");
                    }
                    function baseSample(collection) {
                        return arraySample(values(collection));
                    }
                    function baseSampleSize(collection, n) {
                        var array = values(collection);
                        return shuffleSelf(array, baseClamp(n, 0, array.length));
                    }
                    function baseSet(object, path, value, customizer) {
                        if (!isObject(object)) {
                            return object;
                        }
                        path = castPath(path, object);
                        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
                        while (nested != null && ++index < length) {
                            var key = toKey(path[index]), newValue = value;
                            if (key === "__proto__" || key === "constructor" || key === "prototype") {
                                return object;
                            }
                            if (index != lastIndex) {
                                var objValue = nested[key];
                                newValue = customizer ? customizer(objValue, key, nested) : undefined;
                                if (newValue === undefined) {
                                    newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                                }
                            }
                            assignValue(nested, key, newValue);
                            nested = nested[key];
                        }
                        return object;
                    }
                    var baseSetData = !metaMap ? identity : function(func, data) {
                        metaMap.set(func, data);
                        return func;
                    };
                    var baseSetToString = !defineProperty ? identity : function(func, string) {
                        return defineProperty(func, "toString", {
                            configurable: true,
                            enumerable: false,
                            value: constant(string),
                            writable: true
                        });
                    };
                    function baseShuffle(collection) {
                        return shuffleSelf(values(collection));
                    }
                    function baseSlice(array, start, end) {
                        var index = -1, length = array.length;
                        if (start < 0) {
                            start = -start > length ? 0 : length + start;
                        }
                        end = end > length ? length : end;
                        if (end < 0) {
                            end += length;
                        }
                        length = start > end ? 0 : end - start >>> 0;
                        start >>>= 0;
                        var result = Array(length);
                        while (++index < length) {
                            result[index] = array[index + start];
                        }
                        return result;
                    }
                    function baseSome(collection, predicate) {
                        var result;
                        baseEach(collection, (function(value, index, collection) {
                            result = predicate(value, index, collection);
                            return !result;
                        }));
                        return !!result;
                    }
                    function baseSortedIndex(array, value, retHighest) {
                        var low = 0, high = array == null ? low : array.length;
                        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                            while (low < high) {
                                var mid = low + high >>> 1, computed = array[mid];
                                if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                                    low = mid + 1;
                                } else {
                                    high = mid;
                                }
                            }
                            return high;
                        }
                        return baseSortedIndexBy(array, value, identity, retHighest);
                    }
                    function baseSortedIndexBy(array, value, iteratee, retHighest) {
                        var low = 0, high = array == null ? 0 : array.length;
                        if (high === 0) {
                            return 0;
                        }
                        value = iteratee(value);
                        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined;
                        while (low < high) {
                            var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]), othIsDefined = computed !== undefined, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
                            if (valIsNaN) {
                                var setLow = retHighest || othIsReflexive;
                            } else if (valIsUndefined) {
                                setLow = othIsReflexive && (retHighest || othIsDefined);
                            } else if (valIsNull) {
                                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
                            } else if (valIsSymbol) {
                                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
                            } else if (othIsNull || othIsSymbol) {
                                setLow = false;
                            } else {
                                setLow = retHighest ? computed <= value : computed < value;
                            }
                            if (setLow) {
                                low = mid + 1;
                            } else {
                                high = mid;
                            }
                        }
                        return nativeMin(high, MAX_ARRAY_INDEX);
                    }
                    function baseSortedUniq(array, iteratee) {
                        var index = -1, length = array.length, resIndex = 0, result = [];
                        while (++index < length) {
                            var value = array[index], computed = iteratee ? iteratee(value) : value;
                            if (!index || !eq(computed, seen)) {
                                var seen = computed;
                                result[resIndex++] = value === 0 ? 0 : value;
                            }
                        }
                        return result;
                    }
                    function baseToNumber(value) {
                        if (typeof value == "number") {
                            return value;
                        }
                        if (isSymbol(value)) {
                            return NAN;
                        }
                        return +value;
                    }
                    function baseToString(value) {
                        if (typeof value == "string") {
                            return value;
                        }
                        if (isArray(value)) {
                            return arrayMap(value, baseToString) + "";
                        }
                        if (isSymbol(value)) {
                            return symbolToString ? symbolToString.call(value) : "";
                        }
                        var result = value + "";
                        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
                    }
                    function baseUniq(array, iteratee, comparator) {
                        var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
                        if (comparator) {
                            isCommon = false;
                            includes = arrayIncludesWith;
                        } else if (length >= LARGE_ARRAY_SIZE) {
                            var set = iteratee ? null : createSet(array);
                            if (set) {
                                return setToArray(set);
                            }
                            isCommon = false;
                            includes = cacheHas;
                            seen = new SetCache;
                        } else {
                            seen = iteratee ? [] : result;
                        }
                        outer: while (++index < length) {
                            var value = array[index], computed = iteratee ? iteratee(value) : value;
                            value = comparator || value !== 0 ? value : 0;
                            if (isCommon && computed === computed) {
                                var seenIndex = seen.length;
                                while (seenIndex--) {
                                    if (seen[seenIndex] === computed) {
                                        continue outer;
                                    }
                                }
                                if (iteratee) {
                                    seen.push(computed);
                                }
                                result.push(value);
                            } else if (!includes(seen, computed, comparator)) {
                                if (seen !== result) {
                                    seen.push(computed);
                                }
                                result.push(value);
                            }
                        }
                        return result;
                    }
                    function baseUnset(object, path) {
                        path = castPath(path, object);
                        object = parent(object, path);
                        return object == null || delete object[toKey(last(path))];
                    }
                    function baseUpdate(object, path, updater, customizer) {
                        return baseSet(object, path, updater(baseGet(object, path)), customizer);
                    }
                    function baseWhile(array, predicate, isDrop, fromRight) {
                        var length = array.length, index = fromRight ? length : -1;
                        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
                        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
                    }
                    function baseWrapperValue(value, actions) {
                        var result = value;
                        if (result instanceof LazyWrapper) {
                            result = result.value();
                        }
                        return arrayReduce(actions, (function(result, action) {
                            return action.func.apply(action.thisArg, arrayPush([ result ], action.args));
                        }), result);
                    }
                    function baseXor(arrays, iteratee, comparator) {
                        var length = arrays.length;
                        if (length < 2) {
                            return length ? baseUniq(arrays[0]) : [];
                        }
                        var index = -1, result = Array(length);
                        while (++index < length) {
                            var array = arrays[index], othIndex = -1;
                            while (++othIndex < length) {
                                if (othIndex != index) {
                                    result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
                                }
                            }
                        }
                        return baseUniq(baseFlatten(result, 1), iteratee, comparator);
                    }
                    function baseZipObject(props, values, assignFunc) {
                        var index = -1, length = props.length, valsLength = values.length, result = {};
                        while (++index < length) {
                            var value = index < valsLength ? values[index] : undefined;
                            assignFunc(result, props[index], value);
                        }
                        return result;
                    }
                    function castArrayLikeObject(value) {
                        return isArrayLikeObject(value) ? value : [];
                    }
                    function castFunction(value) {
                        return typeof value == "function" ? value : identity;
                    }
                    function castPath(value, object) {
                        if (isArray(value)) {
                            return value;
                        }
                        return isKey(value, object) ? [ value ] : stringToPath(toString(value));
                    }
                    var castRest = baseRest;
                    function castSlice(array, start, end) {
                        var length = array.length;
                        end = end === undefined ? length : end;
                        return !start && end >= length ? array : baseSlice(array, start, end);
                    }
                    var clearTimeout = ctxClearTimeout || function(id) {
                        return root.clearTimeout(id);
                    };
                    function cloneBuffer(buffer, isDeep) {
                        if (isDeep) {
                            return buffer.slice();
                        }
                        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
                        buffer.copy(result);
                        return result;
                    }
                    function cloneArrayBuffer(arrayBuffer) {
                        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
                        new Uint8Array(result).set(new Uint8Array(arrayBuffer));
                        return result;
                    }
                    function cloneDataView(dataView, isDeep) {
                        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
                    }
                    function cloneRegExp(regexp) {
                        var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                        result.lastIndex = regexp.lastIndex;
                        return result;
                    }
                    function cloneSymbol(symbol) {
                        return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
                    }
                    function cloneTypedArray(typedArray, isDeep) {
                        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
                    }
                    function compareAscending(value, other) {
                        if (value !== other) {
                            var valIsDefined = value !== undefined, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
                            var othIsDefined = other !== undefined, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
                            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                                return 1;
                            }
                            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                                return -1;
                            }
                        }
                        return 0;
                    }
                    function compareMultiple(object, other, orders) {
                        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
                        while (++index < length) {
                            var result = compareAscending(objCriteria[index], othCriteria[index]);
                            if (result) {
                                if (index >= ordersLength) {
                                    return result;
                                }
                                var order = orders[index];
                                return result * (order == "desc" ? -1 : 1);
                            }
                        }
                        return object.index - other.index;
                    }
                    function composeArgs(args, partials, holders, isCurried) {
                        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
                        while (++leftIndex < leftLength) {
                            result[leftIndex] = partials[leftIndex];
                        }
                        while (++argsIndex < holdersLength) {
                            if (isUncurried || argsIndex < argsLength) {
                                result[holders[argsIndex]] = args[argsIndex];
                            }
                        }
                        while (rangeLength--) {
                            result[leftIndex++] = args[argsIndex++];
                        }
                        return result;
                    }
                    function composeArgsRight(args, partials, holders, isCurried) {
                        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
                        while (++argsIndex < rangeLength) {
                            result[argsIndex] = args[argsIndex];
                        }
                        var offset = argsIndex;
                        while (++rightIndex < rightLength) {
                            result[offset + rightIndex] = partials[rightIndex];
                        }
                        while (++holdersIndex < holdersLength) {
                            if (isUncurried || argsIndex < argsLength) {
                                result[offset + holders[holdersIndex]] = args[argsIndex++];
                            }
                        }
                        return result;
                    }
                    function copyArray(source, array) {
                        var index = -1, length = source.length;
                        array || (array = Array(length));
                        while (++index < length) {
                            array[index] = source[index];
                        }
                        return array;
                    }
                    function copyObject(source, props, object, customizer) {
                        var isNew = !object;
                        object || (object = {});
                        var index = -1, length = props.length;
                        while (++index < length) {
                            var key = props[index];
                            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
                            if (newValue === undefined) {
                                newValue = source[key];
                            }
                            if (isNew) {
                                baseAssignValue(object, key, newValue);
                            } else {
                                assignValue(object, key, newValue);
                            }
                        }
                        return object;
                    }
                    function copySymbols(source, object) {
                        return copyObject(source, getSymbols(source), object);
                    }
                    function copySymbolsIn(source, object) {
                        return copyObject(source, getSymbolsIn(source), object);
                    }
                    function createAggregator(setter, initializer) {
                        return function(collection, iteratee) {
                            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
                            return func(collection, setter, getIteratee(iteratee, 2), accumulator);
                        };
                    }
                    function createAssigner(assigner) {
                        return baseRest((function(object, sources) {
                            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
                            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, 
                            customizer) : undefined;
                            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                                customizer = length < 3 ? undefined : customizer;
                                length = 1;
                            }
                            object = Object(object);
                            while (++index < length) {
                                var source = sources[index];
                                if (source) {
                                    assigner(object, source, index, customizer);
                                }
                            }
                            return object;
                        }));
                    }
                    function createBaseEach(eachFunc, fromRight) {
                        return function(collection, iteratee) {
                            if (collection == null) {
                                return collection;
                            }
                            if (!isArrayLike(collection)) {
                                return eachFunc(collection, iteratee);
                            }
                            var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
                            while (fromRight ? index-- : ++index < length) {
                                if (iteratee(iterable[index], index, iterable) === false) {
                                    break;
                                }
                            }
                            return collection;
                        };
                    }
                    function createBaseFor(fromRight) {
                        return function(object, iteratee, keysFunc) {
                            var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
                            while (length--) {
                                var key = props[fromRight ? length : ++index];
                                if (iteratee(iterable[key], key, iterable) === false) {
                                    break;
                                }
                            }
                            return object;
                        };
                    }
                    function createBind(func, bitmask, thisArg) {
                        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                        function wrapper() {
                            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                            return fn.apply(isBind ? thisArg : this, arguments);
                        }
                        return wrapper;
                    }
                    function createCaseFirst(methodName) {
                        return function(string) {
                            string = toString(string);
                            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;
                            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
                            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
                            return chr[methodName]() + trailing;
                        };
                    }
                    function createCompounder(callback) {
                        return function(string) {
                            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
                        };
                    }
                    function createCtor(Ctor) {
                        return function() {
                            var args = arguments;
                            switch (args.length) {
                              case 0:
                                return new Ctor;

                              case 1:
                                return new Ctor(args[0]);

                              case 2:
                                return new Ctor(args[0], args[1]);

                              case 3:
                                return new Ctor(args[0], args[1], args[2]);

                              case 4:
                                return new Ctor(args[0], args[1], args[2], args[3]);

                              case 5:
                                return new Ctor(args[0], args[1], args[2], args[3], args[4]);

                              case 6:
                                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);

                              case 7:
                                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                            }
                            var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
                            return isObject(result) ? result : thisBinding;
                        };
                    }
                    function createCurry(func, bitmask, arity) {
                        var Ctor = createCtor(func);
                        function wrapper() {
                            var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper);
                            while (index--) {
                                args[index] = arguments[index];
                            }
                            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                            length -= holders.length;
                            if (length < arity) {
                                return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
                            }
                            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                            return apply(fn, this, args);
                        }
                        return wrapper;
                    }
                    function createFind(findIndexFunc) {
                        return function(collection, predicate, fromIndex) {
                            var iterable = Object(collection);
                            if (!isArrayLike(collection)) {
                                var iteratee = getIteratee(predicate, 3);
                                collection = keys(collection);
                                predicate = function(key) {
                                    return iteratee(iterable[key], key, iterable);
                                };
                            }
                            var index = findIndexFunc(collection, predicate, fromIndex);
                            return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
                        };
                    }
                    function createFlow(fromRight) {
                        return flatRest((function(funcs) {
                            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
                            if (fromRight) {
                                funcs.reverse();
                            }
                            while (index--) {
                                var func = funcs[index];
                                if (typeof func != "function") {
                                    throw new TypeError(FUNC_ERROR_TEXT);
                                }
                                if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                                    var wrapper = new LodashWrapper([], true);
                                }
                            }
                            index = wrapper ? index : length;
                            while (++index < length) {
                                func = funcs[index];
                                var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined;
                                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                                    wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                                } else {
                                    wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                                }
                            }
                            return function() {
                                var args = arguments, value = args[0];
                                if (wrapper && args.length == 1 && isArray(value)) {
                                    return wrapper.plant(value).value();
                                }
                                var index = 0, result = length ? funcs[index].apply(this, args) : value;
                                while (++index < length) {
                                    result = funcs[index].call(this, result);
                                }
                                return result;
                            };
                        }));
                    }
                    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined : createCtor(func);
                        function wrapper() {
                            var length = arguments.length, args = Array(length), index = length;
                            while (index--) {
                                args[index] = arguments[index];
                            }
                            if (isCurried) {
                                var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
                            }
                            if (partials) {
                                args = composeArgs(args, partials, holders, isCurried);
                            }
                            if (partialsRight) {
                                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
                            }
                            length -= holdersCount;
                            if (isCurried && length < arity) {
                                var newHolders = replaceHolders(args, placeholder);
                                return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
                            }
                            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
                            length = args.length;
                            if (argPos) {
                                args = reorder(args, argPos);
                            } else if (isFlip && length > 1) {
                                args.reverse();
                            }
                            if (isAry && ary < length) {
                                args.length = ary;
                            }
                            if (this && this !== root && this instanceof wrapper) {
                                fn = Ctor || createCtor(fn);
                            }
                            return fn.apply(thisBinding, args);
                        }
                        return wrapper;
                    }
                    function createInverter(setter, toIteratee) {
                        return function(object, iteratee) {
                            return baseInverter(object, setter, toIteratee(iteratee), {});
                        };
                    }
                    function createMathOperation(operator, defaultValue) {
                        return function(value, other) {
                            var result;
                            if (value === undefined && other === undefined) {
                                return defaultValue;
                            }
                            if (value !== undefined) {
                                result = value;
                            }
                            if (other !== undefined) {
                                if (result === undefined) {
                                    return other;
                                }
                                if (typeof value == "string" || typeof other == "string") {
                                    value = baseToString(value);
                                    other = baseToString(other);
                                } else {
                                    value = baseToNumber(value);
                                    other = baseToNumber(other);
                                }
                                result = operator(value, other);
                            }
                            return result;
                        };
                    }
                    function createOver(arrayFunc) {
                        return flatRest((function(iteratees) {
                            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                            return baseRest((function(args) {
                                var thisArg = this;
                                return arrayFunc(iteratees, (function(iteratee) {
                                    return apply(iteratee, thisArg, args);
                                }));
                            }));
                        }));
                    }
                    function createPadding(length, chars) {
                        chars = chars === undefined ? " " : baseToString(chars);
                        var charsLength = chars.length;
                        if (charsLength < 2) {
                            return charsLength ? baseRepeat(chars, length) : chars;
                        }
                        var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
                        return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join("") : result.slice(0, length);
                    }
                    function createPartial(func, bitmask, thisArg, partials) {
                        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                        function wrapper() {
                            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                            while (++leftIndex < leftLength) {
                                args[leftIndex] = partials[leftIndex];
                            }
                            while (argsLength--) {
                                args[leftIndex++] = arguments[++argsIndex];
                            }
                            return apply(fn, isBind ? thisArg : this, args);
                        }
                        return wrapper;
                    }
                    function createRange(fromRight) {
                        return function(start, end, step) {
                            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                                end = step = undefined;
                            }
                            start = toFinite(start);
                            if (end === undefined) {
                                end = start;
                                start = 0;
                            } else {
                                end = toFinite(end);
                            }
                            step = step === undefined ? start < end ? 1 : -1 : toFinite(step);
                            return baseRange(start, end, step, fromRight);
                        };
                    }
                    function createRelationalOperation(operator) {
                        return function(value, other) {
                            if (!(typeof value == "string" && typeof other == "string")) {
                                value = toNumber(value);
                                other = toNumber(other);
                            }
                            return operator(value, other);
                        };
                    }
                    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
                        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined, newHoldersRight = isCurry ? undefined : holders, newPartials = isCurry ? partials : undefined, newPartialsRight = isCurry ? undefined : partials;
                        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
                        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
                        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
                            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
                        }
                        var newData = [ func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity ];
                        var result = wrapFunc.apply(undefined, newData);
                        if (isLaziable(func)) {
                            setData(result, newData);
                        }
                        result.placeholder = placeholder;
                        return setWrapToString(result, func, bitmask);
                    }
                    function createRound(methodName) {
                        var func = Math[methodName];
                        return function(number, precision) {
                            number = toNumber(number);
                            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
                            if (precision && nativeIsFinite(number)) {
                                var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                                pair = (toString(value) + "e").split("e");
                                return +(pair[0] + "e" + (+pair[1] - precision));
                            }
                            return func(number);
                        };
                    }
                    var createSet = !(Set && 1 / setToArray(new Set([ , -0 ]))[1] == INFINITY) ? noop : function(values) {
                        return new Set(values);
                    };
                    function createToPairs(keysFunc) {
                        return function(object) {
                            var tag = getTag(object);
                            if (tag == mapTag) {
                                return mapToArray(object);
                            }
                            if (tag == setTag) {
                                return setToPairs(object);
                            }
                            return baseToPairs(object, keysFunc(object));
                        };
                    }
                    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
                        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
                        if (!isBindKey && typeof func != "function") {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        var length = partials ? partials.length : 0;
                        if (!length) {
                            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
                            partials = holders = undefined;
                        }
                        ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
                        arity = arity === undefined ? arity : toInteger(arity);
                        length -= holders ? holders.length : 0;
                        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                            var partialsRight = partials, holdersRight = holders;
                            partials = holders = undefined;
                        }
                        var data = isBindKey ? undefined : getData(func);
                        var newData = [ func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity ];
                        if (data) {
                            mergeData(newData, data);
                        }
                        func = newData[0];
                        bitmask = newData[1];
                        thisArg = newData[2];
                        partials = newData[3];
                        holders = newData[4];
                        arity = newData[9] = newData[9] === undefined ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
                        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
                            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
                        }
                        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
                            var result = createBind(func, bitmask, thisArg);
                        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
                            result = createCurry(func, bitmask, arity);
                        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
                            result = createPartial(func, bitmask, thisArg, partials);
                        } else {
                            result = createHybrid.apply(undefined, newData);
                        }
                        var setter = data ? baseSetData : setData;
                        return setWrapToString(setter(result, newData), func, bitmask);
                    }
                    function customDefaultsAssignIn(objValue, srcValue, key, object) {
                        if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                            return srcValue;
                        }
                        return objValue;
                    }
                    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
                        if (isObject(objValue) && isObject(srcValue)) {
                            stack.set(srcValue, objValue);
                            baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
                            stack["delete"](srcValue);
                        }
                        return objValue;
                    }
                    function customOmitClone(value) {
                        return isPlainObject(value) ? undefined : value;
                    }
                    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
                        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                            return false;
                        }
                        var arrStacked = stack.get(array);
                        var othStacked = stack.get(other);
                        if (arrStacked && othStacked) {
                            return arrStacked == other && othStacked == array;
                        }
                        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache : undefined;
                        stack.set(array, other);
                        stack.set(other, array);
                        while (++index < arrLength) {
                            var arrValue = array[index], othValue = other[index];
                            if (customizer) {
                                var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                            }
                            if (compared !== undefined) {
                                if (compared) {
                                    continue;
                                }
                                result = false;
                                break;
                            }
                            if (seen) {
                                if (!arraySome(other, (function(othValue, othIndex) {
                                    if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                                        return seen.push(othIndex);
                                    }
                                }))) {
                                    result = false;
                                    break;
                                }
                            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                                result = false;
                                break;
                            }
                        }
                        stack["delete"](array);
                        stack["delete"](other);
                        return result;
                    }
                    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                        switch (tag) {
                          case dataViewTag:
                            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                                return false;
                            }
                            object = object.buffer;
                            other = other.buffer;

                          case arrayBufferTag:
                            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                                return false;
                            }
                            return true;

                          case boolTag:
                          case dateTag:
                          case numberTag:
                            return eq(+object, +other);

                          case errorTag:
                            return object.name == other.name && object.message == other.message;

                          case regexpTag:
                          case stringTag:
                            return object == other + "";

                          case mapTag:
                            var convert = mapToArray;

                          case setTag:
                            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                            convert || (convert = setToArray);
                            if (object.size != other.size && !isPartial) {
                                return false;
                            }
                            var stacked = stack.get(object);
                            if (stacked) {
                                return stacked == other;
                            }
                            bitmask |= COMPARE_UNORDERED_FLAG;
                            stack.set(object, other);
                            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                            stack["delete"](object);
                            return result;

                          case symbolTag:
                            if (symbolValueOf) {
                                return symbolValueOf.call(object) == symbolValueOf.call(other);
                            }
                        }
                        return false;
                    }
                    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
                        if (objLength != othLength && !isPartial) {
                            return false;
                        }
                        var index = objLength;
                        while (index--) {
                            var key = objProps[index];
                            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                                return false;
                            }
                        }
                        var objStacked = stack.get(object);
                        var othStacked = stack.get(other);
                        if (objStacked && othStacked) {
                            return objStacked == other && othStacked == object;
                        }
                        var result = true;
                        stack.set(object, other);
                        stack.set(other, object);
                        var skipCtor = isPartial;
                        while (++index < objLength) {
                            key = objProps[index];
                            var objValue = object[key], othValue = other[key];
                            if (customizer) {
                                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                            }
                            if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                                result = false;
                                break;
                            }
                            skipCtor || (skipCtor = key == "constructor");
                        }
                        if (result && !skipCtor) {
                            var objCtor = object.constructor, othCtor = other.constructor;
                            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                                result = false;
                            }
                        }
                        stack["delete"](object);
                        stack["delete"](other);
                        return result;
                    }
                    function flatRest(func) {
                        return setToString(overRest(func, undefined, flatten), func + "");
                    }
                    function getAllKeys(object) {
                        return baseGetAllKeys(object, keys, getSymbols);
                    }
                    function getAllKeysIn(object) {
                        return baseGetAllKeys(object, keysIn, getSymbolsIn);
                    }
                    var getData = !metaMap ? noop : function(func) {
                        return metaMap.get(func);
                    };
                    function getFuncName(func) {
                        var result = func.name + "", array = realNames[result], length = hasOwnProperty.call(realNames, result) ? array.length : 0;
                        while (length--) {
                            var data = array[length], otherFunc = data.func;
                            if (otherFunc == null || otherFunc == func) {
                                return data.name;
                            }
                        }
                        return result;
                    }
                    function getHolder(func) {
                        var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
                        return object.placeholder;
                    }
                    function getIteratee() {
                        var result = lodash.iteratee || iteratee;
                        result = result === iteratee ? baseIteratee : result;
                        return arguments.length ? result(arguments[0], arguments[1]) : result;
                    }
                    function getMapData(map, key) {
                        var data = map.__data__;
                        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
                    }
                    function getMatchData(object) {
                        var result = keys(object), length = result.length;
                        while (length--) {
                            var key = result[length], value = object[key];
                            result[length] = [ key, value, isStrictComparable(value) ];
                        }
                        return result;
                    }
                    function getNative(object, key) {
                        var value = getValue(object, key);
                        return baseIsNative(value) ? value : undefined;
                    }
                    function getRawTag(value) {
                        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                        try {
                            value[symToStringTag] = undefined;
                            var unmasked = true;
                        } catch (e) {}
                        var result = nativeObjectToString.call(value);
                        if (unmasked) {
                            if (isOwn) {
                                value[symToStringTag] = tag;
                            } else {
                                delete value[symToStringTag];
                            }
                        }
                        return result;
                    }
                    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
                        if (object == null) {
                            return [];
                        }
                        object = Object(object);
                        return arrayFilter(nativeGetSymbols(object), (function(symbol) {
                            return propertyIsEnumerable.call(object, symbol);
                        }));
                    };
                    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
                        var result = [];
                        while (object) {
                            arrayPush(result, getSymbols(object));
                            object = getPrototype(object);
                        }
                        return result;
                    };
                    var getTag = baseGetTag;
                    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) {
                        getTag = function(value) {
                            var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : "";
                            if (ctorString) {
                                switch (ctorString) {
                                  case dataViewCtorString:
                                    return dataViewTag;

                                  case mapCtorString:
                                    return mapTag;

                                  case promiseCtorString:
                                    return promiseTag;

                                  case setCtorString:
                                    return setTag;

                                  case weakMapCtorString:
                                    return weakMapTag;
                                }
                            }
                            return result;
                        };
                    }
                    function getView(start, end, transforms) {
                        var index = -1, length = transforms.length;
                        while (++index < length) {
                            var data = transforms[index], size = data.size;
                            switch (data.type) {
                              case "drop":
                                start += size;
                                break;

                              case "dropRight":
                                end -= size;
                                break;

                              case "take":
                                end = nativeMin(end, start + size);
                                break;

                              case "takeRight":
                                start = nativeMax(start, end - size);
                                break;
                            }
                        }
                        return {
                            start: start,
                            end: end
                        };
                    }
                    function getWrapDetails(source) {
                        var match = source.match(reWrapDetails);
                        return match ? match[1].split(reSplitDetails) : [];
                    }
                    function hasPath(object, path, hasFunc) {
                        path = castPath(path, object);
                        var index = -1, length = path.length, result = false;
                        while (++index < length) {
                            var key = toKey(path[index]);
                            if (!(result = object != null && hasFunc(object, key))) {
                                break;
                            }
                            object = object[key];
                        }
                        if (result || ++index != length) {
                            return result;
                        }
                        length = object == null ? 0 : object.length;
                        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
                    }
                    function initCloneArray(array) {
                        var length = array.length, result = new array.constructor(length);
                        if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
                            result.index = array.index;
                            result.input = array.input;
                        }
                        return result;
                    }
                    function initCloneObject(object) {
                        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
                    }
                    function initCloneByTag(object, tag, isDeep) {
                        var Ctor = object.constructor;
                        switch (tag) {
                          case arrayBufferTag:
                            return cloneArrayBuffer(object);

                          case boolTag:
                          case dateTag:
                            return new Ctor(+object);

                          case dataViewTag:
                            return cloneDataView(object, isDeep);

                          case float32Tag:
                          case float64Tag:
                          case int8Tag:
                          case int16Tag:
                          case int32Tag:
                          case uint8Tag:
                          case uint8ClampedTag:
                          case uint16Tag:
                          case uint32Tag:
                            return cloneTypedArray(object, isDeep);

                          case mapTag:
                            return new Ctor;

                          case numberTag:
                          case stringTag:
                            return new Ctor(object);

                          case regexpTag:
                            return cloneRegExp(object);

                          case setTag:
                            return new Ctor;

                          case symbolTag:
                            return cloneSymbol(object);
                        }
                    }
                    function insertWrapDetails(source, details) {
                        var length = details.length;
                        if (!length) {
                            return source;
                        }
                        var lastIndex = length - 1;
                        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
                        details = details.join(length > 2 ? ", " : " ");
                        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
                    }
                    function isFlattenable(value) {
                        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
                    }
                    function isIndex(value, length) {
                        var type = typeof value;
                        length = length == null ? MAX_SAFE_INTEGER : length;
                        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
                    }
                    function isIterateeCall(value, index, object) {
                        if (!isObject(object)) {
                            return false;
                        }
                        var type = typeof index;
                        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
                            return eq(object[index], value);
                        }
                        return false;
                    }
                    function isKey(value, object) {
                        if (isArray(value)) {
                            return false;
                        }
                        var type = typeof value;
                        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
                            return true;
                        }
                        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
                    }
                    function isKeyable(value) {
                        var type = typeof value;
                        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
                    }
                    function isLaziable(func) {
                        var funcName = getFuncName(func), other = lodash[funcName];
                        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
                            return false;
                        }
                        if (func === other) {
                            return true;
                        }
                        var data = getData(other);
                        return !!data && func === data[0];
                    }
                    function isMasked(func) {
                        return !!maskSrcKey && maskSrcKey in func;
                    }
                    var isMaskable = coreJsData ? isFunction : stubFalse;
                    function isPrototype(value) {
                        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
                        return value === proto;
                    }
                    function isStrictComparable(value) {
                        return value === value && !isObject(value);
                    }
                    function matchesStrictComparable(key, srcValue) {
                        return function(object) {
                            if (object == null) {
                                return false;
                            }
                            return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
                        };
                    }
                    function memoizeCapped(func) {
                        var result = memoize(func, (function(key) {
                            if (cache.size === MAX_MEMOIZE_SIZE) {
                                cache.clear();
                            }
                            return key;
                        }));
                        var cache = result.cache;
                        return result;
                    }
                    function mergeData(data, source) {
                        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
                        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
                        if (!(isCommon || isCombo)) {
                            return data;
                        }
                        if (srcBitmask & WRAP_BIND_FLAG) {
                            data[2] = source[2];
                            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
                        }
                        var value = source[3];
                        if (value) {
                            var partials = data[3];
                            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
                            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
                        }
                        value = source[5];
                        if (value) {
                            partials = data[5];
                            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
                            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
                        }
                        value = source[7];
                        if (value) {
                            data[7] = value;
                        }
                        if (srcBitmask & WRAP_ARY_FLAG) {
                            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                        }
                        if (data[9] == null) {
                            data[9] = source[9];
                        }
                        data[0] = source[0];
                        data[1] = newBitmask;
                        return data;
                    }
                    function nativeKeysIn(object) {
                        var result = [];
                        if (object != null) {
                            for (var key in Object(object)) {
                                result.push(key);
                            }
                        }
                        return result;
                    }
                    function objectToString(value) {
                        return nativeObjectToString.call(value);
                    }
                    function overRest(func, start, transform) {
                        start = nativeMax(start === undefined ? func.length - 1 : start, 0);
                        return function() {
                            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
                            while (++index < length) {
                                array[index] = args[start + index];
                            }
                            index = -1;
                            var otherArgs = Array(start + 1);
                            while (++index < start) {
                                otherArgs[index] = args[index];
                            }
                            otherArgs[start] = transform(array);
                            return apply(func, this, otherArgs);
                        };
                    }
                    function parent(object, path) {
                        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
                    }
                    function reorder(array, indexes) {
                        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
                        while (length--) {
                            var index = indexes[length];
                            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
                        }
                        return array;
                    }
                    function safeGet(object, key) {
                        if (key === "constructor" && typeof object[key] === "function") {
                            return;
                        }
                        if (key == "__proto__") {
                            return;
                        }
                        return object[key];
                    }
                    var setData = shortOut(baseSetData);
                    var setTimeout = ctxSetTimeout || function(func, wait) {
                        return root.setTimeout(func, wait);
                    };
                    var setToString = shortOut(baseSetToString);
                    function setWrapToString(wrapper, reference, bitmask) {
                        var source = reference + "";
                        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
                    }
                    function shortOut(func) {
                        var count = 0, lastCalled = 0;
                        return function() {
                            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                            lastCalled = stamp;
                            if (remaining > 0) {
                                if (++count >= HOT_COUNT) {
                                    return arguments[0];
                                }
                            } else {
                                count = 0;
                            }
                            return func.apply(undefined, arguments);
                        };
                    }
                    function shuffleSelf(array, size) {
                        var index = -1, length = array.length, lastIndex = length - 1;
                        size = size === undefined ? length : size;
                        while (++index < size) {
                            var rand = baseRandom(index, lastIndex), value = array[rand];
                            array[rand] = array[index];
                            array[index] = value;
                        }
                        array.length = size;
                        return array;
                    }
                    var stringToPath = memoizeCapped((function(string) {
                        var result = [];
                        if (string.charCodeAt(0) === 46) {
                            result.push("");
                        }
                        string.replace(rePropName, (function(match, number, quote, subString) {
                            result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
                        }));
                        return result;
                    }));
                    function toKey(value) {
                        if (typeof value == "string" || isSymbol(value)) {
                            return value;
                        }
                        var result = value + "";
                        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
                    }
                    function toSource(func) {
                        if (func != null) {
                            try {
                                return funcToString.call(func);
                            } catch (e) {}
                            try {
                                return func + "";
                            } catch (e) {}
                        }
                        return "";
                    }
                    function updateWrapDetails(details, bitmask) {
                        arrayEach(wrapFlags, (function(pair) {
                            var value = "_." + pair[0];
                            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                                details.push(value);
                            }
                        }));
                        return details.sort();
                    }
                    function wrapperClone(wrapper) {
                        if (wrapper instanceof LazyWrapper) {
                            return wrapper.clone();
                        }
                        var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
                        result.__actions__ = copyArray(wrapper.__actions__);
                        result.__index__ = wrapper.__index__;
                        result.__values__ = wrapper.__values__;
                        return result;
                    }
                    function chunk(array, size, guard) {
                        if (guard ? isIterateeCall(array, size, guard) : size === undefined) {
                            size = 1;
                        } else {
                            size = nativeMax(toInteger(size), 0);
                        }
                        var length = array == null ? 0 : array.length;
                        if (!length || size < 1) {
                            return [];
                        }
                        var index = 0, resIndex = 0, result = Array(nativeCeil(length / size));
                        while (index < length) {
                            result[resIndex++] = baseSlice(array, index, index += size);
                        }
                        return result;
                    }
                    function compact(array) {
                        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
                        while (++index < length) {
                            var value = array[index];
                            if (value) {
                                result[resIndex++] = value;
                            }
                        }
                        return result;
                    }
                    function concat() {
                        var length = arguments.length;
                        if (!length) {
                            return [];
                        }
                        var args = Array(length - 1), array = arguments[0], index = length;
                        while (index--) {
                            args[index - 1] = arguments[index];
                        }
                        return arrayPush(isArray(array) ? copyArray(array) : [ array ], baseFlatten(args, 1));
                    }
                    var difference = baseRest((function(array, values) {
                        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
                    }));
                    var differenceBy = baseRest((function(array, values) {
                        var iteratee = last(values);
                        if (isArrayLikeObject(iteratee)) {
                            iteratee = undefined;
                        }
                        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2)) : [];
                    }));
                    var differenceWith = baseRest((function(array, values) {
                        var comparator = last(values);
                        if (isArrayLikeObject(comparator)) {
                            comparator = undefined;
                        }
                        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : [];
                    }));
                    function drop(array, n, guard) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                            return [];
                        }
                        n = guard || n === undefined ? 1 : toInteger(n);
                        return baseSlice(array, n < 0 ? 0 : n, length);
                    }
                    function dropRight(array, n, guard) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                            return [];
                        }
                        n = guard || n === undefined ? 1 : toInteger(n);
                        n = length - n;
                        return baseSlice(array, 0, n < 0 ? 0 : n);
                    }
                    function dropRightWhile(array, predicate) {
                        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
                    }
                    function dropWhile(array, predicate) {
                        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
                    }
                    function fill(array, value, start, end) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                            return [];
                        }
                        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
                            start = 0;
                            end = length;
                        }
                        return baseFill(array, value, start, end);
                    }
                    function findIndex(array, predicate, fromIndex) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                            return -1;
                        }
                        var index = fromIndex == null ? 0 : toInteger(fromIndex);
                        if (index < 0) {
                            index = nativeMax(length + index, 0);
                        }
                        return baseFindIndex(array, getIteratee(predicate, 3), index);
                    }
                    function findLastIndex(array, predicate, fromIndex) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                            return -1;
                        }
                        var index = length - 1;
                        if (fromIndex !== undefined) {
                            index = toInteger(fromIndex);
                            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
                        }
                        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
                    }
                    function flatten(array) {
                        var length = array == null ? 0 : array.length;
                        return length ? baseFlatten(array, 1) : [];
                    }
                    function flattenDeep(array) {
                        var length = array == null ? 0 : array.length;
                        return length ? baseFlatten(array, INFINITY) : [];
                    }
                    function flattenDepth(array, depth) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                            return [];
                        }
                        depth = depth === undefined ? 1 : toInteger(depth);
                        return baseFlatten(array, depth);
                    }
                    function fromPairs(pairs) {
                        var index = -1, length = pairs == null ? 0 : pairs.length, result = {};
                        while (++index < length) {
                            var pair = pairs[index];
                            result[pair[0]] = pair[1];
                        }
                        return result;
                    }
                    function head(array) {
                        return array && array.length ? array[0] : undefined;
                    }
                    function indexOf(array, value, fromIndex) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                            return -1;
                        }
                        var index = fromIndex == null ? 0 : toInteger(fromIndex);
                        if (index < 0) {
                            index = nativeMax(length + index, 0);
                        }
                        return baseIndexOf(array, value, index);
                    }
                    function initial(array) {
                        var length = array == null ? 0 : array.length;
                        return length ? baseSlice(array, 0, -1) : [];
                    }
                    var intersection = baseRest((function(arrays) {
                        var mapped = arrayMap(arrays, castArrayLikeObject);
                        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
                    }));
                    var intersectionBy = baseRest((function(arrays) {
                        var iteratee = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                        if (iteratee === last(mapped)) {
                            iteratee = undefined;
                        } else {
                            mapped.pop();
                        }
                        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee, 2)) : [];
                    }));
                    var intersectionWith = baseRest((function(arrays) {
                        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                        comparator = typeof comparator == "function" ? comparator : undefined;
                        if (comparator) {
                            mapped.pop();
                        }
                        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : [];
                    }));
                    function join(array, separator) {
                        return array == null ? "" : nativeJoin.call(array, separator);
                    }
                    function last(array) {
                        var length = array == null ? 0 : array.length;
                        return length ? array[length - 1] : undefined;
                    }
                    function lastIndexOf(array, value, fromIndex) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                            return -1;
                        }
                        var index = length;
                        if (fromIndex !== undefined) {
                            index = toInteger(fromIndex);
                            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
                        }
                        return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
                    }
                    function nth(array, n) {
                        return array && array.length ? baseNth(array, toInteger(n)) : undefined;
                    }
                    var pull = baseRest(pullAll);
                    function pullAll(array, values) {
                        return array && array.length && values && values.length ? basePullAll(array, values) : array;
                    }
                    function pullAllBy(array, values, iteratee) {
                        return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee, 2)) : array;
                    }
                    function pullAllWith(array, values, comparator) {
                        return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array;
                    }
                    var pullAt = flatRest((function(array, indexes) {
                        var length = array == null ? 0 : array.length, result = baseAt(array, indexes);
                        basePullAt(array, arrayMap(indexes, (function(index) {
                            return isIndex(index, length) ? +index : index;
                        })).sort(compareAscending));
                        return result;
                    }));
                    function remove(array, predicate) {
                        var result = [];
                        if (!(array && array.length)) {
                            return result;
                        }
                        var index = -1, indexes = [], length = array.length;
                        predicate = getIteratee(predicate, 3);
                        while (++index < length) {
                            var value = array[index];
                            if (predicate(value, index, array)) {
                                result.push(value);
                                indexes.push(index);
                            }
                        }
                        basePullAt(array, indexes);
                        return result;
                    }
                    function reverse(array) {
                        return array == null ? array : nativeReverse.call(array);
                    }
                    function slice(array, start, end) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                            return [];
                        }
                        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
                            start = 0;
                            end = length;
                        } else {
                            start = start == null ? 0 : toInteger(start);
                            end = end === undefined ? length : toInteger(end);
                        }
                        return baseSlice(array, start, end);
                    }
                    function sortedIndex(array, value) {
                        return baseSortedIndex(array, value);
                    }
                    function sortedIndexBy(array, value, iteratee) {
                        return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
                    }
                    function sortedIndexOf(array, value) {
                        var length = array == null ? 0 : array.length;
                        if (length) {
                            var index = baseSortedIndex(array, value);
                            if (index < length && eq(array[index], value)) {
                                return index;
                            }
                        }
                        return -1;
                    }
                    function sortedLastIndex(array, value) {
                        return baseSortedIndex(array, value, true);
                    }
                    function sortedLastIndexBy(array, value, iteratee) {
                        return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
                    }
                    function sortedLastIndexOf(array, value) {
                        var length = array == null ? 0 : array.length;
                        if (length) {
                            var index = baseSortedIndex(array, value, true) - 1;
                            if (eq(array[index], value)) {
                                return index;
                            }
                        }
                        return -1;
                    }
                    function sortedUniq(array) {
                        return array && array.length ? baseSortedUniq(array) : [];
                    }
                    function sortedUniqBy(array, iteratee) {
                        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee, 2)) : [];
                    }
                    function tail(array) {
                        var length = array == null ? 0 : array.length;
                        return length ? baseSlice(array, 1, length) : [];
                    }
                    function take(array, n, guard) {
                        if (!(array && array.length)) {
                            return [];
                        }
                        n = guard || n === undefined ? 1 : toInteger(n);
                        return baseSlice(array, 0, n < 0 ? 0 : n);
                    }
                    function takeRight(array, n, guard) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                            return [];
                        }
                        n = guard || n === undefined ? 1 : toInteger(n);
                        n = length - n;
                        return baseSlice(array, n < 0 ? 0 : n, length);
                    }
                    function takeRightWhile(array, predicate) {
                        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
                    }
                    function takeWhile(array, predicate) {
                        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
                    }
                    var union = baseRest((function(arrays) {
                        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
                    }));
                    var unionBy = baseRest((function(arrays) {
                        var iteratee = last(arrays);
                        if (isArrayLikeObject(iteratee)) {
                            iteratee = undefined;
                        }
                        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
                    }));
                    var unionWith = baseRest((function(arrays) {
                        var comparator = last(arrays);
                        comparator = typeof comparator == "function" ? comparator : undefined;
                        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
                    }));
                    function uniq(array) {
                        return array && array.length ? baseUniq(array) : [];
                    }
                    function uniqBy(array, iteratee) {
                        return array && array.length ? baseUniq(array, getIteratee(iteratee, 2)) : [];
                    }
                    function uniqWith(array, comparator) {
                        comparator = typeof comparator == "function" ? comparator : undefined;
                        return array && array.length ? baseUniq(array, undefined, comparator) : [];
                    }
                    function unzip(array) {
                        if (!(array && array.length)) {
                            return [];
                        }
                        var length = 0;
                        array = arrayFilter(array, (function(group) {
                            if (isArrayLikeObject(group)) {
                                length = nativeMax(group.length, length);
                                return true;
                            }
                        }));
                        return baseTimes(length, (function(index) {
                            return arrayMap(array, baseProperty(index));
                        }));
                    }
                    function unzipWith(array, iteratee) {
                        if (!(array && array.length)) {
                            return [];
                        }
                        var result = unzip(array);
                        if (iteratee == null) {
                            return result;
                        }
                        return arrayMap(result, (function(group) {
                            return apply(iteratee, undefined, group);
                        }));
                    }
                    var without = baseRest((function(array, values) {
                        return isArrayLikeObject(array) ? baseDifference(array, values) : [];
                    }));
                    var xor = baseRest((function(arrays) {
                        return baseXor(arrayFilter(arrays, isArrayLikeObject));
                    }));
                    var xorBy = baseRest((function(arrays) {
                        var iteratee = last(arrays);
                        if (isArrayLikeObject(iteratee)) {
                            iteratee = undefined;
                        }
                        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
                    }));
                    var xorWith = baseRest((function(arrays) {
                        var comparator = last(arrays);
                        comparator = typeof comparator == "function" ? comparator : undefined;
                        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
                    }));
                    var zip = baseRest(unzip);
                    function zipObject(props, values) {
                        return baseZipObject(props || [], values || [], assignValue);
                    }
                    function zipObjectDeep(props, values) {
                        return baseZipObject(props || [], values || [], baseSet);
                    }
                    var zipWith = baseRest((function(arrays) {
                        var length = arrays.length, iteratee = length > 1 ? arrays[length - 1] : undefined;
                        iteratee = typeof iteratee == "function" ? (arrays.pop(), iteratee) : undefined;
                        return unzipWith(arrays, iteratee);
                    }));
                    function chain(value) {
                        var result = lodash(value);
                        result.__chain__ = true;
                        return result;
                    }
                    function tap(value, interceptor) {
                        interceptor(value);
                        return value;
                    }
                    function thru(value, interceptor) {
                        return interceptor(value);
                    }
                    var wrapperAt = flatRest((function(paths) {
                        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
                            return baseAt(object, paths);
                        };
                        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
                            return this.thru(interceptor);
                        }
                        value = value.slice(start, +start + (length ? 1 : 0));
                        value.__actions__.push({
                            func: thru,
                            args: [ interceptor ],
                            thisArg: undefined
                        });
                        return new LodashWrapper(value, this.__chain__).thru((function(array) {
                            if (length && !array.length) {
                                array.push(undefined);
                            }
                            return array;
                        }));
                    }));
                    function wrapperChain() {
                        return chain(this);
                    }
                    function wrapperCommit() {
                        return new LodashWrapper(this.value(), this.__chain__);
                    }
                    function wrapperNext() {
                        if (this.__values__ === undefined) {
                            this.__values__ = toArray(this.value());
                        }
                        var done = this.__index__ >= this.__values__.length, value = done ? undefined : this.__values__[this.__index__++];
                        return {
                            done: done,
                            value: value
                        };
                    }
                    function wrapperToIterator() {
                        return this;
                    }
                    function wrapperPlant(value) {
                        var result, parent = this;
                        while (parent instanceof baseLodash) {
                            var clone = wrapperClone(parent);
                            clone.__index__ = 0;
                            clone.__values__ = undefined;
                            if (result) {
                                previous.__wrapped__ = clone;
                            } else {
                                result = clone;
                            }
                            var previous = clone;
                            parent = parent.__wrapped__;
                        }
                        previous.__wrapped__ = value;
                        return result;
                    }
                    function wrapperReverse() {
                        var value = this.__wrapped__;
                        if (value instanceof LazyWrapper) {
                            var wrapped = value;
                            if (this.__actions__.length) {
                                wrapped = new LazyWrapper(this);
                            }
                            wrapped = wrapped.reverse();
                            wrapped.__actions__.push({
                                func: thru,
                                args: [ reverse ],
                                thisArg: undefined
                            });
                            return new LodashWrapper(wrapped, this.__chain__);
                        }
                        return this.thru(reverse);
                    }
                    function wrapperValue() {
                        return baseWrapperValue(this.__wrapped__, this.__actions__);
                    }
                    var countBy = createAggregator((function(result, value, key) {
                        if (hasOwnProperty.call(result, key)) {
                            ++result[key];
                        } else {
                            baseAssignValue(result, key, 1);
                        }
                    }));
                    function every(collection, predicate, guard) {
                        var func = isArray(collection) ? arrayEvery : baseEvery;
                        if (guard && isIterateeCall(collection, predicate, guard)) {
                            predicate = undefined;
                        }
                        return func(collection, getIteratee(predicate, 3));
                    }
                    function filter(collection, predicate) {
                        var func = isArray(collection) ? arrayFilter : baseFilter;
                        return func(collection, getIteratee(predicate, 3));
                    }
                    var find = createFind(findIndex);
                    var findLast = createFind(findLastIndex);
                    function flatMap(collection, iteratee) {
                        return baseFlatten(map(collection, iteratee), 1);
                    }
                    function flatMapDeep(collection, iteratee) {
                        return baseFlatten(map(collection, iteratee), INFINITY);
                    }
                    function flatMapDepth(collection, iteratee, depth) {
                        depth = depth === undefined ? 1 : toInteger(depth);
                        return baseFlatten(map(collection, iteratee), depth);
                    }
                    function forEach(collection, iteratee) {
                        var func = isArray(collection) ? arrayEach : baseEach;
                        return func(collection, getIteratee(iteratee, 3));
                    }
                    function forEachRight(collection, iteratee) {
                        var func = isArray(collection) ? arrayEachRight : baseEachRight;
                        return func(collection, getIteratee(iteratee, 3));
                    }
                    var groupBy = createAggregator((function(result, value, key) {
                        if (hasOwnProperty.call(result, key)) {
                            result[key].push(value);
                        } else {
                            baseAssignValue(result, key, [ value ]);
                        }
                    }));
                    function includes(collection, value, fromIndex, guard) {
                        collection = isArrayLike(collection) ? collection : values(collection);
                        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
                        var length = collection.length;
                        if (fromIndex < 0) {
                            fromIndex = nativeMax(length + fromIndex, 0);
                        }
                        return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
                    }
                    var invokeMap = baseRest((function(collection, path, args) {
                        var index = -1, isFunc = typeof path == "function", result = isArrayLike(collection) ? Array(collection.length) : [];
                        baseEach(collection, (function(value) {
                            result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
                        }));
                        return result;
                    }));
                    var keyBy = createAggregator((function(result, value, key) {
                        baseAssignValue(result, key, value);
                    }));
                    function map(collection, iteratee) {
                        var func = isArray(collection) ? arrayMap : baseMap;
                        return func(collection, getIteratee(iteratee, 3));
                    }
                    function orderBy(collection, iteratees, orders, guard) {
                        if (collection == null) {
                            return [];
                        }
                        if (!isArray(iteratees)) {
                            iteratees = iteratees == null ? [] : [ iteratees ];
                        }
                        orders = guard ? undefined : orders;
                        if (!isArray(orders)) {
                            orders = orders == null ? [] : [ orders ];
                        }
                        return baseOrderBy(collection, iteratees, orders);
                    }
                    var partition = createAggregator((function(result, value, key) {
                        result[key ? 0 : 1].push(value);
                    }), (function() {
                        return [ [], [] ];
                    }));
                    function reduce(collection, iteratee, accumulator) {
                        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
                        return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
                    }
                    function reduceRight(collection, iteratee, accumulator) {
                        var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
                        return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
                    }
                    function reject(collection, predicate) {
                        var func = isArray(collection) ? arrayFilter : baseFilter;
                        return func(collection, negate(getIteratee(predicate, 3)));
                    }
                    function sample(collection) {
                        var func = isArray(collection) ? arraySample : baseSample;
                        return func(collection);
                    }
                    function sampleSize(collection, n, guard) {
                        if (guard ? isIterateeCall(collection, n, guard) : n === undefined) {
                            n = 1;
                        } else {
                            n = toInteger(n);
                        }
                        var func = isArray(collection) ? arraySampleSize : baseSampleSize;
                        return func(collection, n);
                    }
                    function shuffle(collection) {
                        var func = isArray(collection) ? arrayShuffle : baseShuffle;
                        return func(collection);
                    }
                    function size(collection) {
                        if (collection == null) {
                            return 0;
                        }
                        if (isArrayLike(collection)) {
                            return isString(collection) ? stringSize(collection) : collection.length;
                        }
                        var tag = getTag(collection);
                        if (tag == mapTag || tag == setTag) {
                            return collection.size;
                        }
                        return baseKeys(collection).length;
                    }
                    function some(collection, predicate, guard) {
                        var func = isArray(collection) ? arraySome : baseSome;
                        if (guard && isIterateeCall(collection, predicate, guard)) {
                            predicate = undefined;
                        }
                        return func(collection, getIteratee(predicate, 3));
                    }
                    var sortBy = baseRest((function(collection, iteratees) {
                        if (collection == null) {
                            return [];
                        }
                        var length = iteratees.length;
                        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
                            iteratees = [];
                        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
                            iteratees = [ iteratees[0] ];
                        }
                        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
                    }));
                    var now = ctxNow || function() {
                        return root.Date.now();
                    };
                    function after(n, func) {
                        if (typeof func != "function") {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        n = toInteger(n);
                        return function() {
                            if (--n < 1) {
                                return func.apply(this, arguments);
                            }
                        };
                    }
                    function ary(func, n, guard) {
                        n = guard ? undefined : n;
                        n = func && n == null ? func.length : n;
                        return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
                    }
                    function before(n, func) {
                        var result;
                        if (typeof func != "function") {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        n = toInteger(n);
                        return function() {
                            if (--n > 0) {
                                result = func.apply(this, arguments);
                            }
                            if (n <= 1) {
                                func = undefined;
                            }
                            return result;
                        };
                    }
                    var bind = baseRest((function(func, thisArg, partials) {
                        var bitmask = WRAP_BIND_FLAG;
                        if (partials.length) {
                            var holders = replaceHolders(partials, getHolder(bind));
                            bitmask |= WRAP_PARTIAL_FLAG;
                        }
                        return createWrap(func, bitmask, thisArg, partials, holders);
                    }));
                    var bindKey = baseRest((function(object, key, partials) {
                        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
                        if (partials.length) {
                            var holders = replaceHolders(partials, getHolder(bindKey));
                            bitmask |= WRAP_PARTIAL_FLAG;
                        }
                        return createWrap(key, bitmask, object, partials, holders);
                    }));
                    function curry(func, arity, guard) {
                        arity = guard ? undefined : arity;
                        var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                        result.placeholder = curry.placeholder;
                        return result;
                    }
                    function curryRight(func, arity, guard) {
                        arity = guard ? undefined : arity;
                        var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                        result.placeholder = curryRight.placeholder;
                        return result;
                    }
                    function debounce(func, wait, options) {
                        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
                        if (typeof func != "function") {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        wait = toNumber(wait) || 0;
                        if (isObject(options)) {
                            leading = !!options.leading;
                            maxing = "maxWait" in options;
                            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                            trailing = "trailing" in options ? !!options.trailing : trailing;
                        }
                        function invokeFunc(time) {
                            var args = lastArgs, thisArg = lastThis;
                            lastArgs = lastThis = undefined;
                            lastInvokeTime = time;
                            result = func.apply(thisArg, args);
                            return result;
                        }
                        function leadingEdge(time) {
                            lastInvokeTime = time;
                            timerId = setTimeout(timerExpired, wait);
                            return leading ? invokeFunc(time) : result;
                        }
                        function remainingWait(time) {
                            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
                            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
                        }
                        function shouldInvoke(time) {
                            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                            return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
                        }
                        function timerExpired() {
                            var time = now();
                            if (shouldInvoke(time)) {
                                return trailingEdge(time);
                            }
                            timerId = setTimeout(timerExpired, remainingWait(time));
                        }
                        function trailingEdge(time) {
                            timerId = undefined;
                            if (trailing && lastArgs) {
                                return invokeFunc(time);
                            }
                            lastArgs = lastThis = undefined;
                            return result;
                        }
                        function cancel() {
                            if (timerId !== undefined) {
                                clearTimeout(timerId);
                            }
                            lastInvokeTime = 0;
                            lastArgs = lastCallTime = lastThis = timerId = undefined;
                        }
                        function flush() {
                            return timerId === undefined ? result : trailingEdge(now());
                        }
                        function debounced() {
                            var time = now(), isInvoking = shouldInvoke(time);
                            lastArgs = arguments;
                            lastThis = this;
                            lastCallTime = time;
                            if (isInvoking) {
                                if (timerId === undefined) {
                                    return leadingEdge(lastCallTime);
                                }
                                if (maxing) {
                                    clearTimeout(timerId);
                                    timerId = setTimeout(timerExpired, wait);
                                    return invokeFunc(lastCallTime);
                                }
                            }
                            if (timerId === undefined) {
                                timerId = setTimeout(timerExpired, wait);
                            }
                            return result;
                        }
                        debounced.cancel = cancel;
                        debounced.flush = flush;
                        return debounced;
                    }
                    var defer = baseRest((function(func, args) {
                        return baseDelay(func, 1, args);
                    }));
                    var delay = baseRest((function(func, wait, args) {
                        return baseDelay(func, toNumber(wait) || 0, args);
                    }));
                    function flip(func) {
                        return createWrap(func, WRAP_FLIP_FLAG);
                    }
                    function memoize(func, resolver) {
                        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        var memoized = function() {
                            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                            if (cache.has(key)) {
                                return cache.get(key);
                            }
                            var result = func.apply(this, args);
                            memoized.cache = cache.set(key, result) || cache;
                            return result;
                        };
                        memoized.cache = new (memoize.Cache || MapCache);
                        return memoized;
                    }
                    memoize.Cache = MapCache;
                    function negate(predicate) {
                        if (typeof predicate != "function") {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        return function() {
                            var args = arguments;
                            switch (args.length) {
                              case 0:
                                return !predicate.call(this);

                              case 1:
                                return !predicate.call(this, args[0]);

                              case 2:
                                return !predicate.call(this, args[0], args[1]);

                              case 3:
                                return !predicate.call(this, args[0], args[1], args[2]);
                            }
                            return !predicate.apply(this, args);
                        };
                    }
                    function once(func) {
                        return before(2, func);
                    }
                    var overArgs = castRest((function(func, transforms) {
                        transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
                        var funcsLength = transforms.length;
                        return baseRest((function(args) {
                            var index = -1, length = nativeMin(args.length, funcsLength);
                            while (++index < length) {
                                args[index] = transforms[index].call(this, args[index]);
                            }
                            return apply(func, this, args);
                        }));
                    }));
                    var partial = baseRest((function(func, partials) {
                        var holders = replaceHolders(partials, getHolder(partial));
                        return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
                    }));
                    var partialRight = baseRest((function(func, partials) {
                        var holders = replaceHolders(partials, getHolder(partialRight));
                        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
                    }));
                    var rearg = flatRest((function(func, indexes) {
                        return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
                    }));
                    function rest(func, start) {
                        if (typeof func != "function") {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        start = start === undefined ? start : toInteger(start);
                        return baseRest(func, start);
                    }
                    function spread(func, start) {
                        if (typeof func != "function") {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        start = start == null ? 0 : nativeMax(toInteger(start), 0);
                        return baseRest((function(args) {
                            var array = args[start], otherArgs = castSlice(args, 0, start);
                            if (array) {
                                arrayPush(otherArgs, array);
                            }
                            return apply(func, this, otherArgs);
                        }));
                    }
                    function throttle(func, wait, options) {
                        var leading = true, trailing = true;
                        if (typeof func != "function") {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        if (isObject(options)) {
                            leading = "leading" in options ? !!options.leading : leading;
                            trailing = "trailing" in options ? !!options.trailing : trailing;
                        }
                        return debounce(func, wait, {
                            leading: leading,
                            maxWait: wait,
                            trailing: trailing
                        });
                    }
                    function unary(func) {
                        return ary(func, 1);
                    }
                    function wrap(value, wrapper) {
                        return partial(castFunction(wrapper), value);
                    }
                    function castArray() {
                        if (!arguments.length) {
                            return [];
                        }
                        var value = arguments[0];
                        return isArray(value) ? value : [ value ];
                    }
                    function clone(value) {
                        return baseClone(value, CLONE_SYMBOLS_FLAG);
                    }
                    function cloneWith(value, customizer) {
                        customizer = typeof customizer == "function" ? customizer : undefined;
                        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
                    }
                    function cloneDeep(value) {
                        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
                    }
                    function cloneDeepWith(value, customizer) {
                        customizer = typeof customizer == "function" ? customizer : undefined;
                        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
                    }
                    function conformsTo(object, source) {
                        return source == null || baseConformsTo(object, source, keys(source));
                    }
                    function eq(value, other) {
                        return value === other || value !== value && other !== other;
                    }
                    var gt = createRelationalOperation(baseGt);
                    var gte = createRelationalOperation((function(value, other) {
                        return value >= other;
                    }));
                    var isArguments = baseIsArguments(function() {
                        return arguments;
                    }()) ? baseIsArguments : function(value) {
                        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
                    };
                    var isArray = Array.isArray;
                    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
                    function isArrayLike(value) {
                        return value != null && isLength(value.length) && !isFunction(value);
                    }
                    function isArrayLikeObject(value) {
                        return isObjectLike(value) && isArrayLike(value);
                    }
                    function isBoolean(value) {
                        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
                    }
                    var isBuffer = nativeIsBuffer || stubFalse;
                    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
                    function isElement(value) {
                        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
                    }
                    function isEmpty(value) {
                        if (value == null) {
                            return true;
                        }
                        if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
                            return !value.length;
                        }
                        var tag = getTag(value);
                        if (tag == mapTag || tag == setTag) {
                            return !value.size;
                        }
                        if (isPrototype(value)) {
                            return !baseKeys(value).length;
                        }
                        for (var key in value) {
                            if (hasOwnProperty.call(value, key)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    function isEqual(value, other) {
                        return baseIsEqual(value, other);
                    }
                    function isEqualWith(value, other, customizer) {
                        customizer = typeof customizer == "function" ? customizer : undefined;
                        var result = customizer ? customizer(value, other) : undefined;
                        return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
                    }
                    function isError(value) {
                        if (!isObjectLike(value)) {
                            return false;
                        }
                        var tag = baseGetTag(value);
                        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
                    }
                    function isFinite(value) {
                        return typeof value == "number" && nativeIsFinite(value);
                    }
                    function isFunction(value) {
                        if (!isObject(value)) {
                            return false;
                        }
                        var tag = baseGetTag(value);
                        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
                    }
                    function isInteger(value) {
                        return typeof value == "number" && value == toInteger(value);
                    }
                    function isLength(value) {
                        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
                    }
                    function isObject(value) {
                        var type = typeof value;
                        return value != null && (type == "object" || type == "function");
                    }
                    function isObjectLike(value) {
                        return value != null && typeof value == "object";
                    }
                    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
                    function isMatch(object, source) {
                        return object === source || baseIsMatch(object, source, getMatchData(source));
                    }
                    function isMatchWith(object, source, customizer) {
                        customizer = typeof customizer == "function" ? customizer : undefined;
                        return baseIsMatch(object, source, getMatchData(source), customizer);
                    }
                    function isNaN(value) {
                        return isNumber(value) && value != +value;
                    }
                    function isNative(value) {
                        if (isMaskable(value)) {
                            throw new Error(CORE_ERROR_TEXT);
                        }
                        return baseIsNative(value);
                    }
                    function isNull(value) {
                        return value === null;
                    }
                    function isNil(value) {
                        return value == null;
                    }
                    function isNumber(value) {
                        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
                    }
                    function isPlainObject(value) {
                        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
                            return false;
                        }
                        var proto = getPrototype(value);
                        if (proto === null) {
                            return true;
                        }
                        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
                        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
                    }
                    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
                    function isSafeInteger(value) {
                        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
                    }
                    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
                    function isString(value) {
                        return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
                    }
                    function isSymbol(value) {
                        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
                    }
                    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
                    function isUndefined(value) {
                        return value === undefined;
                    }
                    function isWeakMap(value) {
                        return isObjectLike(value) && getTag(value) == weakMapTag;
                    }
                    function isWeakSet(value) {
                        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
                    }
                    var lt = createRelationalOperation(baseLt);
                    var lte = createRelationalOperation((function(value, other) {
                        return value <= other;
                    }));
                    function toArray(value) {
                        if (!value) {
                            return [];
                        }
                        if (isArrayLike(value)) {
                            return isString(value) ? stringToArray(value) : copyArray(value);
                        }
                        if (symIterator && value[symIterator]) {
                            return iteratorToArray(value[symIterator]());
                        }
                        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
                        return func(value);
                    }
                    function toFinite(value) {
                        if (!value) {
                            return value === 0 ? value : 0;
                        }
                        value = toNumber(value);
                        if (value === INFINITY || value === -INFINITY) {
                            var sign = value < 0 ? -1 : 1;
                            return sign * MAX_INTEGER;
                        }
                        return value === value ? value : 0;
                    }
                    function toInteger(value) {
                        var result = toFinite(value), remainder = result % 1;
                        return result === result ? remainder ? result - remainder : result : 0;
                    }
                    function toLength(value) {
                        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
                    }
                    function toNumber(value) {
                        if (typeof value == "number") {
                            return value;
                        }
                        if (isSymbol(value)) {
                            return NAN;
                        }
                        if (isObject(value)) {
                            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
                            value = isObject(other) ? other + "" : other;
                        }
                        if (typeof value != "string") {
                            return value === 0 ? value : +value;
                        }
                        value = value.replace(reTrim, "");
                        var isBinary = reIsBinary.test(value);
                        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
                    }
                    function toPlainObject(value) {
                        return copyObject(value, keysIn(value));
                    }
                    function toSafeInteger(value) {
                        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
                    }
                    function toString(value) {
                        return value == null ? "" : baseToString(value);
                    }
                    var assign = createAssigner((function(object, source) {
                        if (isPrototype(source) || isArrayLike(source)) {
                            copyObject(source, keys(source), object);
                            return;
                        }
                        for (var key in source) {
                            if (hasOwnProperty.call(source, key)) {
                                assignValue(object, key, source[key]);
                            }
                        }
                    }));
                    var assignIn = createAssigner((function(object, source) {
                        copyObject(source, keysIn(source), object);
                    }));
                    var assignInWith = createAssigner((function(object, source, srcIndex, customizer) {
                        copyObject(source, keysIn(source), object, customizer);
                    }));
                    var assignWith = createAssigner((function(object, source, srcIndex, customizer) {
                        copyObject(source, keys(source), object, customizer);
                    }));
                    var at = flatRest(baseAt);
                    function create(prototype, properties) {
                        var result = baseCreate(prototype);
                        return properties == null ? result : baseAssign(result, properties);
                    }
                    var defaults = baseRest((function(object, sources) {
                        object = Object(object);
                        var index = -1;
                        var length = sources.length;
                        var guard = length > 2 ? sources[2] : undefined;
                        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                            length = 1;
                        }
                        while (++index < length) {
                            var source = sources[index];
                            var props = keysIn(source);
                            var propsIndex = -1;
                            var propsLength = props.length;
                            while (++propsIndex < propsLength) {
                                var key = props[propsIndex];
                                var value = object[key];
                                if (value === undefined || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                                    object[key] = source[key];
                                }
                            }
                        }
                        return object;
                    }));
                    var defaultsDeep = baseRest((function(args) {
                        args.push(undefined, customDefaultsMerge);
                        return apply(mergeWith, undefined, args);
                    }));
                    function findKey(object, predicate) {
                        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
                    }
                    function findLastKey(object, predicate) {
                        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
                    }
                    function forIn(object, iteratee) {
                        return object == null ? object : baseFor(object, getIteratee(iteratee, 3), keysIn);
                    }
                    function forInRight(object, iteratee) {
                        return object == null ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn);
                    }
                    function forOwn(object, iteratee) {
                        return object && baseForOwn(object, getIteratee(iteratee, 3));
                    }
                    function forOwnRight(object, iteratee) {
                        return object && baseForOwnRight(object, getIteratee(iteratee, 3));
                    }
                    function functions(object) {
                        return object == null ? [] : baseFunctions(object, keys(object));
                    }
                    function functionsIn(object) {
                        return object == null ? [] : baseFunctions(object, keysIn(object));
                    }
                    function get(object, path, defaultValue) {
                        var result = object == null ? undefined : baseGet(object, path);
                        return result === undefined ? defaultValue : result;
                    }
                    function has(object, path) {
                        return object != null && hasPath(object, path, baseHas);
                    }
                    function hasIn(object, path) {
                        return object != null && hasPath(object, path, baseHasIn);
                    }
                    var invert = createInverter((function(result, value, key) {
                        if (value != null && typeof value.toString != "function") {
                            value = nativeObjectToString.call(value);
                        }
                        result[value] = key;
                    }), constant(identity));
                    var invertBy = createInverter((function(result, value, key) {
                        if (value != null && typeof value.toString != "function") {
                            value = nativeObjectToString.call(value);
                        }
                        if (hasOwnProperty.call(result, value)) {
                            result[value].push(key);
                        } else {
                            result[value] = [ key ];
                        }
                    }), getIteratee);
                    var invoke = baseRest(baseInvoke);
                    function keys(object) {
                        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
                    }
                    function keysIn(object) {
                        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
                    }
                    function mapKeys(object, iteratee) {
                        var result = {};
                        iteratee = getIteratee(iteratee, 3);
                        baseForOwn(object, (function(value, key, object) {
                            baseAssignValue(result, iteratee(value, key, object), value);
                        }));
                        return result;
                    }
                    function mapValues(object, iteratee) {
                        var result = {};
                        iteratee = getIteratee(iteratee, 3);
                        baseForOwn(object, (function(value, key, object) {
                            baseAssignValue(result, key, iteratee(value, key, object));
                        }));
                        return result;
                    }
                    var merge = createAssigner((function(object, source, srcIndex) {
                        baseMerge(object, source, srcIndex);
                    }));
                    var mergeWith = createAssigner((function(object, source, srcIndex, customizer) {
                        baseMerge(object, source, srcIndex, customizer);
                    }));
                    var omit = flatRest((function(object, paths) {
                        var result = {};
                        if (object == null) {
                            return result;
                        }
                        var isDeep = false;
                        paths = arrayMap(paths, (function(path) {
                            path = castPath(path, object);
                            isDeep || (isDeep = path.length > 1);
                            return path;
                        }));
                        copyObject(object, getAllKeysIn(object), result);
                        if (isDeep) {
                            result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
                        }
                        var length = paths.length;
                        while (length--) {
                            baseUnset(result, paths[length]);
                        }
                        return result;
                    }));
                    function omitBy(object, predicate) {
                        return pickBy(object, negate(getIteratee(predicate)));
                    }
                    var pick = flatRest((function(object, paths) {
                        return object == null ? {} : basePick(object, paths);
                    }));
                    function pickBy(object, predicate) {
                        if (object == null) {
                            return {};
                        }
                        var props = arrayMap(getAllKeysIn(object), (function(prop) {
                            return [ prop ];
                        }));
                        predicate = getIteratee(predicate);
                        return basePickBy(object, props, (function(value, path) {
                            return predicate(value, path[0]);
                        }));
                    }
                    function result(object, path, defaultValue) {
                        path = castPath(path, object);
                        var index = -1, length = path.length;
                        if (!length) {
                            length = 1;
                            object = undefined;
                        }
                        while (++index < length) {
                            var value = object == null ? undefined : object[toKey(path[index])];
                            if (value === undefined) {
                                index = length;
                                value = defaultValue;
                            }
                            object = isFunction(value) ? value.call(object) : value;
                        }
                        return object;
                    }
                    function set(object, path, value) {
                        return object == null ? object : baseSet(object, path, value);
                    }
                    function setWith(object, path, value, customizer) {
                        customizer = typeof customizer == "function" ? customizer : undefined;
                        return object == null ? object : baseSet(object, path, value, customizer);
                    }
                    var toPairs = createToPairs(keys);
                    var toPairsIn = createToPairs(keysIn);
                    function transform(object, iteratee, accumulator) {
                        var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
                        iteratee = getIteratee(iteratee, 4);
                        if (accumulator == null) {
                            var Ctor = object && object.constructor;
                            if (isArrLike) {
                                accumulator = isArr ? new Ctor : [];
                            } else if (isObject(object)) {
                                accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
                            } else {
                                accumulator = {};
                            }
                        }
                        (isArrLike ? arrayEach : baseForOwn)(object, (function(value, index, object) {
                            return iteratee(accumulator, value, index, object);
                        }));
                        return accumulator;
                    }
                    function unset(object, path) {
                        return object == null ? true : baseUnset(object, path);
                    }
                    function update(object, path, updater) {
                        return object == null ? object : baseUpdate(object, path, castFunction(updater));
                    }
                    function updateWith(object, path, updater, customizer) {
                        customizer = typeof customizer == "function" ? customizer : undefined;
                        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
                    }
                    function values(object) {
                        return object == null ? [] : baseValues(object, keys(object));
                    }
                    function valuesIn(object) {
                        return object == null ? [] : baseValues(object, keysIn(object));
                    }
                    function clamp(number, lower, upper) {
                        if (upper === undefined) {
                            upper = lower;
                            lower = undefined;
                        }
                        if (upper !== undefined) {
                            upper = toNumber(upper);
                            upper = upper === upper ? upper : 0;
                        }
                        if (lower !== undefined) {
                            lower = toNumber(lower);
                            lower = lower === lower ? lower : 0;
                        }
                        return baseClamp(toNumber(number), lower, upper);
                    }
                    function inRange(number, start, end) {
                        start = toFinite(start);
                        if (end === undefined) {
                            end = start;
                            start = 0;
                        } else {
                            end = toFinite(end);
                        }
                        number = toNumber(number);
                        return baseInRange(number, start, end);
                    }
                    function random(lower, upper, floating) {
                        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
                            upper = floating = undefined;
                        }
                        if (floating === undefined) {
                            if (typeof upper == "boolean") {
                                floating = upper;
                                upper = undefined;
                            } else if (typeof lower == "boolean") {
                                floating = lower;
                                lower = undefined;
                            }
                        }
                        if (lower === undefined && upper === undefined) {
                            lower = 0;
                            upper = 1;
                        } else {
                            lower = toFinite(lower);
                            if (upper === undefined) {
                                upper = lower;
                                lower = 0;
                            } else {
                                upper = toFinite(upper);
                            }
                        }
                        if (lower > upper) {
                            var temp = lower;
                            lower = upper;
                            upper = temp;
                        }
                        if (floating || lower % 1 || upper % 1) {
                            var rand = nativeRandom();
                            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
                        }
                        return baseRandom(lower, upper);
                    }
                    var camelCase = createCompounder((function(result, word, index) {
                        word = word.toLowerCase();
                        return result + (index ? capitalize(word) : word);
                    }));
                    function capitalize(string) {
                        return upperFirst(toString(string).toLowerCase());
                    }
                    function deburr(string) {
                        string = toString(string);
                        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
                    }
                    function endsWith(string, target, position) {
                        string = toString(string);
                        target = baseToString(target);
                        var length = string.length;
                        position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
                        var end = position;
                        position -= target.length;
                        return position >= 0 && string.slice(position, end) == target;
                    }
                    function escape(string) {
                        string = toString(string);
                        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
                    }
                    function escapeRegExp(string) {
                        string = toString(string);
                        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
                    }
                    var kebabCase = createCompounder((function(result, word, index) {
                        return result + (index ? "-" : "") + word.toLowerCase();
                    }));
                    var lowerCase = createCompounder((function(result, word, index) {
                        return result + (index ? " " : "") + word.toLowerCase();
                    }));
                    var lowerFirst = createCaseFirst("toLowerCase");
                    function pad(string, length, chars) {
                        string = toString(string);
                        length = toInteger(length);
                        var strLength = length ? stringSize(string) : 0;
                        if (!length || strLength >= length) {
                            return string;
                        }
                        var mid = (length - strLength) / 2;
                        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
                    }
                    function padEnd(string, length, chars) {
                        string = toString(string);
                        length = toInteger(length);
                        var strLength = length ? stringSize(string) : 0;
                        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
                    }
                    function padStart(string, length, chars) {
                        string = toString(string);
                        length = toInteger(length);
                        var strLength = length ? stringSize(string) : 0;
                        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
                    }
                    function parseInt(string, radix, guard) {
                        if (guard || radix == null) {
                            radix = 0;
                        } else if (radix) {
                            radix = +radix;
                        }
                        return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
                    }
                    function repeat(string, n, guard) {
                        if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
                            n = 1;
                        } else {
                            n = toInteger(n);
                        }
                        return baseRepeat(toString(string), n);
                    }
                    function replace() {
                        var args = arguments, string = toString(args[0]);
                        return args.length < 3 ? string : string.replace(args[1], args[2]);
                    }
                    var snakeCase = createCompounder((function(result, word, index) {
                        return result + (index ? "_" : "") + word.toLowerCase();
                    }));
                    function split(string, separator, limit) {
                        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
                            separator = limit = undefined;
                        }
                        limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
                        if (!limit) {
                            return [];
                        }
                        string = toString(string);
                        if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
                            separator = baseToString(separator);
                            if (!separator && hasUnicode(string)) {
                                return castSlice(stringToArray(string), 0, limit);
                            }
                        }
                        return string.split(separator, limit);
                    }
                    var startCase = createCompounder((function(result, word, index) {
                        return result + (index ? " " : "") + upperFirst(word);
                    }));
                    function startsWith(string, target, position) {
                        string = toString(string);
                        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
                        target = baseToString(target);
                        return string.slice(position, position + target.length) == target;
                    }
                    function template(string, options, guard) {
                        var settings = lodash.templateSettings;
                        if (guard && isIterateeCall(string, options, guard)) {
                            options = undefined;
                        }
                        string = toString(string);
                        options = assignInWith({}, options, settings, customDefaultsAssignIn);
                        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
                        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
                        var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
                        var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
                        string.replace(reDelimiters, (function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                            interpolateValue || (interpolateValue = esTemplateValue);
                            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                            if (escapeValue) {
                                isEscaping = true;
                                source += "' +\n__e(" + escapeValue + ") +\n'";
                            }
                            if (evaluateValue) {
                                isEvaluating = true;
                                source += "';\n" + evaluateValue + ";\n__p += '";
                            }
                            if (interpolateValue) {
                                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                            }
                            index = offset + match.length;
                            return match;
                        }));
                        source += "';\n";
                        var variable = hasOwnProperty.call(options, "variable") && options.variable;
                        if (!variable) {
                            source = "with (obj) {\n" + source + "\n}\n";
                        }
                        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
                        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                        var result = attempt((function() {
                            return Function(importsKeys, sourceURL + "return " + source).apply(undefined, importsValues);
                        }));
                        result.source = source;
                        if (isError(result)) {
                            throw result;
                        }
                        return result;
                    }
                    function toLower(value) {
                        return toString(value).toLowerCase();
                    }
                    function toUpper(value) {
                        return toString(value).toUpperCase();
                    }
                    function trim(string, chars, guard) {
                        string = toString(string);
                        if (string && (guard || chars === undefined)) {
                            return string.replace(reTrim, "");
                        }
                        if (!string || !(chars = baseToString(chars))) {
                            return string;
                        }
                        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
                        return castSlice(strSymbols, start, end).join("");
                    }
                    function trimEnd(string, chars, guard) {
                        string = toString(string);
                        if (string && (guard || chars === undefined)) {
                            return string.replace(reTrimEnd, "");
                        }
                        if (!string || !(chars = baseToString(chars))) {
                            return string;
                        }
                        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
                        return castSlice(strSymbols, 0, end).join("");
                    }
                    function trimStart(string, chars, guard) {
                        string = toString(string);
                        if (string && (guard || chars === undefined)) {
                            return string.replace(reTrimStart, "");
                        }
                        if (!string || !(chars = baseToString(chars))) {
                            return string;
                        }
                        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
                        return castSlice(strSymbols, start).join("");
                    }
                    function truncate(string, options) {
                        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
                        if (isObject(options)) {
                            var separator = "separator" in options ? options.separator : separator;
                            length = "length" in options ? toInteger(options.length) : length;
                            omission = "omission" in options ? baseToString(options.omission) : omission;
                        }
                        string = toString(string);
                        var strLength = string.length;
                        if (hasUnicode(string)) {
                            var strSymbols = stringToArray(string);
                            strLength = strSymbols.length;
                        }
                        if (length >= strLength) {
                            return string;
                        }
                        var end = length - stringSize(omission);
                        if (end < 1) {
                            return omission;
                        }
                        var result = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
                        if (separator === undefined) {
                            return result + omission;
                        }
                        if (strSymbols) {
                            end += result.length - end;
                        }
                        if (isRegExp(separator)) {
                            if (string.slice(end).search(separator)) {
                                var match, substring = result;
                                if (!separator.global) {
                                    separator = RegExp(separator.source, toString(reFlags.exec(separator)) + "g");
                                }
                                separator.lastIndex = 0;
                                while (match = separator.exec(substring)) {
                                    var newEnd = match.index;
                                }
                                result = result.slice(0, newEnd === undefined ? end : newEnd);
                            }
                        } else if (string.indexOf(baseToString(separator), end) != end) {
                            var index = result.lastIndexOf(separator);
                            if (index > -1) {
                                result = result.slice(0, index);
                            }
                        }
                        return result + omission;
                    }
                    function unescape(string) {
                        string = toString(string);
                        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
                    }
                    var upperCase = createCompounder((function(result, word, index) {
                        return result + (index ? " " : "") + word.toUpperCase();
                    }));
                    var upperFirst = createCaseFirst("toUpperCase");
                    function words(string, pattern, guard) {
                        string = toString(string);
                        pattern = guard ? undefined : pattern;
                        if (pattern === undefined) {
                            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
                        }
                        return string.match(pattern) || [];
                    }
                    var attempt = baseRest((function(func, args) {
                        try {
                            return apply(func, undefined, args);
                        } catch (e) {
                            return isError(e) ? e : new Error(e);
                        }
                    }));
                    var bindAll = flatRest((function(object, methodNames) {
                        arrayEach(methodNames, (function(key) {
                            key = toKey(key);
                            baseAssignValue(object, key, bind(object[key], object));
                        }));
                        return object;
                    }));
                    function cond(pairs) {
                        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
                        pairs = !length ? [] : arrayMap(pairs, (function(pair) {
                            if (typeof pair[1] != "function") {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            return [ toIteratee(pair[0]), pair[1] ];
                        }));
                        return baseRest((function(args) {
                            var index = -1;
                            while (++index < length) {
                                var pair = pairs[index];
                                if (apply(pair[0], this, args)) {
                                    return apply(pair[1], this, args);
                                }
                            }
                        }));
                    }
                    function conforms(source) {
                        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
                    }
                    function constant(value) {
                        return function() {
                            return value;
                        };
                    }
                    function defaultTo(value, defaultValue) {
                        return value == null || value !== value ? defaultValue : value;
                    }
                    var flow = createFlow();
                    var flowRight = createFlow(true);
                    function identity(value) {
                        return value;
                    }
                    function iteratee(func) {
                        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
                    }
                    function matches(source) {
                        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
                    }
                    function matchesProperty(path, srcValue) {
                        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
                    }
                    var method = baseRest((function(path, args) {
                        return function(object) {
                            return baseInvoke(object, path, args);
                        };
                    }));
                    var methodOf = baseRest((function(object, args) {
                        return function(path) {
                            return baseInvoke(object, path, args);
                        };
                    }));
                    function mixin(object, source, options) {
                        var props = keys(source), methodNames = baseFunctions(source, props);
                        if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
                            options = source;
                            source = object;
                            object = this;
                            methodNames = baseFunctions(source, keys(source));
                        }
                        var chain = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
                        arrayEach(methodNames, (function(methodName) {
                            var func = source[methodName];
                            object[methodName] = func;
                            if (isFunc) {
                                object.prototype[methodName] = function() {
                                    var chainAll = this.__chain__;
                                    if (chain || chainAll) {
                                        var result = object(this.__wrapped__), actions = result.__actions__ = copyArray(this.__actions__);
                                        actions.push({
                                            func: func,
                                            args: arguments,
                                            thisArg: object
                                        });
                                        result.__chain__ = chainAll;
                                        return result;
                                    }
                                    return func.apply(object, arrayPush([ this.value() ], arguments));
                                };
                            }
                        }));
                        return object;
                    }
                    function noConflict() {
                        if (root._ === this) {
                            root._ = oldDash;
                        }
                        return this;
                    }
                    function noop() {}
                    function nthArg(n) {
                        n = toInteger(n);
                        return baseRest((function(args) {
                            return baseNth(args, n);
                        }));
                    }
                    var over = createOver(arrayMap);
                    var overEvery = createOver(arrayEvery);
                    var overSome = createOver(arraySome);
                    function property(path) {
                        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
                    }
                    function propertyOf(object) {
                        return function(path) {
                            return object == null ? undefined : baseGet(object, path);
                        };
                    }
                    var range = createRange();
                    var rangeRight = createRange(true);
                    function stubArray() {
                        return [];
                    }
                    function stubFalse() {
                        return false;
                    }
                    function stubObject() {
                        return {};
                    }
                    function stubString() {
                        return "";
                    }
                    function stubTrue() {
                        return true;
                    }
                    function times(n, iteratee) {
                        n = toInteger(n);
                        if (n < 1 || n > MAX_SAFE_INTEGER) {
                            return [];
                        }
                        var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
                        iteratee = getIteratee(iteratee);
                        n -= MAX_ARRAY_LENGTH;
                        var result = baseTimes(length, iteratee);
                        while (++index < n) {
                            iteratee(index);
                        }
                        return result;
                    }
                    function toPath(value) {
                        if (isArray(value)) {
                            return arrayMap(value, toKey);
                        }
                        return isSymbol(value) ? [ value ] : copyArray(stringToPath(toString(value)));
                    }
                    function uniqueId(prefix) {
                        var id = ++idCounter;
                        return toString(prefix) + id;
                    }
                    var add = createMathOperation((function(augend, addend) {
                        return augend + addend;
                    }), 0);
                    var ceil = createRound("ceil");
                    var divide = createMathOperation((function(dividend, divisor) {
                        return dividend / divisor;
                    }), 1);
                    var floor = createRound("floor");
                    function max(array) {
                        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined;
                    }
                    function maxBy(array, iteratee) {
                        return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined;
                    }
                    function mean(array) {
                        return baseMean(array, identity);
                    }
                    function meanBy(array, iteratee) {
                        return baseMean(array, getIteratee(iteratee, 2));
                    }
                    function min(array) {
                        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined;
                    }
                    function minBy(array, iteratee) {
                        return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined;
                    }
                    var multiply = createMathOperation((function(multiplier, multiplicand) {
                        return multiplier * multiplicand;
                    }), 1);
                    var round = createRound("round");
                    var subtract = createMathOperation((function(minuend, subtrahend) {
                        return minuend - subtrahend;
                    }), 0);
                    function sum(array) {
                        return array && array.length ? baseSum(array, identity) : 0;
                    }
                    function sumBy(array, iteratee) {
                        return array && array.length ? baseSum(array, getIteratee(iteratee, 2)) : 0;
                    }
                    lodash.after = after;
                    lodash.ary = ary;
                    lodash.assign = assign;
                    lodash.assignIn = assignIn;
                    lodash.assignInWith = assignInWith;
                    lodash.assignWith = assignWith;
                    lodash.at = at;
                    lodash.before = before;
                    lodash.bind = bind;
                    lodash.bindAll = bindAll;
                    lodash.bindKey = bindKey;
                    lodash.castArray = castArray;
                    lodash.chain = chain;
                    lodash.chunk = chunk;
                    lodash.compact = compact;
                    lodash.concat = concat;
                    lodash.cond = cond;
                    lodash.conforms = conforms;
                    lodash.constant = constant;
                    lodash.countBy = countBy;
                    lodash.create = create;
                    lodash.curry = curry;
                    lodash.curryRight = curryRight;
                    lodash.debounce = debounce;
                    lodash.defaults = defaults;
                    lodash.defaultsDeep = defaultsDeep;
                    lodash.defer = defer;
                    lodash.delay = delay;
                    lodash.difference = difference;
                    lodash.differenceBy = differenceBy;
                    lodash.differenceWith = differenceWith;
                    lodash.drop = drop;
                    lodash.dropRight = dropRight;
                    lodash.dropRightWhile = dropRightWhile;
                    lodash.dropWhile = dropWhile;
                    lodash.fill = fill;
                    lodash.filter = filter;
                    lodash.flatMap = flatMap;
                    lodash.flatMapDeep = flatMapDeep;
                    lodash.flatMapDepth = flatMapDepth;
                    lodash.flatten = flatten;
                    lodash.flattenDeep = flattenDeep;
                    lodash.flattenDepth = flattenDepth;
                    lodash.flip = flip;
                    lodash.flow = flow;
                    lodash.flowRight = flowRight;
                    lodash.fromPairs = fromPairs;
                    lodash.functions = functions;
                    lodash.functionsIn = functionsIn;
                    lodash.groupBy = groupBy;
                    lodash.initial = initial;
                    lodash.intersection = intersection;
                    lodash.intersectionBy = intersectionBy;
                    lodash.intersectionWith = intersectionWith;
                    lodash.invert = invert;
                    lodash.invertBy = invertBy;
                    lodash.invokeMap = invokeMap;
                    lodash.iteratee = iteratee;
                    lodash.keyBy = keyBy;
                    lodash.keys = keys;
                    lodash.keysIn = keysIn;
                    lodash.map = map;
                    lodash.mapKeys = mapKeys;
                    lodash.mapValues = mapValues;
                    lodash.matches = matches;
                    lodash.matchesProperty = matchesProperty;
                    lodash.memoize = memoize;
                    lodash.merge = merge;
                    lodash.mergeWith = mergeWith;
                    lodash.method = method;
                    lodash.methodOf = methodOf;
                    lodash.mixin = mixin;
                    lodash.negate = negate;
                    lodash.nthArg = nthArg;
                    lodash.omit = omit;
                    lodash.omitBy = omitBy;
                    lodash.once = once;
                    lodash.orderBy = orderBy;
                    lodash.over = over;
                    lodash.overArgs = overArgs;
                    lodash.overEvery = overEvery;
                    lodash.overSome = overSome;
                    lodash.partial = partial;
                    lodash.partialRight = partialRight;
                    lodash.partition = partition;
                    lodash.pick = pick;
                    lodash.pickBy = pickBy;
                    lodash.property = property;
                    lodash.propertyOf = propertyOf;
                    lodash.pull = pull;
                    lodash.pullAll = pullAll;
                    lodash.pullAllBy = pullAllBy;
                    lodash.pullAllWith = pullAllWith;
                    lodash.pullAt = pullAt;
                    lodash.range = range;
                    lodash.rangeRight = rangeRight;
                    lodash.rearg = rearg;
                    lodash.reject = reject;
                    lodash.remove = remove;
                    lodash.rest = rest;
                    lodash.reverse = reverse;
                    lodash.sampleSize = sampleSize;
                    lodash.set = set;
                    lodash.setWith = setWith;
                    lodash.shuffle = shuffle;
                    lodash.slice = slice;
                    lodash.sortBy = sortBy;
                    lodash.sortedUniq = sortedUniq;
                    lodash.sortedUniqBy = sortedUniqBy;
                    lodash.split = split;
                    lodash.spread = spread;
                    lodash.tail = tail;
                    lodash.take = take;
                    lodash.takeRight = takeRight;
                    lodash.takeRightWhile = takeRightWhile;
                    lodash.takeWhile = takeWhile;
                    lodash.tap = tap;
                    lodash.throttle = throttle;
                    lodash.thru = thru;
                    lodash.toArray = toArray;
                    lodash.toPairs = toPairs;
                    lodash.toPairsIn = toPairsIn;
                    lodash.toPath = toPath;
                    lodash.toPlainObject = toPlainObject;
                    lodash.transform = transform;
                    lodash.unary = unary;
                    lodash.union = union;
                    lodash.unionBy = unionBy;
                    lodash.unionWith = unionWith;
                    lodash.uniq = uniq;
                    lodash.uniqBy = uniqBy;
                    lodash.uniqWith = uniqWith;
                    lodash.unset = unset;
                    lodash.unzip = unzip;
                    lodash.unzipWith = unzipWith;
                    lodash.update = update;
                    lodash.updateWith = updateWith;
                    lodash.values = values;
                    lodash.valuesIn = valuesIn;
                    lodash.without = without;
                    lodash.words = words;
                    lodash.wrap = wrap;
                    lodash.xor = xor;
                    lodash.xorBy = xorBy;
                    lodash.xorWith = xorWith;
                    lodash.zip = zip;
                    lodash.zipObject = zipObject;
                    lodash.zipObjectDeep = zipObjectDeep;
                    lodash.zipWith = zipWith;
                    lodash.entries = toPairs;
                    lodash.entriesIn = toPairsIn;
                    lodash.extend = assignIn;
                    lodash.extendWith = assignInWith;
                    mixin(lodash, lodash);
                    lodash.add = add;
                    lodash.attempt = attempt;
                    lodash.camelCase = camelCase;
                    lodash.capitalize = capitalize;
                    lodash.ceil = ceil;
                    lodash.clamp = clamp;
                    lodash.clone = clone;
                    lodash.cloneDeep = cloneDeep;
                    lodash.cloneDeepWith = cloneDeepWith;
                    lodash.cloneWith = cloneWith;
                    lodash.conformsTo = conformsTo;
                    lodash.deburr = deburr;
                    lodash.defaultTo = defaultTo;
                    lodash.divide = divide;
                    lodash.endsWith = endsWith;
                    lodash.eq = eq;
                    lodash.escape = escape;
                    lodash.escapeRegExp = escapeRegExp;
                    lodash.every = every;
                    lodash.find = find;
                    lodash.findIndex = findIndex;
                    lodash.findKey = findKey;
                    lodash.findLast = findLast;
                    lodash.findLastIndex = findLastIndex;
                    lodash.findLastKey = findLastKey;
                    lodash.floor = floor;
                    lodash.forEach = forEach;
                    lodash.forEachRight = forEachRight;
                    lodash.forIn = forIn;
                    lodash.forInRight = forInRight;
                    lodash.forOwn = forOwn;
                    lodash.forOwnRight = forOwnRight;
                    lodash.get = get;
                    lodash.gt = gt;
                    lodash.gte = gte;
                    lodash.has = has;
                    lodash.hasIn = hasIn;
                    lodash.head = head;
                    lodash.identity = identity;
                    lodash.includes = includes;
                    lodash.indexOf = indexOf;
                    lodash.inRange = inRange;
                    lodash.invoke = invoke;
                    lodash.isArguments = isArguments;
                    lodash.isArray = isArray;
                    lodash.isArrayBuffer = isArrayBuffer;
                    lodash.isArrayLike = isArrayLike;
                    lodash.isArrayLikeObject = isArrayLikeObject;
                    lodash.isBoolean = isBoolean;
                    lodash.isBuffer = isBuffer;
                    lodash.isDate = isDate;
                    lodash.isElement = isElement;
                    lodash.isEmpty = isEmpty;
                    lodash.isEqual = isEqual;
                    lodash.isEqualWith = isEqualWith;
                    lodash.isError = isError;
                    lodash.isFinite = isFinite;
                    lodash.isFunction = isFunction;
                    lodash.isInteger = isInteger;
                    lodash.isLength = isLength;
                    lodash.isMap = isMap;
                    lodash.isMatch = isMatch;
                    lodash.isMatchWith = isMatchWith;
                    lodash.isNaN = isNaN;
                    lodash.isNative = isNative;
                    lodash.isNil = isNil;
                    lodash.isNull = isNull;
                    lodash.isNumber = isNumber;
                    lodash.isObject = isObject;
                    lodash.isObjectLike = isObjectLike;
                    lodash.isPlainObject = isPlainObject;
                    lodash.isRegExp = isRegExp;
                    lodash.isSafeInteger = isSafeInteger;
                    lodash.isSet = isSet;
                    lodash.isString = isString;
                    lodash.isSymbol = isSymbol;
                    lodash.isTypedArray = isTypedArray;
                    lodash.isUndefined = isUndefined;
                    lodash.isWeakMap = isWeakMap;
                    lodash.isWeakSet = isWeakSet;
                    lodash.join = join;
                    lodash.kebabCase = kebabCase;
                    lodash.last = last;
                    lodash.lastIndexOf = lastIndexOf;
                    lodash.lowerCase = lowerCase;
                    lodash.lowerFirst = lowerFirst;
                    lodash.lt = lt;
                    lodash.lte = lte;
                    lodash.max = max;
                    lodash.maxBy = maxBy;
                    lodash.mean = mean;
                    lodash.meanBy = meanBy;
                    lodash.min = min;
                    lodash.minBy = minBy;
                    lodash.stubArray = stubArray;
                    lodash.stubFalse = stubFalse;
                    lodash.stubObject = stubObject;
                    lodash.stubString = stubString;
                    lodash.stubTrue = stubTrue;
                    lodash.multiply = multiply;
                    lodash.nth = nth;
                    lodash.noConflict = noConflict;
                    lodash.noop = noop;
                    lodash.now = now;
                    lodash.pad = pad;
                    lodash.padEnd = padEnd;
                    lodash.padStart = padStart;
                    lodash.parseInt = parseInt;
                    lodash.random = random;
                    lodash.reduce = reduce;
                    lodash.reduceRight = reduceRight;
                    lodash.repeat = repeat;
                    lodash.replace = replace;
                    lodash.result = result;
                    lodash.round = round;
                    lodash.runInContext = runInContext;
                    lodash.sample = sample;
                    lodash.size = size;
                    lodash.snakeCase = snakeCase;
                    lodash.some = some;
                    lodash.sortedIndex = sortedIndex;
                    lodash.sortedIndexBy = sortedIndexBy;
                    lodash.sortedIndexOf = sortedIndexOf;
                    lodash.sortedLastIndex = sortedLastIndex;
                    lodash.sortedLastIndexBy = sortedLastIndexBy;
                    lodash.sortedLastIndexOf = sortedLastIndexOf;
                    lodash.startCase = startCase;
                    lodash.startsWith = startsWith;
                    lodash.subtract = subtract;
                    lodash.sum = sum;
                    lodash.sumBy = sumBy;
                    lodash.template = template;
                    lodash.times = times;
                    lodash.toFinite = toFinite;
                    lodash.toInteger = toInteger;
                    lodash.toLength = toLength;
                    lodash.toLower = toLower;
                    lodash.toNumber = toNumber;
                    lodash.toSafeInteger = toSafeInteger;
                    lodash.toString = toString;
                    lodash.toUpper = toUpper;
                    lodash.trim = trim;
                    lodash.trimEnd = trimEnd;
                    lodash.trimStart = trimStart;
                    lodash.truncate = truncate;
                    lodash.unescape = unescape;
                    lodash.uniqueId = uniqueId;
                    lodash.upperCase = upperCase;
                    lodash.upperFirst = upperFirst;
                    lodash.each = forEach;
                    lodash.eachRight = forEachRight;
                    lodash.first = head;
                    mixin(lodash, function() {
                        var source = {};
                        baseForOwn(lodash, (function(func, methodName) {
                            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                                source[methodName] = func;
                            }
                        }));
                        return source;
                    }(), {
                        chain: false
                    });
                    lodash.VERSION = VERSION;
                    arrayEach([ "bind", "bindKey", "curry", "curryRight", "partial", "partialRight" ], (function(methodName) {
                        lodash[methodName].placeholder = lodash;
                    }));
                    arrayEach([ "drop", "take" ], (function(methodName, index) {
                        LazyWrapper.prototype[methodName] = function(n) {
                            n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
                            var result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
                            if (result.__filtered__) {
                                result.__takeCount__ = nativeMin(n, result.__takeCount__);
                            } else {
                                result.__views__.push({
                                    size: nativeMin(n, MAX_ARRAY_LENGTH),
                                    type: methodName + (result.__dir__ < 0 ? "Right" : "")
                                });
                            }
                            return result;
                        };
                        LazyWrapper.prototype[methodName + "Right"] = function(n) {
                            return this.reverse()[methodName](n).reverse();
                        };
                    }));
                    arrayEach([ "filter", "map", "takeWhile" ], (function(methodName, index) {
                        var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
                        LazyWrapper.prototype[methodName] = function(iteratee) {
                            var result = this.clone();
                            result.__iteratees__.push({
                                iteratee: getIteratee(iteratee, 3),
                                type: type
                            });
                            result.__filtered__ = result.__filtered__ || isFilter;
                            return result;
                        };
                    }));
                    arrayEach([ "head", "last" ], (function(methodName, index) {
                        var takeName = "take" + (index ? "Right" : "");
                        LazyWrapper.prototype[methodName] = function() {
                            return this[takeName](1).value()[0];
                        };
                    }));
                    arrayEach([ "initial", "tail" ], (function(methodName, index) {
                        var dropName = "drop" + (index ? "" : "Right");
                        LazyWrapper.prototype[methodName] = function() {
                            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                        };
                    }));
                    LazyWrapper.prototype.compact = function() {
                        return this.filter(identity);
                    };
                    LazyWrapper.prototype.find = function(predicate) {
                        return this.filter(predicate).head();
                    };
                    LazyWrapper.prototype.findLast = function(predicate) {
                        return this.reverse().find(predicate);
                    };
                    LazyWrapper.prototype.invokeMap = baseRest((function(path, args) {
                        if (typeof path == "function") {
                            return new LazyWrapper(this);
                        }
                        return this.map((function(value) {
                            return baseInvoke(value, path, args);
                        }));
                    }));
                    LazyWrapper.prototype.reject = function(predicate) {
                        return this.filter(negate(getIteratee(predicate)));
                    };
                    LazyWrapper.prototype.slice = function(start, end) {
                        start = toInteger(start);
                        var result = this;
                        if (result.__filtered__ && (start > 0 || end < 0)) {
                            return new LazyWrapper(result);
                        }
                        if (start < 0) {
                            result = result.takeRight(-start);
                        } else if (start) {
                            result = result.drop(start);
                        }
                        if (end !== undefined) {
                            end = toInteger(end);
                            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
                        }
                        return result;
                    };
                    LazyWrapper.prototype.takeRightWhile = function(predicate) {
                        return this.reverse().takeWhile(predicate).reverse();
                    };
                    LazyWrapper.prototype.toArray = function() {
                        return this.take(MAX_ARRAY_LENGTH);
                    };
                    baseForOwn(LazyWrapper.prototype, (function(func, methodName) {
                        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
                        if (!lodashFunc) {
                            return;
                        }
                        lodash.prototype[methodName] = function() {
                            var value = this.__wrapped__, args = isTaker ? [ 1 ] : arguments, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value);
                            var interceptor = function(value) {
                                var result = lodashFunc.apply(lodash, arrayPush([ value ], args));
                                return isTaker && chainAll ? result[0] : result;
                            };
                            if (useLazy && checkIteratee && typeof iteratee == "function" && iteratee.length != 1) {
                                isLazy = useLazy = false;
                            }
                            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
                            if (!retUnwrapped && useLazy) {
                                value = onlyLazy ? value : new LazyWrapper(this);
                                var result = func.apply(value, args);
                                result.__actions__.push({
                                    func: thru,
                                    args: [ interceptor ],
                                    thisArg: undefined
                                });
                                return new LodashWrapper(result, chainAll);
                            }
                            if (isUnwrapped && onlyLazy) {
                                return func.apply(this, args);
                            }
                            result = this.thru(interceptor);
                            return isUnwrapped ? isTaker ? result.value()[0] : result.value() : result;
                        };
                    }));
                    arrayEach([ "pop", "push", "shift", "sort", "splice", "unshift" ], (function(methodName) {
                        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
                        lodash.prototype[methodName] = function() {
                            var args = arguments;
                            if (retUnwrapped && !this.__chain__) {
                                var value = this.value();
                                return func.apply(isArray(value) ? value : [], args);
                            }
                            return this[chainName]((function(value) {
                                return func.apply(isArray(value) ? value : [], args);
                            }));
                        };
                    }));
                    baseForOwn(LazyWrapper.prototype, (function(func, methodName) {
                        var lodashFunc = lodash[methodName];
                        if (lodashFunc) {
                            var key = lodashFunc.name + "";
                            if (!hasOwnProperty.call(realNames, key)) {
                                realNames[key] = [];
                            }
                            realNames[key].push({
                                name: methodName,
                                func: lodashFunc
                            });
                        }
                    }));
                    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [ {
                        name: "wrapper",
                        func: undefined
                    } ];
                    LazyWrapper.prototype.clone = lazyClone;
                    LazyWrapper.prototype.reverse = lazyReverse;
                    LazyWrapper.prototype.value = lazyValue;
                    lodash.prototype.at = wrapperAt;
                    lodash.prototype.chain = wrapperChain;
                    lodash.prototype.commit = wrapperCommit;
                    lodash.prototype.next = wrapperNext;
                    lodash.prototype.plant = wrapperPlant;
                    lodash.prototype.reverse = wrapperReverse;
                    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
                    lodash.prototype.first = lodash.prototype.head;
                    if (symIterator) {
                        lodash.prototype[symIterator] = wrapperToIterator;
                    }
                    return lodash;
                };
                var _ = runInContext();
                if (true) {
                    root._ = _;
                    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                        return _;
                    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                } else {}
            }).call(this);
        },
        666: module => {
            var runtime = function(exports) {
                "use strict";
                var Op = Object.prototype;
                var hasOwn = Op.hasOwnProperty;
                var undefined;
                var $Symbol = typeof Symbol === "function" ? Symbol : {};
                var iteratorSymbol = $Symbol.iterator || "@@iterator";
                var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
                var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
                function define(obj, key, value) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                    return obj[key];
                }
                try {
                    define({}, "");
                } catch (err) {
                    define = function(obj, key, value) {
                        return obj[key] = value;
                    };
                }
                function wrap(innerFn, outerFn, self, tryLocsList) {
                    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
                    var generator = Object.create(protoGenerator.prototype);
                    var context = new Context(tryLocsList || []);
                    generator._invoke = makeInvokeMethod(innerFn, self, context);
                    return generator;
                }
                exports.wrap = wrap;
                function tryCatch(fn, obj, arg) {
                    try {
                        return {
                            type: "normal",
                            arg: fn.call(obj, arg)
                        };
                    } catch (err) {
                        return {
                            type: "throw",
                            arg: err
                        };
                    }
                }
                var GenStateSuspendedStart = "suspendedStart";
                var GenStateSuspendedYield = "suspendedYield";
                var GenStateExecuting = "executing";
                var GenStateCompleted = "completed";
                var ContinueSentinel = {};
                function Generator() {}
                function GeneratorFunction() {}
                function GeneratorFunctionPrototype() {}
                var IteratorPrototype = {};
                IteratorPrototype[iteratorSymbol] = function() {
                    return this;
                };
                var getProto = Object.getPrototypeOf;
                var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
                if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
                    IteratorPrototype = NativeIteratorPrototype;
                }
                var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
                GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
                GeneratorFunctionPrototype.constructor = GeneratorFunction;
                GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");
                function defineIteratorMethods(prototype) {
                    [ "next", "throw", "return" ].forEach((function(method) {
                        define(prototype, method, (function(arg) {
                            return this._invoke(method, arg);
                        }));
                    }));
                }
                exports.isGeneratorFunction = function(genFun) {
                    var ctor = typeof genFun === "function" && genFun.constructor;
                    return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
                };
                exports.mark = function(genFun) {
                    if (Object.setPrototypeOf) {
                        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
                    } else {
                        genFun.__proto__ = GeneratorFunctionPrototype;
                        define(genFun, toStringTagSymbol, "GeneratorFunction");
                    }
                    genFun.prototype = Object.create(Gp);
                    return genFun;
                };
                exports.awrap = function(arg) {
                    return {
                        __await: arg
                    };
                };
                function AsyncIterator(generator, PromiseImpl) {
                    function invoke(method, arg, resolve, reject) {
                        var record = tryCatch(generator[method], generator, arg);
                        if (record.type === "throw") {
                            reject(record.arg);
                        } else {
                            var result = record.arg;
                            var value = result.value;
                            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
                                return PromiseImpl.resolve(value.__await).then((function(value) {
                                    invoke("next", value, resolve, reject);
                                }), (function(err) {
                                    invoke("throw", err, resolve, reject);
                                }));
                            }
                            return PromiseImpl.resolve(value).then((function(unwrapped) {
                                result.value = unwrapped;
                                resolve(result);
                            }), (function(error) {
                                return invoke("throw", error, resolve, reject);
                            }));
                        }
                    }
                    var previousPromise;
                    function enqueue(method, arg) {
                        function callInvokeWithMethodAndArg() {
                            return new PromiseImpl((function(resolve, reject) {
                                invoke(method, arg, resolve, reject);
                            }));
                        }
                        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
                    }
                    this._invoke = enqueue;
                }
                defineIteratorMethods(AsyncIterator.prototype);
                AsyncIterator.prototype[asyncIteratorSymbol] = function() {
                    return this;
                };
                exports.AsyncIterator = AsyncIterator;
                exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
                    if (PromiseImpl === void 0) PromiseImpl = Promise;
                    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
                    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then((function(result) {
                        return result.done ? result.value : iter.next();
                    }));
                };
                function makeInvokeMethod(innerFn, self, context) {
                    var state = GenStateSuspendedStart;
                    return function invoke(method, arg) {
                        if (state === GenStateExecuting) {
                            throw new Error("Generator is already running");
                        }
                        if (state === GenStateCompleted) {
                            if (method === "throw") {
                                throw arg;
                            }
                            return doneResult();
                        }
                        context.method = method;
                        context.arg = arg;
                        while (true) {
                            var delegate = context.delegate;
                            if (delegate) {
                                var delegateResult = maybeInvokeDelegate(delegate, context);
                                if (delegateResult) {
                                    if (delegateResult === ContinueSentinel) continue;
                                    return delegateResult;
                                }
                            }
                            if (context.method === "next") {
                                context.sent = context._sent = context.arg;
                            } else if (context.method === "throw") {
                                if (state === GenStateSuspendedStart) {
                                    state = GenStateCompleted;
                                    throw context.arg;
                                }
                                context.dispatchException(context.arg);
                            } else if (context.method === "return") {
                                context.abrupt("return", context.arg);
                            }
                            state = GenStateExecuting;
                            var record = tryCatch(innerFn, self, context);
                            if (record.type === "normal") {
                                state = context.done ? GenStateCompleted : GenStateSuspendedYield;
                                if (record.arg === ContinueSentinel) {
                                    continue;
                                }
                                return {
                                    value: record.arg,
                                    done: context.done
                                };
                            } else if (record.type === "throw") {
                                state = GenStateCompleted;
                                context.method = "throw";
                                context.arg = record.arg;
                            }
                        }
                    };
                }
                function maybeInvokeDelegate(delegate, context) {
                    var method = delegate.iterator[context.method];
                    if (method === undefined) {
                        context.delegate = null;
                        if (context.method === "throw") {
                            if (delegate.iterator["return"]) {
                                context.method = "return";
                                context.arg = undefined;
                                maybeInvokeDelegate(delegate, context);
                                if (context.method === "throw") {
                                    return ContinueSentinel;
                                }
                            }
                            context.method = "throw";
                            context.arg = new TypeError("The iterator does not provide a 'throw' method");
                        }
                        return ContinueSentinel;
                    }
                    var record = tryCatch(method, delegate.iterator, context.arg);
                    if (record.type === "throw") {
                        context.method = "throw";
                        context.arg = record.arg;
                        context.delegate = null;
                        return ContinueSentinel;
                    }
                    var info = record.arg;
                    if (!info) {
                        context.method = "throw";
                        context.arg = new TypeError("iterator result is not an object");
                        context.delegate = null;
                        return ContinueSentinel;
                    }
                    if (info.done) {
                        context[delegate.resultName] = info.value;
                        context.next = delegate.nextLoc;
                        if (context.method !== "return") {
                            context.method = "next";
                            context.arg = undefined;
                        }
                    } else {
                        return info;
                    }
                    context.delegate = null;
                    return ContinueSentinel;
                }
                defineIteratorMethods(Gp);
                define(Gp, toStringTagSymbol, "Generator");
                Gp[iteratorSymbol] = function() {
                    return this;
                };
                Gp.toString = function() {
                    return "[object Generator]";
                };
                function pushTryEntry(locs) {
                    var entry = {
                        tryLoc: locs[0]
                    };
                    if (1 in locs) {
                        entry.catchLoc = locs[1];
                    }
                    if (2 in locs) {
                        entry.finallyLoc = locs[2];
                        entry.afterLoc = locs[3];
                    }
                    this.tryEntries.push(entry);
                }
                function resetTryEntry(entry) {
                    var record = entry.completion || {};
                    record.type = "normal";
                    delete record.arg;
                    entry.completion = record;
                }
                function Context(tryLocsList) {
                    this.tryEntries = [ {
                        tryLoc: "root"
                    } ];
                    tryLocsList.forEach(pushTryEntry, this);
                    this.reset(true);
                }
                exports.keys = function(object) {
                    var keys = [];
                    for (var key in object) {
                        keys.push(key);
                    }
                    keys.reverse();
                    return function next() {
                        while (keys.length) {
                            var key = keys.pop();
                            if (key in object) {
                                next.value = key;
                                next.done = false;
                                return next;
                            }
                        }
                        next.done = true;
                        return next;
                    };
                };
                function values(iterable) {
                    if (iterable) {
                        var iteratorMethod = iterable[iteratorSymbol];
                        if (iteratorMethod) {
                            return iteratorMethod.call(iterable);
                        }
                        if (typeof iterable.next === "function") {
                            return iterable;
                        }
                        if (!isNaN(iterable.length)) {
                            var i = -1, next = function next() {
                                while (++i < iterable.length) {
                                    if (hasOwn.call(iterable, i)) {
                                        next.value = iterable[i];
                                        next.done = false;
                                        return next;
                                    }
                                }
                                next.value = undefined;
                                next.done = true;
                                return next;
                            };
                            return next.next = next;
                        }
                    }
                    return {
                        next: doneResult
                    };
                }
                exports.values = values;
                function doneResult() {
                    return {
                        value: undefined,
                        done: true
                    };
                }
                Context.prototype = {
                    constructor: Context,
                    reset: function(skipTempReset) {
                        this.prev = 0;
                        this.next = 0;
                        this.sent = this._sent = undefined;
                        this.done = false;
                        this.delegate = null;
                        this.method = "next";
                        this.arg = undefined;
                        this.tryEntries.forEach(resetTryEntry);
                        if (!skipTempReset) {
                            for (var name in this) {
                                if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                                    this[name] = undefined;
                                }
                            }
                        }
                    },
                    stop: function() {
                        this.done = true;
                        var rootEntry = this.tryEntries[0];
                        var rootRecord = rootEntry.completion;
                        if (rootRecord.type === "throw") {
                            throw rootRecord.arg;
                        }
                        return this.rval;
                    },
                    dispatchException: function(exception) {
                        if (this.done) {
                            throw exception;
                        }
                        var context = this;
                        function handle(loc, caught) {
                            record.type = "throw";
                            record.arg = exception;
                            context.next = loc;
                            if (caught) {
                                context.method = "next";
                                context.arg = undefined;
                            }
                            return !!caught;
                        }
                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var entry = this.tryEntries[i];
                            var record = entry.completion;
                            if (entry.tryLoc === "root") {
                                return handle("end");
                            }
                            if (entry.tryLoc <= this.prev) {
                                var hasCatch = hasOwn.call(entry, "catchLoc");
                                var hasFinally = hasOwn.call(entry, "finallyLoc");
                                if (hasCatch && hasFinally) {
                                    if (this.prev < entry.catchLoc) {
                                        return handle(entry.catchLoc, true);
                                    } else if (this.prev < entry.finallyLoc) {
                                        return handle(entry.finallyLoc);
                                    }
                                } else if (hasCatch) {
                                    if (this.prev < entry.catchLoc) {
                                        return handle(entry.catchLoc, true);
                                    }
                                } else if (hasFinally) {
                                    if (this.prev < entry.finallyLoc) {
                                        return handle(entry.finallyLoc);
                                    }
                                } else {
                                    throw new Error("try statement without catch or finally");
                                }
                            }
                        }
                    },
                    abrupt: function(type, arg) {
                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var entry = this.tryEntries[i];
                            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                                var finallyEntry = entry;
                                break;
                            }
                        }
                        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
                            finallyEntry = null;
                        }
                        var record = finallyEntry ? finallyEntry.completion : {};
                        record.type = type;
                        record.arg = arg;
                        if (finallyEntry) {
                            this.method = "next";
                            this.next = finallyEntry.finallyLoc;
                            return ContinueSentinel;
                        }
                        return this.complete(record);
                    },
                    complete: function(record, afterLoc) {
                        if (record.type === "throw") {
                            throw record.arg;
                        }
                        if (record.type === "break" || record.type === "continue") {
                            this.next = record.arg;
                        } else if (record.type === "return") {
                            this.rval = this.arg = record.arg;
                            this.method = "return";
                            this.next = "end";
                        } else if (record.type === "normal" && afterLoc) {
                            this.next = afterLoc;
                        }
                        return ContinueSentinel;
                    },
                    finish: function(finallyLoc) {
                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var entry = this.tryEntries[i];
                            if (entry.finallyLoc === finallyLoc) {
                                this.complete(entry.completion, entry.afterLoc);
                                resetTryEntry(entry);
                                return ContinueSentinel;
                            }
                        }
                    },
                    catch: function(tryLoc) {
                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var entry = this.tryEntries[i];
                            if (entry.tryLoc === tryLoc) {
                                var record = entry.completion;
                                if (record.type === "throw") {
                                    var thrown = record.arg;
                                    resetTryEntry(entry);
                                }
                                return thrown;
                            }
                        }
                        throw new Error("illegal catch attempt");
                    },
                    delegateYield: function(iterable, resultName, nextLoc) {
                        this.delegate = {
                            iterator: values(iterable),
                            resultName: resultName,
                            nextLoc: nextLoc
                        };
                        if (this.method === "next") {
                            this.arg = undefined;
                        }
                        return ContinueSentinel;
                    }
                };
                return exports;
            }(true ? module.exports : 0);
            try {
                regeneratorRuntime = runtime;
            } catch (accidentalStrictMode) {
                Function("r", "regeneratorRuntime = r")(runtime);
            }
        }
    };
    var __webpack_module_cache__ = {};
    function __webpack_require__(moduleId) {
        if (__webpack_module_cache__[moduleId]) {
            return __webpack_module_cache__[moduleId].exports;
        }
        var module = __webpack_module_cache__[moduleId] = {
            id: moduleId,
            loaded: false,
            exports: {}
        };
        __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        module.loaded = true;
        return module.exports;
    }
    (() => {
        __webpack_require__.n = module => {
            var getter = module && module.__esModule ? () => module["default"] : () => module;
            __webpack_require__.d(getter, {
                a: getter
            });
            return getter;
        };
    })();
    (() => {
        __webpack_require__.d = (exports, definition) => {
            for (var key in definition) {
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
                    Object.defineProperty(exports, key, {
                        enumerable: true,
                        get: definition[key]
                    });
                }
            }
        };
    })();
    (() => {
        __webpack_require__.g = function() {
            if (typeof globalThis === "object") return globalThis;
            try {
                return this || new Function("return this")();
            } catch (e) {
                if (typeof window === "object") return window;
            }
        }();
    })();
    (() => {
        __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
    })();
    (() => {
        __webpack_require__.r = exports => {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                Object.defineProperty(exports, Symbol.toStringTag, {
                    value: "Module"
                });
            }
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
        };
    })();
    (() => {
        __webpack_require__.nmd = module => {
            module.paths = [];
            if (!module.children) module.children = [];
            return module;
        };
    })();
    (() => {
        "use strict";
        var MBAutocompleteTextField_namespaceObject = {};
        __webpack_require__.r(MBAutocompleteTextField_namespaceObject);
        __webpack_require__.d(MBAutocompleteTextField_namespaceObject, {
            close: () => MBAutocompleteTextField_close,
            init: () => init,
            open: () => MBAutocompleteTextField_open,
            setDisabled: () => setDisabled,
            setValue: () => setValue
        });
        var MBBladeSet_namespaceObject = {};
        __webpack_require__.r(MBBladeSet_namespaceObject);
        __webpack_require__.d(MBBladeSet_namespaceObject, {
            closeBlade: () => closeBlade,
            openBlade: () => openBlade
        });
        var MBButton_namespaceObject = {};
        __webpack_require__.r(MBButton_namespaceObject);
        __webpack_require__.d(MBButton_namespaceObject, {
            init: () => MBButton_init
        });
        var MBCard_namespaceObject = {};
        __webpack_require__.r(MBCard_namespaceObject);
        __webpack_require__.d(MBCard_namespaceObject, {
            init: () => MBCard_init
        });
        var MBChipsSelectMulti_namespaceObject = {};
        __webpack_require__.r(MBChipsSelectMulti_namespaceObject);
        __webpack_require__.d(MBChipsSelectMulti_namespaceObject, {
            init: () => MBChipsSelectMulti_init,
            setDisabled: () => MBChipsSelectMulti_setDisabled,
            setSelected: () => setSelected
        });
        var MBCheckbox_namespaceObject = {};
        __webpack_require__.r(MBCheckbox_namespaceObject);
        __webpack_require__.d(MBCheckbox_namespaceObject, {
            init: () => MBCheckbox_init,
            setChecked: () => setChecked,
            setDisabled: () => MBCheckbox_setDisabled,
            setIndeterminate: () => setIndeterminate
        });
        var MBCircularProgress_namespaceObject = {};
        __webpack_require__.r(MBCircularProgress_namespaceObject);
        __webpack_require__.d(MBCircularProgress_namespaceObject, {
            init: () => MBCircularProgress_init,
            setProgress: () => setProgress
        });
        var MBDataTable_namespaceObject = {};
        __webpack_require__.r(MBDataTable_namespaceObject);
        __webpack_require__.d(MBDataTable_namespaceObject, {
            init: () => MBDataTable_init,
            setProgress: () => MBDataTable_setProgress
        });
        var MBDatePicker_namespaceObject = {};
        __webpack_require__.r(MBDatePicker_namespaceObject);
        __webpack_require__.d(MBDatePicker_namespaceObject, {
            init: () => MBDatePicker_init,
            listItemClick: () => listItemClick,
            scrollToYear: () => scrollToYear,
            setDisabled: () => MBDatePicker_setDisabled
        });
        var MBDialog_namespaceObject = {};
        __webpack_require__.r(MBDialog_namespaceObject);
        __webpack_require__.d(MBDialog_namespaceObject, {
            hide: () => hide,
            show: () => show
        });
        var MBDrawer_namespaceObject = {};
        __webpack_require__.r(MBDrawer_namespaceObject);
        __webpack_require__.d(MBDrawer_namespaceObject, {
            init: () => MBDrawer_init,
            toggle: () => toggle
        });
        var MBFloatingActionButton_namespaceObject = {};
        __webpack_require__.r(MBFloatingActionButton_namespaceObject);
        __webpack_require__.d(MBFloatingActionButton_namespaceObject, {
            init: () => MBFloatingActionButton_init,
            setExited: () => setExited
        });
        var MBGrid_namespaceObject = {};
        __webpack_require__.r(MBGrid_namespaceObject);
        __webpack_require__.d(MBGrid_namespaceObject, {
            getScrollBarWidth: () => getScrollBarWidth,
            getTextWidths: () => getTextWidths,
            syncScrollByID: () => syncScrollByID,
            syncScrollByRef: () => syncScrollByRef
        });
        var MBIconButton_namespaceObject = {};
        __webpack_require__.r(MBIconButton_namespaceObject);
        __webpack_require__.d(MBIconButton_namespaceObject, {
            init: () => MBIconButton_init
        });
        var MBIconButtonToggle_namespaceObject = {};
        __webpack_require__.r(MBIconButtonToggle_namespaceObject);
        __webpack_require__.d(MBIconButtonToggle_namespaceObject, {
            click: () => click,
            init: () => MBIconButtonToggle_init,
            setOn: () => setOn
        });
        var MBLinearProgress_namespaceObject = {};
        __webpack_require__.r(MBLinearProgress_namespaceObject);
        __webpack_require__.d(MBLinearProgress_namespaceObject, {
            init: () => MBLinearProgress_init,
            setProgress: () => MBLinearProgress_setProgress
        });
        var MBList_namespaceObject = {};
        __webpack_require__.r(MBList_namespaceObject);
        __webpack_require__.d(MBList_namespaceObject, {
            init: () => MBList_init
        });
        var MBMenu_namespaceObject = {};
        __webpack_require__.r(MBMenu_namespaceObject);
        __webpack_require__.d(MBMenu_namespaceObject, {
            hide: () => MBMenu_hide,
            init: () => MBMenu_init,
            show: () => MBMenu_show
        });
        var MBMenuSurface_namespaceObject = {};
        __webpack_require__.r(MBMenuSurface_namespaceObject);
        __webpack_require__.d(MBMenuSurface_namespaceObject, {
            hide: () => MBMenuSurface_hide,
            init: () => MBMenuSurface_init,
            show: () => MBMenuSurface_show
        });
        var MBRadioButton_namespaceObject = {};
        __webpack_require__.r(MBRadioButton_namespaceObject);
        __webpack_require__.d(MBRadioButton_namespaceObject, {
            init: () => MBRadioButton_init,
            setChecked: () => MBRadioButton_setChecked,
            setDisabled: () => MBRadioButton_setDisabled
        });
        var MBSegmentedButtonMulti_namespaceObject = {};
        __webpack_require__.r(MBSegmentedButtonMulti_namespaceObject);
        __webpack_require__.d(MBSegmentedButtonMulti_namespaceObject, {
            init: () => MBSegmentedButtonMulti_init,
            setDisabled: () => MBSegmentedButtonMulti_setDisabled,
            setSelected: () => MBSegmentedButtonMulti_setSelected
        });
        var MBSelect_namespaceObject = {};
        __webpack_require__.r(MBSelect_namespaceObject);
        __webpack_require__.d(MBSelect_namespaceObject, {
            init: () => MBSelect_init,
            setDisabled: () => MBSelect_setDisabled,
            setIndex: () => setIndex
        });
        var MBSlider_namespaceObject = {};
        __webpack_require__.r(MBSlider_namespaceObject);
        __webpack_require__.d(MBSlider_namespaceObject, {
            init: () => MBSlider_init,
            setDisabled: () => MBSlider_setDisabled,
            setValue: () => MBSlider_setValue
        });
        var MBSnackbar_namespaceObject = {};
        __webpack_require__.r(MBSnackbar_namespaceObject);
        __webpack_require__.d(MBSnackbar_namespaceObject, {
            init: () => MBSnackbar_init
        });
        var MBSwitch_namespaceObject = {};
        __webpack_require__.r(MBSwitch_namespaceObject);
        __webpack_require__.d(MBSwitch_namespaceObject, {
            init: () => MBSwitch_init,
            setChecked: () => MBSwitch_setChecked,
            setDisabled: () => MBSwitch_setDisabled
        });
        var MBTabBar_namespaceObject = {};
        __webpack_require__.r(MBTabBar_namespaceObject);
        __webpack_require__.d(MBTabBar_namespaceObject, {
            activateTab: () => activateTab,
            init: () => MBTabBar_init
        });
        var MBTextField_namespaceObject = {};
        __webpack_require__.r(MBTextField_namespaceObject);
        __webpack_require__.d(MBTextField_namespaceObject, {
            init: () => MBTextField_init,
            setDisabled: () => MBTextField_setDisabled,
            setHelperText: () => setHelperText,
            setType: () => setType,
            setValue: () => MBTextField_setValue
        });
        var MBTooltip_namespaceObject = {};
        __webpack_require__.r(MBTooltip_namespaceObject);
        __webpack_require__.d(MBTooltip_namespaceObject, {
            init: () => MBTooltip_init
        });
        var MBTopAppBar_namespaceObject = {};
        __webpack_require__.r(MBTopAppBar_namespaceObject);
        __webpack_require__.d(MBTopAppBar_namespaceObject, {
            init: () => MBTopAppBar_init
        });
        /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
        var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };
            return extendStatics(d, b);
        };
        function __extends(d, b) {
            extendStatics(d, b);
            function __() {
                this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
        }
        var __assign = function() {
            __assign = Object.assign || function __assign(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return __assign.apply(this, arguments);
        };
        function __rest(s, e) {
            var t = {};
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
            if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
            }
            return t;
        }
        function __decorate(decorators, target, key, desc) {
            var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
            if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
            return c > 3 && r && Object.defineProperty(target, key, r), r;
        }
        function __param(paramIndex, decorator) {
            return function(target, key) {
                decorator(target, key, paramIndex);
            };
        }
        function __metadata(metadataKey, metadataValue) {
            if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
        }
        function __awaiter(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P((function(resolve) {
                    resolve(value);
                }));
            }
            return new (P || (P = Promise))((function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        }
        function __generator(thisArg, body) {
            var _ = {
                label: 0,
                sent: function() {
                    if (t[0] & 1) throw t[1];
                    return t[1];
                },
                trys: [],
                ops: []
            }, f, y, t, g;
            return g = {
                next: verb(0),
                throw: verb(1),
                return: verb(2)
            }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
                return this;
            }), g;
            function verb(n) {
                return function(v) {
                    return step([ n, v ]);
                };
            }
            function step(op) {
                if (f) throw new TypeError("Generator is already executing.");
                while (_) try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 
                    0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                    if (y = 0, t) op = [ op[0] & 2, t.value ];
                    switch (op[0]) {
                      case 0:
                      case 1:
                        t = op;
                        break;

                      case 4:
                        _.label++;
                        return {
                            value: op[1],
                            done: false
                        };

                      case 5:
                        _.label++;
                        y = op[1];
                        op = [ 0 ];
                        continue;

                      case 7:
                        op = _.ops.pop();
                        _.trys.pop();
                        continue;

                      default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                            _ = 0;
                            continue;
                        }
                        if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                            _.label = op[1];
                            break;
                        }
                        if (op[0] === 6 && _.label < t[1]) {
                            _.label = t[1];
                            t = op;
                            break;
                        }
                        if (t && _.label < t[2]) {
                            _.label = t[2];
                            _.ops.push(op);
                            break;
                        }
                        if (t[2]) _.ops.pop();
                        _.trys.pop();
                        continue;
                    }
                    op = body.call(thisArg, _);
                } catch (e) {
                    op = [ 6, e ];
                    y = 0;
                } finally {
                    f = t = 0;
                }
                if (op[0] & 5) throw op[1];
                return {
                    value: op[0] ? op[1] : void 0,
                    done: true
                };
            }
        }
        function __createBinding(o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
        }
        function __exportStar(m, exports) {
            for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
        }
        function __values(o) {
            var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
            if (m) return m.call(o);
            if (o && typeof o.length === "number") return {
                next: function() {
                    if (o && i >= o.length) o = void 0;
                    return {
                        value: o && o[i++],
                        done: !o
                    };
                }
            };
            throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        function __read(o, n) {
            var m = typeof Symbol === "function" && o[Symbol.iterator];
            if (!m) return o;
            var i = m.call(o), r, ar = [], e;
            try {
                while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
            } catch (error) {
                e = {
                    error: error
                };
            } finally {
                try {
                    if (r && !r.done && (m = i["return"])) m.call(i);
                } finally {
                    if (e) throw e.error;
                }
            }
            return ar;
        }
        function __spread() {
            for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
            return ar;
        }
        function __spreadArrays() {
            for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
            for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, 
            k++) r[k] = a[j];
            return r;
        }
        function __await(v) {
            return this instanceof __await ? (this.v = v, this) : new __await(v);
        }
        function __asyncGenerator(thisArg, _arguments, generator) {
            if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
            var g = generator.apply(thisArg, _arguments || []), i, q = [];
            return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
                return this;
            }, i;
            function verb(n) {
                if (g[n]) i[n] = function(v) {
                    return new Promise((function(a, b) {
                        q.push([ n, v, a, b ]) > 1 || resume(n, v);
                    }));
                };
            }
            function resume(n, v) {
                try {
                    step(g[n](v));
                } catch (e) {
                    settle(q[0][3], e);
                }
            }
            function step(r) {
                r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
            }
            function fulfill(value) {
                resume("next", value);
            }
            function reject(value) {
                resume("throw", value);
            }
            function settle(f, v) {
                if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
            }
        }
        function __asyncDelegator(o) {
            var i, p;
            return i = {}, verb("next"), verb("throw", (function(e) {
                throw e;
            })), verb("return"), i[Symbol.iterator] = function() {
                return this;
            }, i;
            function verb(n, f) {
                i[n] = o[n] ? function(v) {
                    return (p = !p) ? {
                        value: __await(o[n](v)),
                        done: n === "return"
                    } : f ? f(v) : v;
                } : f;
            }
        }
        function __asyncValues(o) {
            if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
            var m = o[Symbol.asyncIterator], i;
            return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), 
            i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
                return this;
            }, i);
            function verb(n) {
                i[n] = o[n] && function(v) {
                    return new Promise((function(resolve, reject) {
                        v = o[n](v), settle(resolve, reject, v.done, v.value);
                    }));
                };
            }
            function settle(resolve, reject, d, v) {
                Promise.resolve(v).then((function(v) {
                    resolve({
                        value: v,
                        done: d
                    });
                }), reject);
            }
        }
        function __makeTemplateObject(cooked, raw) {
            if (Object.defineProperty) {
                Object.defineProperty(cooked, "raw", {
                    value: raw
                });
            } else {
                cooked.raw = raw;
            }
            return cooked;
        }
        function __importStar(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
            result.default = mod;
            return result;
        }
        function __importDefault(mod) {
            return mod && mod.__esModule ? mod : {
                default: mod
            };
        }
        function __classPrivateFieldGet(receiver, privateMap) {
            if (!privateMap.has(receiver)) {
                throw new TypeError("attempted to get private field on non-instance");
            }
            return privateMap.get(receiver);
        }
        function __classPrivateFieldSet(receiver, privateMap, value) {
            if (!privateMap.has(receiver)) {
                throw new TypeError("attempted to set private field on non-instance");
            }
            privateMap.set(receiver, value);
            return value;
        }
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCFoundation = function() {
            function MDCFoundation(adapter) {
                if (adapter === void 0) {
                    adapter = {};
                }
                this.adapter = adapter;
            }
            Object.defineProperty(MDCFoundation, "cssClasses", {
                get: function() {
                    return {};
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCFoundation, "strings", {
                get: function() {
                    return {};
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCFoundation, "numbers", {
                get: function() {
                    return {};
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCFoundation, "defaultAdapter", {
                get: function() {
                    return {};
                },
                enumerable: true,
                configurable: true
            });
            MDCFoundation.prototype.init = function() {};
            MDCFoundation.prototype.destroy = function() {};
            return MDCFoundation;
        }();
        const foundation = null && MDCFoundation;
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCComponent = function() {
            function MDCComponent(root, foundation) {
                var args = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    args[_i - 2] = arguments[_i];
                }
                this.root = root;
                this.initialize.apply(this, __spread(args));
                this.foundation = foundation === undefined ? this.getDefaultFoundation() : foundation;
                this.foundation.init();
                this.initialSyncWithDOM();
            }
            MDCComponent.attachTo = function(root) {
                return new MDCComponent(root, new MDCFoundation({}));
            };
            MDCComponent.prototype.initialize = function() {
                var _args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    _args[_i] = arguments[_i];
                }
            };
            MDCComponent.prototype.getDefaultFoundation = function() {
                throw new Error("Subclasses must override getDefaultFoundation to return a properly configured " + "foundation class");
            };
            MDCComponent.prototype.initialSyncWithDOM = function() {};
            MDCComponent.prototype.destroy = function() {
                this.foundation.destroy();
            };
            MDCComponent.prototype.listen = function(evtType, handler, options) {
                this.root.addEventListener(evtType, handler, options);
            };
            MDCComponent.prototype.unlisten = function(evtType, handler, options) {
                this.root.removeEventListener(evtType, handler, options);
            };
            MDCComponent.prototype.emit = function(evtType, evtData, shouldBubble) {
                if (shouldBubble === void 0) {
                    shouldBubble = false;
                }
                var evt;
                if (typeof CustomEvent === "function") {
                    evt = new CustomEvent(evtType, {
                        bubbles: shouldBubble,
                        detail: evtData
                    });
                } else {
                    evt = document.createEvent("CustomEvent");
                    evt.initCustomEvent(evtType, shouldBubble, false, evtData);
                }
                this.root.dispatchEvent(evt);
            };
            return MDCComponent;
        }();
        const component = null && MDCComponent;
        /**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        function applyPassive(globalObj) {
            if (globalObj === void 0) {
                globalObj = window;
            }
            return supportsPassiveOption(globalObj) ? {
                passive: true
            } : false;
        }
        function supportsPassiveOption(globalObj) {
            if (globalObj === void 0) {
                globalObj = window;
            }
            var passiveSupported = false;
            try {
                var options = {
                    get passive() {
                        passiveSupported = true;
                        return false;
                    }
                };
                var handler = function() {};
                globalObj.document.addEventListener("test", handler, options);
                globalObj.document.removeEventListener("test", handler, options);
            } catch (err) {
                passiveSupported = false;
            }
            return passiveSupported;
        }
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        function closest(element, selector) {
            if (element.closest) {
                return element.closest(selector);
            }
            var el = element;
            while (el) {
                if (matches(el, selector)) {
                    return el;
                }
                el = el.parentElement;
            }
            return null;
        }
        function matches(element, selector) {
            var nativeMatches = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
            return nativeMatches.call(element, selector);
        }
        function estimateScrollWidth(element) {
            var htmlEl = element;
            if (htmlEl.offsetParent !== null) {
                return htmlEl.scrollWidth;
            }
            var clone = htmlEl.cloneNode(true);
            clone.style.setProperty("position", "absolute");
            clone.style.setProperty("transform", "translate(-9999px, -9999px)");
            document.documentElement.appendChild(clone);
            var scrollWidth = clone.scrollWidth;
            document.documentElement.removeChild(clone);
            return scrollWidth;
        }
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var cssClasses = {
            LABEL_FLOAT_ABOVE: "mdc-floating-label--float-above",
            LABEL_REQUIRED: "mdc-floating-label--required",
            LABEL_SHAKE: "mdc-floating-label--shake",
            ROOT: "mdc-floating-label"
        };
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCFloatingLabelFoundation = function(_super) {
            __extends(MDCFloatingLabelFoundation, _super);
            function MDCFloatingLabelFoundation(adapter) {
                var _this = _super.call(this, __assign(__assign({}, MDCFloatingLabelFoundation.defaultAdapter), adapter)) || this;
                _this.shakeAnimationEndHandler_ = function() {
                    return _this.handleShakeAnimationEnd_();
                };
                return _this;
            }
            Object.defineProperty(MDCFloatingLabelFoundation, "cssClasses", {
                get: function() {
                    return cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCFloatingLabelFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClass: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        getWidth: function() {
                            return 0;
                        },
                        registerInteractionHandler: function() {
                            return undefined;
                        },
                        deregisterInteractionHandler: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCFloatingLabelFoundation.prototype.init = function() {
                this.adapter.registerInteractionHandler("animationend", this.shakeAnimationEndHandler_);
            };
            MDCFloatingLabelFoundation.prototype.destroy = function() {
                this.adapter.deregisterInteractionHandler("animationend", this.shakeAnimationEndHandler_);
            };
            MDCFloatingLabelFoundation.prototype.getWidth = function() {
                return this.adapter.getWidth();
            };
            MDCFloatingLabelFoundation.prototype.shake = function(shouldShake) {
                var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;
                if (shouldShake) {
                    this.adapter.addClass(LABEL_SHAKE);
                } else {
                    this.adapter.removeClass(LABEL_SHAKE);
                }
            };
            MDCFloatingLabelFoundation.prototype.float = function(shouldFloat) {
                var _a = MDCFloatingLabelFoundation.cssClasses, LABEL_FLOAT_ABOVE = _a.LABEL_FLOAT_ABOVE, LABEL_SHAKE = _a.LABEL_SHAKE;
                if (shouldFloat) {
                    this.adapter.addClass(LABEL_FLOAT_ABOVE);
                } else {
                    this.adapter.removeClass(LABEL_FLOAT_ABOVE);
                    this.adapter.removeClass(LABEL_SHAKE);
                }
            };
            MDCFloatingLabelFoundation.prototype.setRequired = function(isRequired) {
                var LABEL_REQUIRED = MDCFloatingLabelFoundation.cssClasses.LABEL_REQUIRED;
                if (isRequired) {
                    this.adapter.addClass(LABEL_REQUIRED);
                } else {
                    this.adapter.removeClass(LABEL_REQUIRED);
                }
            };
            MDCFloatingLabelFoundation.prototype.handleShakeAnimationEnd_ = function() {
                var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;
                this.adapter.removeClass(LABEL_SHAKE);
            };
            return MDCFloatingLabelFoundation;
        }(MDCFoundation);
        const floating_label_foundation = null && MDCFloatingLabelFoundation;
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCFloatingLabel = function(_super) {
            __extends(MDCFloatingLabel, _super);
            function MDCFloatingLabel() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCFloatingLabel.attachTo = function(root) {
                return new MDCFloatingLabel(root);
            };
            MDCFloatingLabel.prototype.shake = function(shouldShake) {
                this.foundation.shake(shouldShake);
            };
            MDCFloatingLabel.prototype.float = function(shouldFloat) {
                this.foundation.float(shouldFloat);
            };
            MDCFloatingLabel.prototype.setRequired = function(isRequired) {
                this.foundation.setRequired(isRequired);
            };
            MDCFloatingLabel.prototype.getWidth = function() {
                return this.foundation.getWidth();
            };
            MDCFloatingLabel.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    addClass: function(className) {
                        return _this.root.classList.add(className);
                    },
                    removeClass: function(className) {
                        return _this.root.classList.remove(className);
                    },
                    getWidth: function() {
                        return estimateScrollWidth(_this.root);
                    },
                    registerInteractionHandler: function(evtType, handler) {
                        return _this.listen(evtType, handler);
                    },
                    deregisterInteractionHandler: function(evtType, handler) {
                        return _this.unlisten(evtType, handler);
                    }
                };
                return new MDCFloatingLabelFoundation(adapter);
            };
            return MDCFloatingLabel;
        }(MDCComponent);
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var constants_cssClasses = {
            LINE_RIPPLE_ACTIVE: "mdc-line-ripple--active",
            LINE_RIPPLE_DEACTIVATING: "mdc-line-ripple--deactivating"
        };
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCLineRippleFoundation = function(_super) {
            __extends(MDCLineRippleFoundation, _super);
            function MDCLineRippleFoundation(adapter) {
                var _this = _super.call(this, __assign(__assign({}, MDCLineRippleFoundation.defaultAdapter), adapter)) || this;
                _this.transitionEndHandler_ = function(evt) {
                    return _this.handleTransitionEnd(evt);
                };
                return _this;
            }
            Object.defineProperty(MDCLineRippleFoundation, "cssClasses", {
                get: function() {
                    return constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCLineRippleFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClass: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        hasClass: function() {
                            return false;
                        },
                        setStyle: function() {
                            return undefined;
                        },
                        registerEventHandler: function() {
                            return undefined;
                        },
                        deregisterEventHandler: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCLineRippleFoundation.prototype.init = function() {
                this.adapter.registerEventHandler("transitionend", this.transitionEndHandler_);
            };
            MDCLineRippleFoundation.prototype.destroy = function() {
                this.adapter.deregisterEventHandler("transitionend", this.transitionEndHandler_);
            };
            MDCLineRippleFoundation.prototype.activate = function() {
                this.adapter.removeClass(constants_cssClasses.LINE_RIPPLE_DEACTIVATING);
                this.adapter.addClass(constants_cssClasses.LINE_RIPPLE_ACTIVE);
            };
            MDCLineRippleFoundation.prototype.setRippleCenter = function(xCoordinate) {
                this.adapter.setStyle("transform-origin", xCoordinate + "px center");
            };
            MDCLineRippleFoundation.prototype.deactivate = function() {
                this.adapter.addClass(constants_cssClasses.LINE_RIPPLE_DEACTIVATING);
            };
            MDCLineRippleFoundation.prototype.handleTransitionEnd = function(evt) {
                var isDeactivating = this.adapter.hasClass(constants_cssClasses.LINE_RIPPLE_DEACTIVATING);
                if (evt.propertyName === "opacity") {
                    if (isDeactivating) {
                        this.adapter.removeClass(constants_cssClasses.LINE_RIPPLE_ACTIVE);
                        this.adapter.removeClass(constants_cssClasses.LINE_RIPPLE_DEACTIVATING);
                    }
                }
            };
            return MDCLineRippleFoundation;
        }(MDCFoundation);
        const line_ripple_foundation = null && MDCLineRippleFoundation;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCLineRipple = function(_super) {
            __extends(MDCLineRipple, _super);
            function MDCLineRipple() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCLineRipple.attachTo = function(root) {
                return new MDCLineRipple(root);
            };
            MDCLineRipple.prototype.activate = function() {
                this.foundation.activate();
            };
            MDCLineRipple.prototype.deactivate = function() {
                this.foundation.deactivate();
            };
            MDCLineRipple.prototype.setRippleCenter = function(xCoordinate) {
                this.foundation.setRippleCenter(xCoordinate);
            };
            MDCLineRipple.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    addClass: function(className) {
                        return _this.root.classList.add(className);
                    },
                    removeClass: function(className) {
                        return _this.root.classList.remove(className);
                    },
                    hasClass: function(className) {
                        return _this.root.classList.contains(className);
                    },
                    setStyle: function(propertyName, value) {
                        return _this.root.style.setProperty(propertyName, value);
                    },
                    registerEventHandler: function(evtType, handler) {
                        return _this.listen(evtType, handler);
                    },
                    deregisterEventHandler: function(evtType, handler) {
                        return _this.unlisten(evtType, handler);
                    }
                };
                return new MDCLineRippleFoundation(adapter);
            };
            return MDCLineRipple;
        }(MDCComponent);
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var strings = {
            NOTCH_ELEMENT_SELECTOR: ".mdc-notched-outline__notch"
        };
        var numbers = {
            NOTCH_ELEMENT_PADDING: 8
        };
        var notched_outline_constants_cssClasses = {
            NO_LABEL: "mdc-notched-outline--no-label",
            OUTLINE_NOTCHED: "mdc-notched-outline--notched",
            OUTLINE_UPGRADED: "mdc-notched-outline--upgraded"
        };
        /**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCNotchedOutlineFoundation = function(_super) {
            __extends(MDCNotchedOutlineFoundation, _super);
            function MDCNotchedOutlineFoundation(adapter) {
                return _super.call(this, __assign(__assign({}, MDCNotchedOutlineFoundation.defaultAdapter), adapter)) || this;
            }
            Object.defineProperty(MDCNotchedOutlineFoundation, "strings", {
                get: function() {
                    return strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCNotchedOutlineFoundation, "cssClasses", {
                get: function() {
                    return notched_outline_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCNotchedOutlineFoundation, "numbers", {
                get: function() {
                    return numbers;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCNotchedOutlineFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClass: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        setNotchWidthProperty: function() {
                            return undefined;
                        },
                        removeNotchWidthProperty: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCNotchedOutlineFoundation.prototype.notch = function(notchWidth) {
                var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
                if (notchWidth > 0) {
                    notchWidth += numbers.NOTCH_ELEMENT_PADDING;
                }
                this.adapter.setNotchWidthProperty(notchWidth);
                this.adapter.addClass(OUTLINE_NOTCHED);
            };
            MDCNotchedOutlineFoundation.prototype.closeNotch = function() {
                var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
                this.adapter.removeClass(OUTLINE_NOTCHED);
                this.adapter.removeNotchWidthProperty();
            };
            return MDCNotchedOutlineFoundation;
        }(MDCFoundation);
        const notched_outline_foundation = null && MDCNotchedOutlineFoundation;
        /**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCNotchedOutline = function(_super) {
            __extends(MDCNotchedOutline, _super);
            function MDCNotchedOutline() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCNotchedOutline.attachTo = function(root) {
                return new MDCNotchedOutline(root);
            };
            MDCNotchedOutline.prototype.initialSyncWithDOM = function() {
                this.notchElement_ = this.root.querySelector(strings.NOTCH_ELEMENT_SELECTOR);
                var label = this.root.querySelector("." + MDCFloatingLabelFoundation.cssClasses.ROOT);
                if (label) {
                    label.style.transitionDuration = "0s";
                    this.root.classList.add(notched_outline_constants_cssClasses.OUTLINE_UPGRADED);
                    requestAnimationFrame((function() {
                        label.style.transitionDuration = "";
                    }));
                } else {
                    this.root.classList.add(notched_outline_constants_cssClasses.NO_LABEL);
                }
            };
            MDCNotchedOutline.prototype.notch = function(notchWidth) {
                this.foundation.notch(notchWidth);
            };
            MDCNotchedOutline.prototype.closeNotch = function() {
                this.foundation.closeNotch();
            };
            MDCNotchedOutline.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    addClass: function(className) {
                        return _this.root.classList.add(className);
                    },
                    removeClass: function(className) {
                        return _this.root.classList.remove(className);
                    },
                    setNotchWidthProperty: function(width) {
                        return _this.notchElement_.style.setProperty("width", width + "px");
                    },
                    removeNotchWidthProperty: function() {
                        return _this.notchElement_.style.removeProperty("width");
                    }
                };
                return new MDCNotchedOutlineFoundation(adapter);
            };
            return MDCNotchedOutline;
        }(MDCComponent);
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var ripple_constants_cssClasses = {
            BG_FOCUSED: "mdc-ripple-upgraded--background-focused",
            FG_ACTIVATION: "mdc-ripple-upgraded--foreground-activation",
            FG_DEACTIVATION: "mdc-ripple-upgraded--foreground-deactivation",
            ROOT: "mdc-ripple-upgraded",
            UNBOUNDED: "mdc-ripple-upgraded--unbounded"
        };
        var constants_strings = {
            VAR_FG_SCALE: "--mdc-ripple-fg-scale",
            VAR_FG_SIZE: "--mdc-ripple-fg-size",
            VAR_FG_TRANSLATE_END: "--mdc-ripple-fg-translate-end",
            VAR_FG_TRANSLATE_START: "--mdc-ripple-fg-translate-start",
            VAR_LEFT: "--mdc-ripple-left",
            VAR_TOP: "--mdc-ripple-top"
        };
        var constants_numbers = {
            DEACTIVATION_TIMEOUT_MS: 225,
            FG_DEACTIVATION_MS: 150,
            INITIAL_ORIGIN_SCALE: .6,
            PADDING: 10,
            TAP_DELAY_MS: 300
        };
        var supportsCssVariables_;
        function supportsCssVariables(windowObj, forceRefresh) {
            if (forceRefresh === void 0) {
                forceRefresh = false;
            }
            var CSS = windowObj.CSS;
            var supportsCssVars = supportsCssVariables_;
            if (typeof supportsCssVariables_ === "boolean" && !forceRefresh) {
                return supportsCssVariables_;
            }
            var supportsFunctionPresent = CSS && typeof CSS.supports === "function";
            if (!supportsFunctionPresent) {
                return false;
            }
            var explicitlySupportsCssVars = CSS.supports("--css-vars", "yes");
            var weAreFeatureDetectingSafari10plus = CSS.supports("(--css-vars: yes)") && CSS.supports("color", "#00000000");
            supportsCssVars = explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus;
            if (!forceRefresh) {
                supportsCssVariables_ = supportsCssVars;
            }
            return supportsCssVars;
        }
        function getNormalizedEventCoords(evt, pageOffset, clientRect) {
            if (!evt) {
                return {
                    x: 0,
                    y: 0
                };
            }
            var x = pageOffset.x, y = pageOffset.y;
            var documentX = x + clientRect.left;
            var documentY = y + clientRect.top;
            var normalizedX;
            var normalizedY;
            if (evt.type === "touchstart") {
                var touchEvent = evt;
                normalizedX = touchEvent.changedTouches[0].pageX - documentX;
                normalizedY = touchEvent.changedTouches[0].pageY - documentY;
            } else {
                var mouseEvent = evt;
                normalizedX = mouseEvent.pageX - documentX;
                normalizedY = mouseEvent.pageY - documentY;
            }
            return {
                x: normalizedX,
                y: normalizedY
            };
        }
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var ACTIVATION_EVENT_TYPES = [ "touchstart", "pointerdown", "mousedown", "keydown" ];
        var POINTER_DEACTIVATION_EVENT_TYPES = [ "touchend", "pointerup", "mouseup", "contextmenu" ];
        var activatedTargets = [];
        var MDCRippleFoundation = function(_super) {
            __extends(MDCRippleFoundation, _super);
            function MDCRippleFoundation(adapter) {
                var _this = _super.call(this, __assign(__assign({}, MDCRippleFoundation.defaultAdapter), adapter)) || this;
                _this.activationAnimationHasEnded_ = false;
                _this.activationTimer_ = 0;
                _this.fgDeactivationRemovalTimer_ = 0;
                _this.fgScale_ = "0";
                _this.frame_ = {
                    width: 0,
                    height: 0
                };
                _this.initialSize_ = 0;
                _this.layoutFrame_ = 0;
                _this.maxRadius_ = 0;
                _this.unboundedCoords_ = {
                    left: 0,
                    top: 0
                };
                _this.activationState_ = _this.defaultActivationState_();
                _this.activationTimerCallback_ = function() {
                    _this.activationAnimationHasEnded_ = true;
                    _this.runDeactivationUXLogicIfReady_();
                };
                _this.activateHandler_ = function(e) {
                    return _this.activate_(e);
                };
                _this.deactivateHandler_ = function() {
                    return _this.deactivate_();
                };
                _this.focusHandler_ = function() {
                    return _this.handleFocus();
                };
                _this.blurHandler_ = function() {
                    return _this.handleBlur();
                };
                _this.resizeHandler_ = function() {
                    return _this.layout();
                };
                return _this;
            }
            Object.defineProperty(MDCRippleFoundation, "cssClasses", {
                get: function() {
                    return ripple_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCRippleFoundation, "strings", {
                get: function() {
                    return constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCRippleFoundation, "numbers", {
                get: function() {
                    return constants_numbers;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCRippleFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClass: function() {
                            return undefined;
                        },
                        browserSupportsCssVars: function() {
                            return true;
                        },
                        computeBoundingRect: function() {
                            return {
                                top: 0,
                                right: 0,
                                bottom: 0,
                                left: 0,
                                width: 0,
                                height: 0
                            };
                        },
                        containsEventTarget: function() {
                            return true;
                        },
                        deregisterDocumentInteractionHandler: function() {
                            return undefined;
                        },
                        deregisterInteractionHandler: function() {
                            return undefined;
                        },
                        deregisterResizeHandler: function() {
                            return undefined;
                        },
                        getWindowPageOffset: function() {
                            return {
                                x: 0,
                                y: 0
                            };
                        },
                        isSurfaceActive: function() {
                            return true;
                        },
                        isSurfaceDisabled: function() {
                            return true;
                        },
                        isUnbounded: function() {
                            return true;
                        },
                        registerDocumentInteractionHandler: function() {
                            return undefined;
                        },
                        registerInteractionHandler: function() {
                            return undefined;
                        },
                        registerResizeHandler: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        updateCssVariable: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCRippleFoundation.prototype.init = function() {
                var _this = this;
                var supportsPressRipple = this.supportsPressRipple_();
                this.registerRootHandlers_(supportsPressRipple);
                if (supportsPressRipple) {
                    var _a = MDCRippleFoundation.cssClasses, ROOT_1 = _a.ROOT, UNBOUNDED_1 = _a.UNBOUNDED;
                    requestAnimationFrame((function() {
                        _this.adapter.addClass(ROOT_1);
                        if (_this.adapter.isUnbounded()) {
                            _this.adapter.addClass(UNBOUNDED_1);
                            _this.layoutInternal_();
                        }
                    }));
                }
            };
            MDCRippleFoundation.prototype.destroy = function() {
                var _this = this;
                if (this.supportsPressRipple_()) {
                    if (this.activationTimer_) {
                        clearTimeout(this.activationTimer_);
                        this.activationTimer_ = 0;
                        this.adapter.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
                    }
                    if (this.fgDeactivationRemovalTimer_) {
                        clearTimeout(this.fgDeactivationRemovalTimer_);
                        this.fgDeactivationRemovalTimer_ = 0;
                        this.adapter.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
                    }
                    var _a = MDCRippleFoundation.cssClasses, ROOT_2 = _a.ROOT, UNBOUNDED_2 = _a.UNBOUNDED;
                    requestAnimationFrame((function() {
                        _this.adapter.removeClass(ROOT_2);
                        _this.adapter.removeClass(UNBOUNDED_2);
                        _this.removeCssVars_();
                    }));
                }
                this.deregisterRootHandlers_();
                this.deregisterDeactivationHandlers_();
            };
            MDCRippleFoundation.prototype.activate = function(evt) {
                this.activate_(evt);
            };
            MDCRippleFoundation.prototype.deactivate = function() {
                this.deactivate_();
            };
            MDCRippleFoundation.prototype.layout = function() {
                var _this = this;
                if (this.layoutFrame_) {
                    cancelAnimationFrame(this.layoutFrame_);
                }
                this.layoutFrame_ = requestAnimationFrame((function() {
                    _this.layoutInternal_();
                    _this.layoutFrame_ = 0;
                }));
            };
            MDCRippleFoundation.prototype.setUnbounded = function(unbounded) {
                var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;
                if (unbounded) {
                    this.adapter.addClass(UNBOUNDED);
                } else {
                    this.adapter.removeClass(UNBOUNDED);
                }
            };
            MDCRippleFoundation.prototype.handleFocus = function() {
                var _this = this;
                requestAnimationFrame((function() {
                    return _this.adapter.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
                }));
            };
            MDCRippleFoundation.prototype.handleBlur = function() {
                var _this = this;
                requestAnimationFrame((function() {
                    return _this.adapter.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
                }));
            };
            MDCRippleFoundation.prototype.supportsPressRipple_ = function() {
                return this.adapter.browserSupportsCssVars();
            };
            MDCRippleFoundation.prototype.defaultActivationState_ = function() {
                return {
                    activationEvent: undefined,
                    hasDeactivationUXRun: false,
                    isActivated: false,
                    isProgrammatic: false,
                    wasActivatedByPointer: false,
                    wasElementMadeActive: false
                };
            };
            MDCRippleFoundation.prototype.registerRootHandlers_ = function(supportsPressRipple) {
                var _this = this;
                if (supportsPressRipple) {
                    ACTIVATION_EVENT_TYPES.forEach((function(evtType) {
                        _this.adapter.registerInteractionHandler(evtType, _this.activateHandler_);
                    }));
                    if (this.adapter.isUnbounded()) {
                        this.adapter.registerResizeHandler(this.resizeHandler_);
                    }
                }
                this.adapter.registerInteractionHandler("focus", this.focusHandler_);
                this.adapter.registerInteractionHandler("blur", this.blurHandler_);
            };
            MDCRippleFoundation.prototype.registerDeactivationHandlers_ = function(evt) {
                var _this = this;
                if (evt.type === "keydown") {
                    this.adapter.registerInteractionHandler("keyup", this.deactivateHandler_);
                } else {
                    POINTER_DEACTIVATION_EVENT_TYPES.forEach((function(evtType) {
                        _this.adapter.registerDocumentInteractionHandler(evtType, _this.deactivateHandler_);
                    }));
                }
            };
            MDCRippleFoundation.prototype.deregisterRootHandlers_ = function() {
                var _this = this;
                ACTIVATION_EVENT_TYPES.forEach((function(evtType) {
                    _this.adapter.deregisterInteractionHandler(evtType, _this.activateHandler_);
                }));
                this.adapter.deregisterInteractionHandler("focus", this.focusHandler_);
                this.adapter.deregisterInteractionHandler("blur", this.blurHandler_);
                if (this.adapter.isUnbounded()) {
                    this.adapter.deregisterResizeHandler(this.resizeHandler_);
                }
            };
            MDCRippleFoundation.prototype.deregisterDeactivationHandlers_ = function() {
                var _this = this;
                this.adapter.deregisterInteractionHandler("keyup", this.deactivateHandler_);
                POINTER_DEACTIVATION_EVENT_TYPES.forEach((function(evtType) {
                    _this.adapter.deregisterDocumentInteractionHandler(evtType, _this.deactivateHandler_);
                }));
            };
            MDCRippleFoundation.prototype.removeCssVars_ = function() {
                var _this = this;
                var rippleStrings = MDCRippleFoundation.strings;
                var keys = Object.keys(rippleStrings);
                keys.forEach((function(key) {
                    if (key.indexOf("VAR_") === 0) {
                        _this.adapter.updateCssVariable(rippleStrings[key], null);
                    }
                }));
            };
            MDCRippleFoundation.prototype.activate_ = function(evt) {
                var _this = this;
                if (this.adapter.isSurfaceDisabled()) {
                    return;
                }
                var activationState = this.activationState_;
                if (activationState.isActivated) {
                    return;
                }
                var previousActivationEvent = this.previousActivationEvent_;
                var isSameInteraction = previousActivationEvent && evt !== undefined && previousActivationEvent.type !== evt.type;
                if (isSameInteraction) {
                    return;
                }
                activationState.isActivated = true;
                activationState.isProgrammatic = evt === undefined;
                activationState.activationEvent = evt;
                activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : evt !== undefined && (evt.type === "mousedown" || evt.type === "touchstart" || evt.type === "pointerdown");
                var hasActivatedChild = evt !== undefined && activatedTargets.length > 0 && activatedTargets.some((function(target) {
                    return _this.adapter.containsEventTarget(target);
                }));
                if (hasActivatedChild) {
                    this.resetActivationState_();
                    return;
                }
                if (evt !== undefined) {
                    activatedTargets.push(evt.target);
                    this.registerDeactivationHandlers_(evt);
                }
                activationState.wasElementMadeActive = this.checkElementMadeActive_(evt);
                if (activationState.wasElementMadeActive) {
                    this.animateActivation_();
                }
                requestAnimationFrame((function() {
                    activatedTargets = [];
                    if (!activationState.wasElementMadeActive && evt !== undefined && (evt.key === " " || evt.keyCode === 32)) {
                        activationState.wasElementMadeActive = _this.checkElementMadeActive_(evt);
                        if (activationState.wasElementMadeActive) {
                            _this.animateActivation_();
                        }
                    }
                    if (!activationState.wasElementMadeActive) {
                        _this.activationState_ = _this.defaultActivationState_();
                    }
                }));
            };
            MDCRippleFoundation.prototype.checkElementMadeActive_ = function(evt) {
                return evt !== undefined && evt.type === "keydown" ? this.adapter.isSurfaceActive() : true;
            };
            MDCRippleFoundation.prototype.animateActivation_ = function() {
                var _this = this;
                var _a = MDCRippleFoundation.strings, VAR_FG_TRANSLATE_START = _a.VAR_FG_TRANSLATE_START, VAR_FG_TRANSLATE_END = _a.VAR_FG_TRANSLATE_END;
                var _b = MDCRippleFoundation.cssClasses, FG_DEACTIVATION = _b.FG_DEACTIVATION, FG_ACTIVATION = _b.FG_ACTIVATION;
                var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
                this.layoutInternal_();
                var translateStart = "";
                var translateEnd = "";
                if (!this.adapter.isUnbounded()) {
                    var _c = this.getFgTranslationCoordinates_(), startPoint = _c.startPoint, endPoint = _c.endPoint;
                    translateStart = startPoint.x + "px, " + startPoint.y + "px";
                    translateEnd = endPoint.x + "px, " + endPoint.y + "px";
                }
                this.adapter.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
                this.adapter.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
                clearTimeout(this.activationTimer_);
                clearTimeout(this.fgDeactivationRemovalTimer_);
                this.rmBoundedActivationClasses_();
                this.adapter.removeClass(FG_DEACTIVATION);
                this.adapter.computeBoundingRect();
                this.adapter.addClass(FG_ACTIVATION);
                this.activationTimer_ = setTimeout((function() {
                    return _this.activationTimerCallback_();
                }), DEACTIVATION_TIMEOUT_MS);
            };
            MDCRippleFoundation.prototype.getFgTranslationCoordinates_ = function() {
                var _a = this.activationState_, activationEvent = _a.activationEvent, wasActivatedByPointer = _a.wasActivatedByPointer;
                var startPoint;
                if (wasActivatedByPointer) {
                    startPoint = getNormalizedEventCoords(activationEvent, this.adapter.getWindowPageOffset(), this.adapter.computeBoundingRect());
                } else {
                    startPoint = {
                        x: this.frame_.width / 2,
                        y: this.frame_.height / 2
                    };
                }
                startPoint = {
                    x: startPoint.x - this.initialSize_ / 2,
                    y: startPoint.y - this.initialSize_ / 2
                };
                var endPoint = {
                    x: this.frame_.width / 2 - this.initialSize_ / 2,
                    y: this.frame_.height / 2 - this.initialSize_ / 2
                };
                return {
                    startPoint: startPoint,
                    endPoint: endPoint
                };
            };
            MDCRippleFoundation.prototype.runDeactivationUXLogicIfReady_ = function() {
                var _this = this;
                var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
                var _a = this.activationState_, hasDeactivationUXRun = _a.hasDeactivationUXRun, isActivated = _a.isActivated;
                var activationHasEnded = hasDeactivationUXRun || !isActivated;
                if (activationHasEnded && this.activationAnimationHasEnded_) {
                    this.rmBoundedActivationClasses_();
                    this.adapter.addClass(FG_DEACTIVATION);
                    this.fgDeactivationRemovalTimer_ = setTimeout((function() {
                        _this.adapter.removeClass(FG_DEACTIVATION);
                    }), constants_numbers.FG_DEACTIVATION_MS);
                }
            };
            MDCRippleFoundation.prototype.rmBoundedActivationClasses_ = function() {
                var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
                this.adapter.removeClass(FG_ACTIVATION);
                this.activationAnimationHasEnded_ = false;
                this.adapter.computeBoundingRect();
            };
            MDCRippleFoundation.prototype.resetActivationState_ = function() {
                var _this = this;
                this.previousActivationEvent_ = this.activationState_.activationEvent;
                this.activationState_ = this.defaultActivationState_();
                setTimeout((function() {
                    return _this.previousActivationEvent_ = undefined;
                }), MDCRippleFoundation.numbers.TAP_DELAY_MS);
            };
            MDCRippleFoundation.prototype.deactivate_ = function() {
                var _this = this;
                var activationState = this.activationState_;
                if (!activationState.isActivated) {
                    return;
                }
                var state = __assign({}, activationState);
                if (activationState.isProgrammatic) {
                    requestAnimationFrame((function() {
                        return _this.animateDeactivation_(state);
                    }));
                    this.resetActivationState_();
                } else {
                    this.deregisterDeactivationHandlers_();
                    requestAnimationFrame((function() {
                        _this.activationState_.hasDeactivationUXRun = true;
                        _this.animateDeactivation_(state);
                        _this.resetActivationState_();
                    }));
                }
            };
            MDCRippleFoundation.prototype.animateDeactivation_ = function(_a) {
                var wasActivatedByPointer = _a.wasActivatedByPointer, wasElementMadeActive = _a.wasElementMadeActive;
                if (wasActivatedByPointer || wasElementMadeActive) {
                    this.runDeactivationUXLogicIfReady_();
                }
            };
            MDCRippleFoundation.prototype.layoutInternal_ = function() {
                var _this = this;
                this.frame_ = this.adapter.computeBoundingRect();
                var maxDim = Math.max(this.frame_.height, this.frame_.width);
                var getBoundedRadius = function() {
                    var hypotenuse = Math.sqrt(Math.pow(_this.frame_.width, 2) + Math.pow(_this.frame_.height, 2));
                    return hypotenuse + MDCRippleFoundation.numbers.PADDING;
                };
                this.maxRadius_ = this.adapter.isUnbounded() ? maxDim : getBoundedRadius();
                var initialSize = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
                if (this.adapter.isUnbounded() && initialSize % 2 !== 0) {
                    this.initialSize_ = initialSize - 1;
                } else {
                    this.initialSize_ = initialSize;
                }
                this.fgScale_ = "" + this.maxRadius_ / this.initialSize_;
                this.updateLayoutCssVars_();
            };
            MDCRippleFoundation.prototype.updateLayoutCssVars_ = function() {
                var _a = MDCRippleFoundation.strings, VAR_FG_SIZE = _a.VAR_FG_SIZE, VAR_LEFT = _a.VAR_LEFT, VAR_TOP = _a.VAR_TOP, VAR_FG_SCALE = _a.VAR_FG_SCALE;
                this.adapter.updateCssVariable(VAR_FG_SIZE, this.initialSize_ + "px");
                this.adapter.updateCssVariable(VAR_FG_SCALE, this.fgScale_);
                if (this.adapter.isUnbounded()) {
                    this.unboundedCoords_ = {
                        left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
                        top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
                    };
                    this.adapter.updateCssVariable(VAR_LEFT, this.unboundedCoords_.left + "px");
                    this.adapter.updateCssVariable(VAR_TOP, this.unboundedCoords_.top + "px");
                }
            };
            return MDCRippleFoundation;
        }(MDCFoundation);
        const ripple_foundation = null && MDCRippleFoundation;
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCRipple = function(_super) {
            __extends(MDCRipple, _super);
            function MDCRipple() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.disabled = false;
                return _this;
            }
            MDCRipple.attachTo = function(root, opts) {
                if (opts === void 0) {
                    opts = {
                        isUnbounded: undefined
                    };
                }
                var ripple = new MDCRipple(root);
                if (opts.isUnbounded !== undefined) {
                    ripple.unbounded = opts.isUnbounded;
                }
                return ripple;
            };
            MDCRipple.createAdapter = function(instance) {
                return {
                    addClass: function(className) {
                        return instance.root.classList.add(className);
                    },
                    browserSupportsCssVars: function() {
                        return supportsCssVariables(window);
                    },
                    computeBoundingRect: function() {
                        return instance.root.getBoundingClientRect();
                    },
                    containsEventTarget: function(target) {
                        return instance.root.contains(target);
                    },
                    deregisterDocumentInteractionHandler: function(evtType, handler) {
                        return document.documentElement.removeEventListener(evtType, handler, applyPassive());
                    },
                    deregisterInteractionHandler: function(evtType, handler) {
                        return instance.root.removeEventListener(evtType, handler, applyPassive());
                    },
                    deregisterResizeHandler: function(handler) {
                        return window.removeEventListener("resize", handler);
                    },
                    getWindowPageOffset: function() {
                        return {
                            x: window.pageXOffset,
                            y: window.pageYOffset
                        };
                    },
                    isSurfaceActive: function() {
                        return matches(instance.root, ":active");
                    },
                    isSurfaceDisabled: function() {
                        return Boolean(instance.disabled);
                    },
                    isUnbounded: function() {
                        return Boolean(instance.unbounded);
                    },
                    registerDocumentInteractionHandler: function(evtType, handler) {
                        return document.documentElement.addEventListener(evtType, handler, applyPassive());
                    },
                    registerInteractionHandler: function(evtType, handler) {
                        return instance.root.addEventListener(evtType, handler, applyPassive());
                    },
                    registerResizeHandler: function(handler) {
                        return window.addEventListener("resize", handler);
                    },
                    removeClass: function(className) {
                        return instance.root.classList.remove(className);
                    },
                    updateCssVariable: function(varName, value) {
                        return instance.root.style.setProperty(varName, value);
                    }
                };
            };
            Object.defineProperty(MDCRipple.prototype, "unbounded", {
                get: function() {
                    return Boolean(this.unbounded_);
                },
                set: function(unbounded) {
                    this.unbounded_ = Boolean(unbounded);
                    this.setUnbounded_();
                },
                enumerable: true,
                configurable: true
            });
            MDCRipple.prototype.activate = function() {
                this.foundation.activate();
            };
            MDCRipple.prototype.deactivate = function() {
                this.foundation.deactivate();
            };
            MDCRipple.prototype.layout = function() {
                this.foundation.layout();
            };
            MDCRipple.prototype.getDefaultFoundation = function() {
                return new MDCRippleFoundation(MDCRipple.createAdapter(this));
            };
            MDCRipple.prototype.initialSyncWithDOM = function() {
                var root = this.root;
                this.unbounded = "mdcRippleIsUnbounded" in root.dataset;
            };
            MDCRipple.prototype.setUnbounded_ = function() {
                this.foundation.setUnbounded(Boolean(this.unbounded_));
            };
            return MDCRipple;
        }(MDCComponent);
        /**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var character_counter_constants_cssClasses = {
            ROOT: "mdc-text-field-character-counter"
        };
        var character_counter_constants_strings = {
            ROOT_SELECTOR: "." + character_counter_constants_cssClasses.ROOT
        };
        /**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCTextFieldCharacterCounterFoundation = function(_super) {
            __extends(MDCTextFieldCharacterCounterFoundation, _super);
            function MDCTextFieldCharacterCounterFoundation(adapter) {
                return _super.call(this, __assign(__assign({}, MDCTextFieldCharacterCounterFoundation.defaultAdapter), adapter)) || this;
            }
            Object.defineProperty(MDCTextFieldCharacterCounterFoundation, "cssClasses", {
                get: function() {
                    return character_counter_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextFieldCharacterCounterFoundation, "strings", {
                get: function() {
                    return character_counter_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextFieldCharacterCounterFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        setContent: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCTextFieldCharacterCounterFoundation.prototype.setCounterValue = function(currentLength, maxLength) {
                currentLength = Math.min(currentLength, maxLength);
                this.adapter.setContent(currentLength + " / " + maxLength);
            };
            return MDCTextFieldCharacterCounterFoundation;
        }(MDCFoundation);
        const character_counter_foundation = null && MDCTextFieldCharacterCounterFoundation;
        /**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCTextFieldCharacterCounter = function(_super) {
            __extends(MDCTextFieldCharacterCounter, _super);
            function MDCTextFieldCharacterCounter() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCTextFieldCharacterCounter.attachTo = function(root) {
                return new MDCTextFieldCharacterCounter(root);
            };
            Object.defineProperty(MDCTextFieldCharacterCounter.prototype, "foundationForTextField", {
                get: function() {
                    return this.foundation;
                },
                enumerable: true,
                configurable: true
            });
            MDCTextFieldCharacterCounter.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    setContent: function(content) {
                        _this.root.textContent = content;
                    }
                };
                return new MDCTextFieldCharacterCounterFoundation(adapter);
            };
            return MDCTextFieldCharacterCounter;
        }(MDCComponent);
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var textfield_constants_strings = {
            ARIA_CONTROLS: "aria-controls",
            ARIA_DESCRIBEDBY: "aria-describedby",
            INPUT_SELECTOR: ".mdc-text-field__input",
            LABEL_SELECTOR: ".mdc-floating-label",
            LEADING_ICON_SELECTOR: ".mdc-text-field__icon--leading",
            LINE_RIPPLE_SELECTOR: ".mdc-line-ripple",
            OUTLINE_SELECTOR: ".mdc-notched-outline",
            PREFIX_SELECTOR: ".mdc-text-field__affix--prefix",
            SUFFIX_SELECTOR: ".mdc-text-field__affix--suffix",
            TRAILING_ICON_SELECTOR: ".mdc-text-field__icon--trailing"
        };
        var textfield_constants_cssClasses = {
            DISABLED: "mdc-text-field--disabled",
            FOCUSED: "mdc-text-field--focused",
            HELPER_LINE: "mdc-text-field-helper-line",
            INVALID: "mdc-text-field--invalid",
            LABEL_FLOATING: "mdc-text-field--label-floating",
            NO_LABEL: "mdc-text-field--no-label",
            OUTLINED: "mdc-text-field--outlined",
            ROOT: "mdc-text-field",
            TEXTAREA: "mdc-text-field--textarea",
            WITH_LEADING_ICON: "mdc-text-field--with-leading-icon",
            WITH_TRAILING_ICON: "mdc-text-field--with-trailing-icon"
        };
        var textfield_constants_numbers = {
            LABEL_SCALE: .75
        };
        var VALIDATION_ATTR_WHITELIST = [ "pattern", "min", "max", "required", "step", "minlength", "maxlength" ];
        var ALWAYS_FLOAT_TYPES = [ "color", "date", "datetime-local", "month", "range", "time", "week" ];
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var POINTERDOWN_EVENTS = [ "mousedown", "touchstart" ];
        var INTERACTION_EVENTS = [ "click", "keydown" ];
        var MDCTextFieldFoundation = function(_super) {
            __extends(MDCTextFieldFoundation, _super);
            function MDCTextFieldFoundation(adapter, foundationMap) {
                if (foundationMap === void 0) {
                    foundationMap = {};
                }
                var _this = _super.call(this, __assign(__assign({}, MDCTextFieldFoundation.defaultAdapter), adapter)) || this;
                _this.isFocused_ = false;
                _this.receivedUserInput_ = false;
                _this.isValid_ = true;
                _this.useNativeValidation_ = true;
                _this.validateOnValueChange_ = true;
                _this.helperText_ = foundationMap.helperText;
                _this.characterCounter_ = foundationMap.characterCounter;
                _this.leadingIcon_ = foundationMap.leadingIcon;
                _this.trailingIcon_ = foundationMap.trailingIcon;
                _this.inputFocusHandler_ = function() {
                    return _this.activateFocus();
                };
                _this.inputBlurHandler_ = function() {
                    return _this.deactivateFocus();
                };
                _this.inputInputHandler_ = function() {
                    return _this.handleInput();
                };
                _this.setPointerXOffset_ = function(evt) {
                    return _this.setTransformOrigin(evt);
                };
                _this.textFieldInteractionHandler_ = function() {
                    return _this.handleTextFieldInteraction();
                };
                _this.validationAttributeChangeHandler_ = function(attributesList) {
                    return _this.handleValidationAttributeChange(attributesList);
                };
                return _this;
            }
            Object.defineProperty(MDCTextFieldFoundation, "cssClasses", {
                get: function() {
                    return textfield_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextFieldFoundation, "strings", {
                get: function() {
                    return textfield_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextFieldFoundation, "numbers", {
                get: function() {
                    return textfield_constants_numbers;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextFieldFoundation.prototype, "shouldAlwaysFloat_", {
                get: function() {
                    var type = this.getNativeInput_().type;
                    return ALWAYS_FLOAT_TYPES.indexOf(type) >= 0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextFieldFoundation.prototype, "shouldFloat", {
                get: function() {
                    return this.shouldAlwaysFloat_ || this.isFocused_ || !!this.getValue() || this.isBadInput_();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextFieldFoundation.prototype, "shouldShake", {
                get: function() {
                    return !this.isFocused_ && !this.isValid() && !!this.getValue();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextFieldFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClass: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        hasClass: function() {
                            return true;
                        },
                        setInputAttr: function() {
                            return undefined;
                        },
                        removeInputAttr: function() {
                            return undefined;
                        },
                        registerTextFieldInteractionHandler: function() {
                            return undefined;
                        },
                        deregisterTextFieldInteractionHandler: function() {
                            return undefined;
                        },
                        registerInputInteractionHandler: function() {
                            return undefined;
                        },
                        deregisterInputInteractionHandler: function() {
                            return undefined;
                        },
                        registerValidationAttributeChangeHandler: function() {
                            return new MutationObserver((function() {
                                return undefined;
                            }));
                        },
                        deregisterValidationAttributeChangeHandler: function() {
                            return undefined;
                        },
                        getNativeInput: function() {
                            return null;
                        },
                        isFocused: function() {
                            return false;
                        },
                        activateLineRipple: function() {
                            return undefined;
                        },
                        deactivateLineRipple: function() {
                            return undefined;
                        },
                        setLineRippleTransformOrigin: function() {
                            return undefined;
                        },
                        shakeLabel: function() {
                            return undefined;
                        },
                        floatLabel: function() {
                            return undefined;
                        },
                        setLabelRequired: function() {
                            return undefined;
                        },
                        hasLabel: function() {
                            return false;
                        },
                        getLabelWidth: function() {
                            return 0;
                        },
                        hasOutline: function() {
                            return false;
                        },
                        notchOutline: function() {
                            return undefined;
                        },
                        closeOutline: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCTextFieldFoundation.prototype.init = function() {
                var _this = this;
                if (this.adapter.hasLabel() && this.getNativeInput_().required) {
                    this.adapter.setLabelRequired(true);
                }
                if (this.adapter.isFocused()) {
                    this.inputFocusHandler_();
                } else if (this.adapter.hasLabel() && this.shouldFloat) {
                    this.notchOutline(true);
                    this.adapter.floatLabel(true);
                    this.styleFloating_(true);
                }
                this.adapter.registerInputInteractionHandler("focus", this.inputFocusHandler_);
                this.adapter.registerInputInteractionHandler("blur", this.inputBlurHandler_);
                this.adapter.registerInputInteractionHandler("input", this.inputInputHandler_);
                POINTERDOWN_EVENTS.forEach((function(evtType) {
                    _this.adapter.registerInputInteractionHandler(evtType, _this.setPointerXOffset_);
                }));
                INTERACTION_EVENTS.forEach((function(evtType) {
                    _this.adapter.registerTextFieldInteractionHandler(evtType, _this.textFieldInteractionHandler_);
                }));
                this.validationObserver_ = this.adapter.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler_);
                this.setCharacterCounter_(this.getValue().length);
            };
            MDCTextFieldFoundation.prototype.destroy = function() {
                var _this = this;
                this.adapter.deregisterInputInteractionHandler("focus", this.inputFocusHandler_);
                this.adapter.deregisterInputInteractionHandler("blur", this.inputBlurHandler_);
                this.adapter.deregisterInputInteractionHandler("input", this.inputInputHandler_);
                POINTERDOWN_EVENTS.forEach((function(evtType) {
                    _this.adapter.deregisterInputInteractionHandler(evtType, _this.setPointerXOffset_);
                }));
                INTERACTION_EVENTS.forEach((function(evtType) {
                    _this.adapter.deregisterTextFieldInteractionHandler(evtType, _this.textFieldInteractionHandler_);
                }));
                this.adapter.deregisterValidationAttributeChangeHandler(this.validationObserver_);
            };
            MDCTextFieldFoundation.prototype.handleTextFieldInteraction = function() {
                var nativeInput = this.adapter.getNativeInput();
                if (nativeInput && nativeInput.disabled) {
                    return;
                }
                this.receivedUserInput_ = true;
            };
            MDCTextFieldFoundation.prototype.handleValidationAttributeChange = function(attributesList) {
                var _this = this;
                attributesList.some((function(attributeName) {
                    if (VALIDATION_ATTR_WHITELIST.indexOf(attributeName) > -1) {
                        _this.styleValidity_(true);
                        _this.adapter.setLabelRequired(_this.getNativeInput_().required);
                        return true;
                    }
                    return false;
                }));
                if (attributesList.indexOf("maxlength") > -1) {
                    this.setCharacterCounter_(this.getValue().length);
                }
            };
            MDCTextFieldFoundation.prototype.notchOutline = function(openNotch) {
                if (!this.adapter.hasOutline() || !this.adapter.hasLabel()) {
                    return;
                }
                if (openNotch) {
                    var labelWidth = this.adapter.getLabelWidth() * textfield_constants_numbers.LABEL_SCALE;
                    this.adapter.notchOutline(labelWidth);
                } else {
                    this.adapter.closeOutline();
                }
            };
            MDCTextFieldFoundation.prototype.activateFocus = function() {
                this.isFocused_ = true;
                this.styleFocused_(this.isFocused_);
                this.adapter.activateLineRipple();
                if (this.adapter.hasLabel()) {
                    this.notchOutline(this.shouldFloat);
                    this.adapter.floatLabel(this.shouldFloat);
                    this.styleFloating_(this.shouldFloat);
                    this.adapter.shakeLabel(this.shouldShake);
                }
                if (this.helperText_ && (this.helperText_.isPersistent() || !this.helperText_.isValidation() || !this.isValid_)) {
                    this.helperText_.showToScreenReader();
                }
            };
            MDCTextFieldFoundation.prototype.setTransformOrigin = function(evt) {
                if (this.isDisabled() || this.adapter.hasOutline()) {
                    return;
                }
                var touches = evt.touches;
                var targetEvent = touches ? touches[0] : evt;
                var targetClientRect = targetEvent.target.getBoundingClientRect();
                var normalizedX = targetEvent.clientX - targetClientRect.left;
                this.adapter.setLineRippleTransformOrigin(normalizedX);
            };
            MDCTextFieldFoundation.prototype.handleInput = function() {
                this.autoCompleteFocus();
                this.setCharacterCounter_(this.getValue().length);
            };
            MDCTextFieldFoundation.prototype.autoCompleteFocus = function() {
                if (!this.receivedUserInput_) {
                    this.activateFocus();
                }
            };
            MDCTextFieldFoundation.prototype.deactivateFocus = function() {
                this.isFocused_ = false;
                this.adapter.deactivateLineRipple();
                var isValid = this.isValid();
                this.styleValidity_(isValid);
                this.styleFocused_(this.isFocused_);
                if (this.adapter.hasLabel()) {
                    this.notchOutline(this.shouldFloat);
                    this.adapter.floatLabel(this.shouldFloat);
                    this.styleFloating_(this.shouldFloat);
                    this.adapter.shakeLabel(this.shouldShake);
                }
                if (!this.shouldFloat) {
                    this.receivedUserInput_ = false;
                }
            };
            MDCTextFieldFoundation.prototype.getValue = function() {
                return this.getNativeInput_().value;
            };
            MDCTextFieldFoundation.prototype.setValue = function(value) {
                if (this.getValue() !== value) {
                    this.getNativeInput_().value = value;
                }
                this.setCharacterCounter_(value.length);
                if (this.validateOnValueChange_) {
                    var isValid = this.isValid();
                    this.styleValidity_(isValid);
                }
                if (this.adapter.hasLabel()) {
                    this.notchOutline(this.shouldFloat);
                    this.adapter.floatLabel(this.shouldFloat);
                    this.styleFloating_(this.shouldFloat);
                    if (this.validateOnValueChange_) {
                        this.adapter.shakeLabel(this.shouldShake);
                    }
                }
            };
            MDCTextFieldFoundation.prototype.isValid = function() {
                return this.useNativeValidation_ ? this.isNativeInputValid_() : this.isValid_;
            };
            MDCTextFieldFoundation.prototype.setValid = function(isValid) {
                this.isValid_ = isValid;
                this.styleValidity_(isValid);
                var shouldShake = !isValid && !this.isFocused_ && !!this.getValue();
                if (this.adapter.hasLabel()) {
                    this.adapter.shakeLabel(shouldShake);
                }
            };
            MDCTextFieldFoundation.prototype.setValidateOnValueChange = function(shouldValidate) {
                this.validateOnValueChange_ = shouldValidate;
            };
            MDCTextFieldFoundation.prototype.getValidateOnValueChange = function() {
                return this.validateOnValueChange_;
            };
            MDCTextFieldFoundation.prototype.setUseNativeValidation = function(useNativeValidation) {
                this.useNativeValidation_ = useNativeValidation;
            };
            MDCTextFieldFoundation.prototype.isDisabled = function() {
                return this.getNativeInput_().disabled;
            };
            MDCTextFieldFoundation.prototype.setDisabled = function(disabled) {
                this.getNativeInput_().disabled = disabled;
                this.styleDisabled_(disabled);
            };
            MDCTextFieldFoundation.prototype.setHelperTextContent = function(content) {
                if (this.helperText_) {
                    this.helperText_.setContent(content);
                }
            };
            MDCTextFieldFoundation.prototype.setLeadingIconAriaLabel = function(label) {
                if (this.leadingIcon_) {
                    this.leadingIcon_.setAriaLabel(label);
                }
            };
            MDCTextFieldFoundation.prototype.setLeadingIconContent = function(content) {
                if (this.leadingIcon_) {
                    this.leadingIcon_.setContent(content);
                }
            };
            MDCTextFieldFoundation.prototype.setTrailingIconAriaLabel = function(label) {
                if (this.trailingIcon_) {
                    this.trailingIcon_.setAriaLabel(label);
                }
            };
            MDCTextFieldFoundation.prototype.setTrailingIconContent = function(content) {
                if (this.trailingIcon_) {
                    this.trailingIcon_.setContent(content);
                }
            };
            MDCTextFieldFoundation.prototype.setCharacterCounter_ = function(currentLength) {
                if (!this.characterCounter_) {
                    return;
                }
                var maxLength = this.getNativeInput_().maxLength;
                if (maxLength === -1) {
                    throw new Error("MDCTextFieldFoundation: Expected maxlength html property on text input or textarea.");
                }
                this.characterCounter_.setCounterValue(currentLength, maxLength);
            };
            MDCTextFieldFoundation.prototype.isBadInput_ = function() {
                return this.getNativeInput_().validity.badInput || false;
            };
            MDCTextFieldFoundation.prototype.isNativeInputValid_ = function() {
                return this.getNativeInput_().validity.valid;
            };
            MDCTextFieldFoundation.prototype.styleValidity_ = function(isValid) {
                var INVALID = MDCTextFieldFoundation.cssClasses.INVALID;
                if (isValid) {
                    this.adapter.removeClass(INVALID);
                } else {
                    this.adapter.addClass(INVALID);
                }
                if (this.helperText_) {
                    this.helperText_.setValidity(isValid);
                    var helperTextValidation = this.helperText_.isValidation();
                    if (!helperTextValidation) {
                        return;
                    }
                    var helperTextVisible = this.helperText_.isVisible();
                    var helperTextId = this.helperText_.getId();
                    if (helperTextVisible && helperTextId) {
                        this.adapter.setInputAttr(textfield_constants_strings.ARIA_DESCRIBEDBY, helperTextId);
                    } else {
                        this.adapter.removeInputAttr(textfield_constants_strings.ARIA_DESCRIBEDBY);
                    }
                }
            };
            MDCTextFieldFoundation.prototype.styleFocused_ = function(isFocused) {
                var FOCUSED = MDCTextFieldFoundation.cssClasses.FOCUSED;
                if (isFocused) {
                    this.adapter.addClass(FOCUSED);
                } else {
                    this.adapter.removeClass(FOCUSED);
                }
            };
            MDCTextFieldFoundation.prototype.styleDisabled_ = function(isDisabled) {
                var _a = MDCTextFieldFoundation.cssClasses, DISABLED = _a.DISABLED, INVALID = _a.INVALID;
                if (isDisabled) {
                    this.adapter.addClass(DISABLED);
                    this.adapter.removeClass(INVALID);
                } else {
                    this.adapter.removeClass(DISABLED);
                }
                if (this.leadingIcon_) {
                    this.leadingIcon_.setDisabled(isDisabled);
                }
                if (this.trailingIcon_) {
                    this.trailingIcon_.setDisabled(isDisabled);
                }
            };
            MDCTextFieldFoundation.prototype.styleFloating_ = function(isFloating) {
                var LABEL_FLOATING = MDCTextFieldFoundation.cssClasses.LABEL_FLOATING;
                if (isFloating) {
                    this.adapter.addClass(LABEL_FLOATING);
                } else {
                    this.adapter.removeClass(LABEL_FLOATING);
                }
            };
            MDCTextFieldFoundation.prototype.getNativeInput_ = function() {
                var nativeInput = this.adapter ? this.adapter.getNativeInput() : null;
                return nativeInput || {
                    disabled: false,
                    maxLength: -1,
                    required: false,
                    type: "input",
                    validity: {
                        badInput: false,
                        valid: true
                    },
                    value: ""
                };
            };
            return MDCTextFieldFoundation;
        }(MDCFoundation);
        const textfield_foundation = null && MDCTextFieldFoundation;
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var helper_text_constants_cssClasses = {
            HELPER_TEXT_PERSISTENT: "mdc-text-field-helper-text--persistent",
            HELPER_TEXT_VALIDATION_MSG: "mdc-text-field-helper-text--validation-msg",
            ROOT: "mdc-text-field-helper-text"
        };
        var helper_text_constants_strings = {
            ARIA_HIDDEN: "aria-hidden",
            ROLE: "role",
            ROOT_SELECTOR: "." + helper_text_constants_cssClasses.ROOT
        };
        /**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCTextFieldHelperTextFoundation = function(_super) {
            __extends(MDCTextFieldHelperTextFoundation, _super);
            function MDCTextFieldHelperTextFoundation(adapter) {
                return _super.call(this, __assign(__assign({}, MDCTextFieldHelperTextFoundation.defaultAdapter), adapter)) || this;
            }
            Object.defineProperty(MDCTextFieldHelperTextFoundation, "cssClasses", {
                get: function() {
                    return helper_text_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextFieldHelperTextFoundation, "strings", {
                get: function() {
                    return helper_text_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextFieldHelperTextFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClass: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        hasClass: function() {
                            return false;
                        },
                        getAttr: function() {
                            return null;
                        },
                        setAttr: function() {
                            return undefined;
                        },
                        removeAttr: function() {
                            return undefined;
                        },
                        setContent: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCTextFieldHelperTextFoundation.prototype.getId = function() {
                return this.adapter.getAttr("id");
            };
            MDCTextFieldHelperTextFoundation.prototype.isVisible = function() {
                return this.adapter.getAttr(helper_text_constants_strings.ARIA_HIDDEN) !== "true";
            };
            MDCTextFieldHelperTextFoundation.prototype.setContent = function(content) {
                this.adapter.setContent(content);
            };
            MDCTextFieldHelperTextFoundation.prototype.isPersistent = function() {
                return this.adapter.hasClass(helper_text_constants_cssClasses.HELPER_TEXT_PERSISTENT);
            };
            MDCTextFieldHelperTextFoundation.prototype.setPersistent = function(isPersistent) {
                if (isPersistent) {
                    this.adapter.addClass(helper_text_constants_cssClasses.HELPER_TEXT_PERSISTENT);
                } else {
                    this.adapter.removeClass(helper_text_constants_cssClasses.HELPER_TEXT_PERSISTENT);
                }
            };
            MDCTextFieldHelperTextFoundation.prototype.isValidation = function() {
                return this.adapter.hasClass(helper_text_constants_cssClasses.HELPER_TEXT_VALIDATION_MSG);
            };
            MDCTextFieldHelperTextFoundation.prototype.setValidation = function(isValidation) {
                if (isValidation) {
                    this.adapter.addClass(helper_text_constants_cssClasses.HELPER_TEXT_VALIDATION_MSG);
                } else {
                    this.adapter.removeClass(helper_text_constants_cssClasses.HELPER_TEXT_VALIDATION_MSG);
                }
            };
            MDCTextFieldHelperTextFoundation.prototype.showToScreenReader = function() {
                this.adapter.removeAttr(helper_text_constants_strings.ARIA_HIDDEN);
            };
            MDCTextFieldHelperTextFoundation.prototype.setValidity = function(inputIsValid) {
                var helperTextIsPersistent = this.adapter.hasClass(helper_text_constants_cssClasses.HELPER_TEXT_PERSISTENT);
                var helperTextIsValidationMsg = this.adapter.hasClass(helper_text_constants_cssClasses.HELPER_TEXT_VALIDATION_MSG);
                var validationMsgNeedsDisplay = helperTextIsValidationMsg && !inputIsValid;
                if (validationMsgNeedsDisplay) {
                    this.showToScreenReader();
                    this.adapter.setAttr(helper_text_constants_strings.ROLE, "alert");
                } else {
                    this.adapter.removeAttr(helper_text_constants_strings.ROLE);
                }
                if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
                    this.hide_();
                }
            };
            MDCTextFieldHelperTextFoundation.prototype.hide_ = function() {
                this.adapter.setAttr(helper_text_constants_strings.ARIA_HIDDEN, "true");
            };
            return MDCTextFieldHelperTextFoundation;
        }(MDCFoundation);
        const helper_text_foundation = null && MDCTextFieldHelperTextFoundation;
        /**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCTextFieldHelperText = function(_super) {
            __extends(MDCTextFieldHelperText, _super);
            function MDCTextFieldHelperText() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCTextFieldHelperText.attachTo = function(root) {
                return new MDCTextFieldHelperText(root);
            };
            Object.defineProperty(MDCTextFieldHelperText.prototype, "foundationForTextField", {
                get: function() {
                    return this.foundation;
                },
                enumerable: true,
                configurable: true
            });
            MDCTextFieldHelperText.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    addClass: function(className) {
                        return _this.root.classList.add(className);
                    },
                    removeClass: function(className) {
                        return _this.root.classList.remove(className);
                    },
                    hasClass: function(className) {
                        return _this.root.classList.contains(className);
                    },
                    getAttr: function(attr) {
                        return _this.root.getAttribute(attr);
                    },
                    setAttr: function(attr, value) {
                        return _this.root.setAttribute(attr, value);
                    },
                    removeAttr: function(attr) {
                        return _this.root.removeAttribute(attr);
                    },
                    setContent: function(content) {
                        _this.root.textContent = content;
                    }
                };
                return new MDCTextFieldHelperTextFoundation(adapter);
            };
            return MDCTextFieldHelperText;
        }(MDCComponent);
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var icon_constants_strings = {
            ICON_EVENT: "MDCTextField:icon",
            ICON_ROLE: "button"
        };
        var icon_constants_cssClasses = {
            ROOT: "mdc-text-field__icon"
        };
        /**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var foundation_INTERACTION_EVENTS = [ "click", "keydown" ];
        var MDCTextFieldIconFoundation = function(_super) {
            __extends(MDCTextFieldIconFoundation, _super);
            function MDCTextFieldIconFoundation(adapter) {
                var _this = _super.call(this, __assign(__assign({}, MDCTextFieldIconFoundation.defaultAdapter), adapter)) || this;
                _this.savedTabIndex_ = null;
                _this.interactionHandler_ = function(evt) {
                    return _this.handleInteraction(evt);
                };
                return _this;
            }
            Object.defineProperty(MDCTextFieldIconFoundation, "strings", {
                get: function() {
                    return icon_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextFieldIconFoundation, "cssClasses", {
                get: function() {
                    return icon_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextFieldIconFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        getAttr: function() {
                            return null;
                        },
                        setAttr: function() {
                            return undefined;
                        },
                        removeAttr: function() {
                            return undefined;
                        },
                        setContent: function() {
                            return undefined;
                        },
                        registerInteractionHandler: function() {
                            return undefined;
                        },
                        deregisterInteractionHandler: function() {
                            return undefined;
                        },
                        notifyIconAction: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCTextFieldIconFoundation.prototype.init = function() {
                var _this = this;
                this.savedTabIndex_ = this.adapter.getAttr("tabindex");
                foundation_INTERACTION_EVENTS.forEach((function(evtType) {
                    _this.adapter.registerInteractionHandler(evtType, _this.interactionHandler_);
                }));
            };
            MDCTextFieldIconFoundation.prototype.destroy = function() {
                var _this = this;
                foundation_INTERACTION_EVENTS.forEach((function(evtType) {
                    _this.adapter.deregisterInteractionHandler(evtType, _this.interactionHandler_);
                }));
            };
            MDCTextFieldIconFoundation.prototype.setDisabled = function(disabled) {
                if (!this.savedTabIndex_) {
                    return;
                }
                if (disabled) {
                    this.adapter.setAttr("tabindex", "-1");
                    this.adapter.removeAttr("role");
                } else {
                    this.adapter.setAttr("tabindex", this.savedTabIndex_);
                    this.adapter.setAttr("role", icon_constants_strings.ICON_ROLE);
                }
            };
            MDCTextFieldIconFoundation.prototype.setAriaLabel = function(label) {
                this.adapter.setAttr("aria-label", label);
            };
            MDCTextFieldIconFoundation.prototype.setContent = function(content) {
                this.adapter.setContent(content);
            };
            MDCTextFieldIconFoundation.prototype.handleInteraction = function(evt) {
                var isEnterKey = evt.key === "Enter" || evt.keyCode === 13;
                if (evt.type === "click" || isEnterKey) {
                    evt.preventDefault();
                    this.adapter.notifyIconAction();
                }
            };
            return MDCTextFieldIconFoundation;
        }(MDCFoundation);
        const icon_foundation = null && MDCTextFieldIconFoundation;
        /**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCTextFieldIcon = function(_super) {
            __extends(MDCTextFieldIcon, _super);
            function MDCTextFieldIcon() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCTextFieldIcon.attachTo = function(root) {
                return new MDCTextFieldIcon(root);
            };
            Object.defineProperty(MDCTextFieldIcon.prototype, "foundationForTextField", {
                get: function() {
                    return this.foundation;
                },
                enumerable: true,
                configurable: true
            });
            MDCTextFieldIcon.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    getAttr: function(attr) {
                        return _this.root.getAttribute(attr);
                    },
                    setAttr: function(attr, value) {
                        return _this.root.setAttribute(attr, value);
                    },
                    removeAttr: function(attr) {
                        return _this.root.removeAttribute(attr);
                    },
                    setContent: function(content) {
                        _this.root.textContent = content;
                    },
                    registerInteractionHandler: function(evtType, handler) {
                        return _this.listen(evtType, handler);
                    },
                    deregisterInteractionHandler: function(evtType, handler) {
                        return _this.unlisten(evtType, handler);
                    },
                    notifyIconAction: function() {
                        return _this.emit(MDCTextFieldIconFoundation.strings.ICON_EVENT, {}, true);
                    }
                };
                return new MDCTextFieldIconFoundation(adapter);
            };
            return MDCTextFieldIcon;
        }(MDCComponent);
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCTextField = function(_super) {
            __extends(MDCTextField, _super);
            function MDCTextField() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCTextField.attachTo = function(root) {
                return new MDCTextField(root);
            };
            MDCTextField.prototype.initialize = function(rippleFactory, lineRippleFactory, helperTextFactory, characterCounterFactory, iconFactory, labelFactory, outlineFactory) {
                if (rippleFactory === void 0) {
                    rippleFactory = function(el, foundation) {
                        return new MDCRipple(el, foundation);
                    };
                }
                if (lineRippleFactory === void 0) {
                    lineRippleFactory = function(el) {
                        return new MDCLineRipple(el);
                    };
                }
                if (helperTextFactory === void 0) {
                    helperTextFactory = function(el) {
                        return new MDCTextFieldHelperText(el);
                    };
                }
                if (characterCounterFactory === void 0) {
                    characterCounterFactory = function(el) {
                        return new MDCTextFieldCharacterCounter(el);
                    };
                }
                if (iconFactory === void 0) {
                    iconFactory = function(el) {
                        return new MDCTextFieldIcon(el);
                    };
                }
                if (labelFactory === void 0) {
                    labelFactory = function(el) {
                        return new MDCFloatingLabel(el);
                    };
                }
                if (outlineFactory === void 0) {
                    outlineFactory = function(el) {
                        return new MDCNotchedOutline(el);
                    };
                }
                this.input_ = this.root.querySelector(textfield_constants_strings.INPUT_SELECTOR);
                var labelElement = this.root.querySelector(textfield_constants_strings.LABEL_SELECTOR);
                this.label_ = labelElement ? labelFactory(labelElement) : null;
                var lineRippleElement = this.root.querySelector(textfield_constants_strings.LINE_RIPPLE_SELECTOR);
                this.lineRipple_ = lineRippleElement ? lineRippleFactory(lineRippleElement) : null;
                var outlineElement = this.root.querySelector(textfield_constants_strings.OUTLINE_SELECTOR);
                this.outline_ = outlineElement ? outlineFactory(outlineElement) : null;
                var helperTextStrings = MDCTextFieldHelperTextFoundation.strings;
                var nextElementSibling = this.root.nextElementSibling;
                var hasHelperLine = nextElementSibling && nextElementSibling.classList.contains(textfield_constants_cssClasses.HELPER_LINE);
                var helperTextEl = hasHelperLine && nextElementSibling && nextElementSibling.querySelector(helperTextStrings.ROOT_SELECTOR);
                this.helperText_ = helperTextEl ? helperTextFactory(helperTextEl) : null;
                var characterCounterStrings = MDCTextFieldCharacterCounterFoundation.strings;
                var characterCounterEl = this.root.querySelector(characterCounterStrings.ROOT_SELECTOR);
                if (!characterCounterEl && hasHelperLine && nextElementSibling) {
                    characterCounterEl = nextElementSibling.querySelector(characterCounterStrings.ROOT_SELECTOR);
                }
                this.characterCounter_ = characterCounterEl ? characterCounterFactory(characterCounterEl) : null;
                var leadingIconEl = this.root.querySelector(textfield_constants_strings.LEADING_ICON_SELECTOR);
                this.leadingIcon_ = leadingIconEl ? iconFactory(leadingIconEl) : null;
                var trailingIconEl = this.root.querySelector(textfield_constants_strings.TRAILING_ICON_SELECTOR);
                this.trailingIcon_ = trailingIconEl ? iconFactory(trailingIconEl) : null;
                this.prefix_ = this.root.querySelector(textfield_constants_strings.PREFIX_SELECTOR);
                this.suffix_ = this.root.querySelector(textfield_constants_strings.SUFFIX_SELECTOR);
                this.ripple = this.createRipple_(rippleFactory);
            };
            MDCTextField.prototype.destroy = function() {
                if (this.ripple) {
                    this.ripple.destroy();
                }
                if (this.lineRipple_) {
                    this.lineRipple_.destroy();
                }
                if (this.helperText_) {
                    this.helperText_.destroy();
                }
                if (this.characterCounter_) {
                    this.characterCounter_.destroy();
                }
                if (this.leadingIcon_) {
                    this.leadingIcon_.destroy();
                }
                if (this.trailingIcon_) {
                    this.trailingIcon_.destroy();
                }
                if (this.label_) {
                    this.label_.destroy();
                }
                if (this.outline_) {
                    this.outline_.destroy();
                }
                _super.prototype.destroy.call(this);
            };
            MDCTextField.prototype.initialSyncWithDOM = function() {
                this.disabled = this.input_.disabled;
            };
            Object.defineProperty(MDCTextField.prototype, "value", {
                get: function() {
                    return this.foundation.getValue();
                },
                set: function(value) {
                    this.foundation.setValue(value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextField.prototype, "disabled", {
                get: function() {
                    return this.foundation.isDisabled();
                },
                set: function(disabled) {
                    this.foundation.setDisabled(disabled);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextField.prototype, "valid", {
                get: function() {
                    return this.foundation.isValid();
                },
                set: function(valid) {
                    this.foundation.setValid(valid);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextField.prototype, "required", {
                get: function() {
                    return this.input_.required;
                },
                set: function(required) {
                    this.input_.required = required;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextField.prototype, "pattern", {
                get: function() {
                    return this.input_.pattern;
                },
                set: function(pattern) {
                    this.input_.pattern = pattern;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextField.prototype, "minLength", {
                get: function() {
                    return this.input_.minLength;
                },
                set: function(minLength) {
                    this.input_.minLength = minLength;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextField.prototype, "maxLength", {
                get: function() {
                    return this.input_.maxLength;
                },
                set: function(maxLength) {
                    if (maxLength < 0) {
                        this.input_.removeAttribute("maxLength");
                    } else {
                        this.input_.maxLength = maxLength;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextField.prototype, "min", {
                get: function() {
                    return this.input_.min;
                },
                set: function(min) {
                    this.input_.min = min;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextField.prototype, "max", {
                get: function() {
                    return this.input_.max;
                },
                set: function(max) {
                    this.input_.max = max;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextField.prototype, "step", {
                get: function() {
                    return this.input_.step;
                },
                set: function(step) {
                    this.input_.step = step;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextField.prototype, "helperTextContent", {
                set: function(content) {
                    this.foundation.setHelperTextContent(content);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextField.prototype, "leadingIconAriaLabel", {
                set: function(label) {
                    this.foundation.setLeadingIconAriaLabel(label);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextField.prototype, "leadingIconContent", {
                set: function(content) {
                    this.foundation.setLeadingIconContent(content);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextField.prototype, "trailingIconAriaLabel", {
                set: function(label) {
                    this.foundation.setTrailingIconAriaLabel(label);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextField.prototype, "trailingIconContent", {
                set: function(content) {
                    this.foundation.setTrailingIconContent(content);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextField.prototype, "useNativeValidation", {
                set: function(useNativeValidation) {
                    this.foundation.setUseNativeValidation(useNativeValidation);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextField.prototype, "prefixText", {
                get: function() {
                    return this.prefix_ ? this.prefix_.textContent : null;
                },
                set: function(prefixText) {
                    if (this.prefix_) {
                        this.prefix_.textContent = prefixText;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTextField.prototype, "suffixText", {
                get: function() {
                    return this.suffix_ ? this.suffix_.textContent : null;
                },
                set: function(suffixText) {
                    if (this.suffix_) {
                        this.suffix_.textContent = suffixText;
                    }
                },
                enumerable: true,
                configurable: true
            });
            MDCTextField.prototype.focus = function() {
                this.input_.focus();
            };
            MDCTextField.prototype.layout = function() {
                var openNotch = this.foundation.shouldFloat;
                this.foundation.notchOutline(openNotch);
            };
            MDCTextField.prototype.getDefaultFoundation = function() {
                var adapter = __assign(__assign(__assign(__assign(__assign({}, this.getRootAdapterMethods_()), this.getInputAdapterMethods_()), this.getLabelAdapterMethods_()), this.getLineRippleAdapterMethods_()), this.getOutlineAdapterMethods_());
                return new MDCTextFieldFoundation(adapter, this.getFoundationMap_());
            };
            MDCTextField.prototype.getRootAdapterMethods_ = function() {
                var _this = this;
                return {
                    addClass: function(className) {
                        return _this.root.classList.add(className);
                    },
                    removeClass: function(className) {
                        return _this.root.classList.remove(className);
                    },
                    hasClass: function(className) {
                        return _this.root.classList.contains(className);
                    },
                    registerTextFieldInteractionHandler: function(evtType, handler) {
                        _this.listen(evtType, handler);
                    },
                    deregisterTextFieldInteractionHandler: function(evtType, handler) {
                        _this.unlisten(evtType, handler);
                    },
                    registerValidationAttributeChangeHandler: function(handler) {
                        var getAttributesList = function(mutationsList) {
                            return mutationsList.map((function(mutation) {
                                return mutation.attributeName;
                            })).filter((function(attributeName) {
                                return attributeName;
                            }));
                        };
                        var observer = new MutationObserver((function(mutationsList) {
                            return handler(getAttributesList(mutationsList));
                        }));
                        var config = {
                            attributes: true
                        };
                        observer.observe(_this.input_, config);
                        return observer;
                    },
                    deregisterValidationAttributeChangeHandler: function(observer) {
                        observer.disconnect();
                    }
                };
            };
            MDCTextField.prototype.getInputAdapterMethods_ = function() {
                var _this = this;
                return {
                    getNativeInput: function() {
                        return _this.input_;
                    },
                    setInputAttr: function(attr, value) {
                        _this.input_.setAttribute(attr, value);
                    },
                    removeInputAttr: function(attr) {
                        _this.input_.removeAttribute(attr);
                    },
                    isFocused: function() {
                        return document.activeElement === _this.input_;
                    },
                    registerInputInteractionHandler: function(evtType, handler) {
                        _this.input_.addEventListener(evtType, handler, applyPassive());
                    },
                    deregisterInputInteractionHandler: function(evtType, handler) {
                        _this.input_.removeEventListener(evtType, handler, applyPassive());
                    }
                };
            };
            MDCTextField.prototype.getLabelAdapterMethods_ = function() {
                var _this = this;
                return {
                    floatLabel: function(shouldFloat) {
                        return _this.label_ && _this.label_.float(shouldFloat);
                    },
                    getLabelWidth: function() {
                        return _this.label_ ? _this.label_.getWidth() : 0;
                    },
                    hasLabel: function() {
                        return Boolean(_this.label_);
                    },
                    shakeLabel: function(shouldShake) {
                        return _this.label_ && _this.label_.shake(shouldShake);
                    },
                    setLabelRequired: function(isRequired) {
                        return _this.label_ && _this.label_.setRequired(isRequired);
                    }
                };
            };
            MDCTextField.prototype.getLineRippleAdapterMethods_ = function() {
                var _this = this;
                return {
                    activateLineRipple: function() {
                        if (_this.lineRipple_) {
                            _this.lineRipple_.activate();
                        }
                    },
                    deactivateLineRipple: function() {
                        if (_this.lineRipple_) {
                            _this.lineRipple_.deactivate();
                        }
                    },
                    setLineRippleTransformOrigin: function(normalizedX) {
                        if (_this.lineRipple_) {
                            _this.lineRipple_.setRippleCenter(normalizedX);
                        }
                    }
                };
            };
            MDCTextField.prototype.getOutlineAdapterMethods_ = function() {
                var _this = this;
                return {
                    closeOutline: function() {
                        return _this.outline_ && _this.outline_.closeNotch();
                    },
                    hasOutline: function() {
                        return Boolean(_this.outline_);
                    },
                    notchOutline: function(labelWidth) {
                        return _this.outline_ && _this.outline_.notch(labelWidth);
                    }
                };
            };
            MDCTextField.prototype.getFoundationMap_ = function() {
                return {
                    characterCounter: this.characterCounter_ ? this.characterCounter_.foundationForTextField : undefined,
                    helperText: this.helperText_ ? this.helperText_.foundationForTextField : undefined,
                    leadingIcon: this.leadingIcon_ ? this.leadingIcon_.foundationForTextField : undefined,
                    trailingIcon: this.trailingIcon_ ? this.trailingIcon_.foundationForTextField : undefined
                };
            };
            MDCTextField.prototype.createRipple_ = function(rippleFactory) {
                var _this = this;
                var isTextArea = this.root.classList.contains(textfield_constants_cssClasses.TEXTAREA);
                var isOutlined = this.root.classList.contains(textfield_constants_cssClasses.OUTLINED);
                if (isTextArea || isOutlined) {
                    return null;
                }
                var adapter = __assign(__assign({}, MDCRipple.createAdapter(this)), {
                    isSurfaceActive: function() {
                        return matches(_this.input_, ":active");
                    },
                    registerInteractionHandler: function(evtType, handler) {
                        return _this.input_.addEventListener(evtType, handler, applyPassive());
                    },
                    deregisterInteractionHandler: function(evtType, handler) {
                        return _this.input_.removeEventListener(evtType, handler, applyPassive());
                    }
                });
                return rippleFactory(this.root, new MDCRippleFoundation(adapter));
            };
            return MDCTextField;
        }(MDCComponent);
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var list_constants_cssClasses = {
            LIST_ITEM_ACTIVATED_CLASS: "mdc-list-item--activated",
            LIST_ITEM_CLASS: "mdc-list-item",
            LIST_ITEM_DISABLED_CLASS: "mdc-list-item--disabled",
            LIST_ITEM_SELECTED_CLASS: "mdc-list-item--selected",
            LIST_ITEM_TEXT_CLASS: "mdc-list-item__text",
            LIST_ITEM_PRIMARY_TEXT_CLASS: "mdc-list-item__primary-text",
            ROOT: "mdc-list"
        };
        var list_constants_strings = {
            ACTION_EVENT: "MDCList:action",
            ARIA_CHECKED: "aria-checked",
            ARIA_CHECKED_CHECKBOX_SELECTOR: '[role="checkbox"][aria-checked="true"]',
            ARIA_CHECKED_RADIO_SELECTOR: '[role="radio"][aria-checked="true"]',
            ARIA_CURRENT: "aria-current",
            ARIA_DISABLED: "aria-disabled",
            ARIA_ORIENTATION: "aria-orientation",
            ARIA_ORIENTATION_HORIZONTAL: "horizontal",
            ARIA_ROLE_CHECKBOX_SELECTOR: '[role="checkbox"]',
            ARIA_SELECTED: "aria-selected",
            CHECKBOX_RADIO_SELECTOR: 'input[type="checkbox"], input[type="radio"]',
            CHECKBOX_SELECTOR: 'input[type="checkbox"]',
            CHILD_ELEMENTS_TO_TOGGLE_TABINDEX: "\n    ." + list_constants_cssClasses.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + list_constants_cssClasses.LIST_ITEM_CLASS + " a\n  ",
            FOCUSABLE_CHILD_ELEMENTS: "\n    ." + list_constants_cssClasses.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + list_constants_cssClasses.LIST_ITEM_CLASS + " a,\n    ." + list_constants_cssClasses.LIST_ITEM_CLASS + ' input[type="radio"]:not(:disabled),\n    .' + list_constants_cssClasses.LIST_ITEM_CLASS + ' input[type="checkbox"]:not(:disabled)\n  ',
            RADIO_SELECTOR: 'input[type="radio"]'
        };
        var list_constants_numbers = {
            UNSET_INDEX: -1,
            TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS: 300
        };
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var KEY = {
            UNKNOWN: "Unknown",
            BACKSPACE: "Backspace",
            ENTER: "Enter",
            SPACEBAR: "Spacebar",
            PAGE_UP: "PageUp",
            PAGE_DOWN: "PageDown",
            END: "End",
            HOME: "Home",
            ARROW_LEFT: "ArrowLeft",
            ARROW_UP: "ArrowUp",
            ARROW_RIGHT: "ArrowRight",
            ARROW_DOWN: "ArrowDown",
            DELETE: "Delete",
            ESCAPE: "Escape"
        };
        var normalizedKeys = new Set;
        normalizedKeys.add(KEY.BACKSPACE);
        normalizedKeys.add(KEY.ENTER);
        normalizedKeys.add(KEY.SPACEBAR);
        normalizedKeys.add(KEY.PAGE_UP);
        normalizedKeys.add(KEY.PAGE_DOWN);
        normalizedKeys.add(KEY.END);
        normalizedKeys.add(KEY.HOME);
        normalizedKeys.add(KEY.ARROW_LEFT);
        normalizedKeys.add(KEY.ARROW_UP);
        normalizedKeys.add(KEY.ARROW_RIGHT);
        normalizedKeys.add(KEY.ARROW_DOWN);
        normalizedKeys.add(KEY.DELETE);
        normalizedKeys.add(KEY.ESCAPE);
        var KEY_CODE = {
            BACKSPACE: 8,
            ENTER: 13,
            SPACEBAR: 32,
            PAGE_UP: 33,
            PAGE_DOWN: 34,
            END: 35,
            HOME: 36,
            ARROW_LEFT: 37,
            ARROW_UP: 38,
            ARROW_RIGHT: 39,
            ARROW_DOWN: 40,
            DELETE: 46,
            ESCAPE: 27
        };
        var mappedKeyCodes = new Map;
        mappedKeyCodes.set(KEY_CODE.BACKSPACE, KEY.BACKSPACE);
        mappedKeyCodes.set(KEY_CODE.ENTER, KEY.ENTER);
        mappedKeyCodes.set(KEY_CODE.SPACEBAR, KEY.SPACEBAR);
        mappedKeyCodes.set(KEY_CODE.PAGE_UP, KEY.PAGE_UP);
        mappedKeyCodes.set(KEY_CODE.PAGE_DOWN, KEY.PAGE_DOWN);
        mappedKeyCodes.set(KEY_CODE.END, KEY.END);
        mappedKeyCodes.set(KEY_CODE.HOME, KEY.HOME);
        mappedKeyCodes.set(KEY_CODE.ARROW_LEFT, KEY.ARROW_LEFT);
        mappedKeyCodes.set(KEY_CODE.ARROW_UP, KEY.ARROW_UP);
        mappedKeyCodes.set(KEY_CODE.ARROW_RIGHT, KEY.ARROW_RIGHT);
        mappedKeyCodes.set(KEY_CODE.ARROW_DOWN, KEY.ARROW_DOWN);
        mappedKeyCodes.set(KEY_CODE.DELETE, KEY.DELETE);
        mappedKeyCodes.set(KEY_CODE.ESCAPE, KEY.ESCAPE);
        var navigationKeys = new Set;
        navigationKeys.add(KEY.PAGE_UP);
        navigationKeys.add(KEY.PAGE_DOWN);
        navigationKeys.add(KEY.END);
        navigationKeys.add(KEY.HOME);
        navigationKeys.add(KEY.ARROW_LEFT);
        navigationKeys.add(KEY.ARROW_UP);
        navigationKeys.add(KEY.ARROW_RIGHT);
        navigationKeys.add(KEY.ARROW_DOWN);
        function normalizeKey(evt) {
            var key = evt.key;
            if (normalizedKeys.has(key)) {
                return key;
            }
            var mappedKey = mappedKeyCodes.get(evt.keyCode);
            if (mappedKey) {
                return mappedKey;
            }
            return KEY.UNKNOWN;
        }
        function isNavigationEvent(evt) {
            return navigationKeys.has(normalizeKey(evt));
        }
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var ELEMENTS_KEY_ALLOWED_IN = [ "input", "button", "textarea", "select" ];
        var preventDefaultEvent = function(evt) {
            var target = evt.target;
            if (!target) {
                return;
            }
            var tagName = ("" + target.tagName).toLowerCase();
            if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {
                evt.preventDefault();
            }
        };
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        function initState() {
            var state = {
                bufferClearTimeout: 0,
                currentFirstChar: "",
                sortedIndexCursor: 0,
                typeaheadBuffer: ""
            };
            return state;
        }
        function initSortedIndex(listItemCount, getPrimaryTextByItemIndex) {
            var sortedIndexByFirstChar = new Map;
            for (var i = 0; i < listItemCount; i++) {
                var primaryText = getPrimaryTextByItemIndex(i).trim();
                if (!primaryText) {
                    continue;
                }
                var firstChar = primaryText[0].toLowerCase();
                if (!sortedIndexByFirstChar.has(firstChar)) {
                    sortedIndexByFirstChar.set(firstChar, []);
                }
                sortedIndexByFirstChar.get(firstChar).push({
                    text: primaryText.toLowerCase(),
                    index: i
                });
            }
            sortedIndexByFirstChar.forEach((function(values) {
                values.sort((function(first, second) {
                    return first.index - second.index;
                }));
            }));
            return sortedIndexByFirstChar;
        }
        function matchItem(opts, state) {
            var nextChar = opts.nextChar, focusItemAtIndex = opts.focusItemAtIndex, sortedIndexByFirstChar = opts.sortedIndexByFirstChar, focusedItemIndex = opts.focusedItemIndex, skipFocus = opts.skipFocus, isItemAtIndexDisabled = opts.isItemAtIndexDisabled;
            clearTimeout(state.bufferClearTimeout);
            state.bufferClearTimeout = setTimeout((function() {
                clearBuffer(state);
            }), list_constants_numbers.TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS);
            state.typeaheadBuffer = state.typeaheadBuffer + nextChar;
            var index;
            if (state.typeaheadBuffer.length === 1) {
                index = matchFirstChar(sortedIndexByFirstChar, focusedItemIndex, isItemAtIndexDisabled, state);
            } else {
                index = matchAllChars(sortedIndexByFirstChar, isItemAtIndexDisabled, state);
            }
            if (index !== -1 && !skipFocus) {
                focusItemAtIndex(index);
            }
            return index;
        }
        function matchFirstChar(sortedIndexByFirstChar, focusedItemIndex, isItemAtIndexDisabled, state) {
            var firstChar = state.typeaheadBuffer[0];
            var itemsMatchingFirstChar = sortedIndexByFirstChar.get(firstChar);
            if (!itemsMatchingFirstChar) {
                return -1;
            }
            if (firstChar === state.currentFirstChar && itemsMatchingFirstChar[state.sortedIndexCursor].index === focusedItemIndex) {
                state.sortedIndexCursor = (state.sortedIndexCursor + 1) % itemsMatchingFirstChar.length;
                var newIndex = itemsMatchingFirstChar[state.sortedIndexCursor].index;
                if (!isItemAtIndexDisabled(newIndex)) {
                    return newIndex;
                }
            }
            state.currentFirstChar = firstChar;
            var newCursorPosition = -1;
            var cursorPosition;
            for (cursorPosition = 0; cursorPosition < itemsMatchingFirstChar.length; cursorPosition++) {
                if (!isItemAtIndexDisabled(itemsMatchingFirstChar[cursorPosition].index)) {
                    newCursorPosition = cursorPosition;
                    break;
                }
            }
            for (;cursorPosition < itemsMatchingFirstChar.length; cursorPosition++) {
                if (itemsMatchingFirstChar[cursorPosition].index > focusedItemIndex && !isItemAtIndexDisabled(itemsMatchingFirstChar[cursorPosition].index)) {
                    newCursorPosition = cursorPosition;
                    break;
                }
            }
            if (newCursorPosition !== -1) {
                state.sortedIndexCursor = newCursorPosition;
                return itemsMatchingFirstChar[state.sortedIndexCursor].index;
            }
            return -1;
        }
        function matchAllChars(sortedIndexByFirstChar, isItemAtIndexDisabled, state) {
            var firstChar = state.typeaheadBuffer[0];
            var itemsMatchingFirstChar = sortedIndexByFirstChar.get(firstChar);
            if (!itemsMatchingFirstChar) {
                return -1;
            }
            var startingItem = itemsMatchingFirstChar[state.sortedIndexCursor];
            if (startingItem.text.lastIndexOf(state.typeaheadBuffer, 0) === 0 && !isItemAtIndexDisabled(startingItem.index)) {
                return startingItem.index;
            }
            var cursorPosition = (state.sortedIndexCursor + 1) % itemsMatchingFirstChar.length;
            var nextCursorPosition = -1;
            while (cursorPosition !== state.sortedIndexCursor) {
                var currentItem = itemsMatchingFirstChar[cursorPosition];
                var matches = currentItem.text.lastIndexOf(state.typeaheadBuffer, 0) === 0;
                var isEnabled = !isItemAtIndexDisabled(currentItem.index);
                if (matches && isEnabled) {
                    nextCursorPosition = cursorPosition;
                    break;
                }
                cursorPosition = (cursorPosition + 1) % itemsMatchingFirstChar.length;
            }
            if (nextCursorPosition !== -1) {
                state.sortedIndexCursor = nextCursorPosition;
                return itemsMatchingFirstChar[state.sortedIndexCursor].index;
            }
            return -1;
        }
        function isTypingInProgress(state) {
            return state.typeaheadBuffer.length > 0;
        }
        function clearBuffer(state) {
            state.typeaheadBuffer = "";
        }
        function handleKeydown(opts, state) {
            var event = opts.event, isTargetListItem = opts.isTargetListItem, focusedItemIndex = opts.focusedItemIndex, focusItemAtIndex = opts.focusItemAtIndex, sortedIndexByFirstChar = opts.sortedIndexByFirstChar, isItemAtIndexDisabled = opts.isItemAtIndexDisabled;
            var isArrowLeft = normalizeKey(event) === "ArrowLeft";
            var isArrowUp = normalizeKey(event) === "ArrowUp";
            var isArrowRight = normalizeKey(event) === "ArrowRight";
            var isArrowDown = normalizeKey(event) === "ArrowDown";
            var isHome = normalizeKey(event) === "Home";
            var isEnd = normalizeKey(event) === "End";
            var isEnter = normalizeKey(event) === "Enter";
            var isSpace = normalizeKey(event) === "Spacebar";
            if (isArrowLeft || isArrowUp || isArrowRight || isArrowDown || isHome || isEnd || isEnter) {
                return -1;
            }
            var isCharacterKey = !isSpace && event.key.length === 1;
            if (isCharacterKey) {
                preventDefaultEvent(event);
                var matchItemOpts = {
                    focusItemAtIndex: focusItemAtIndex,
                    focusedItemIndex: focusedItemIndex,
                    nextChar: event.key.toLowerCase(),
                    sortedIndexByFirstChar: sortedIndexByFirstChar,
                    skipFocus: false,
                    isItemAtIndexDisabled: isItemAtIndexDisabled
                };
                return matchItem(matchItemOpts, state);
            }
            if (!isSpace) {
                return -1;
            }
            if (isTargetListItem) {
                preventDefaultEvent(event);
            }
            var typeaheadOnListItem = isTargetListItem && isTypingInProgress(state);
            if (typeaheadOnListItem) {
                var matchItemOpts = {
                    focusItemAtIndex: focusItemAtIndex,
                    focusedItemIndex: focusedItemIndex,
                    nextChar: " ",
                    sortedIndexByFirstChar: sortedIndexByFirstChar,
                    skipFocus: false,
                    isItemAtIndexDisabled: isItemAtIndexDisabled
                };
                return matchItem(matchItemOpts, state);
            }
            return -1;
        }
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        function isNumberArray(selectedIndex) {
            return selectedIndex instanceof Array;
        }
        var MDCListFoundation = function(_super) {
            __extends(MDCListFoundation, _super);
            function MDCListFoundation(adapter) {
                var _this = _super.call(this, __assign(__assign({}, MDCListFoundation.defaultAdapter), adapter)) || this;
                _this.wrapFocus_ = false;
                _this.isVertical_ = true;
                _this.isSingleSelectionList_ = false;
                _this.selectedIndex_ = list_constants_numbers.UNSET_INDEX;
                _this.focusedItemIndex = list_constants_numbers.UNSET_INDEX;
                _this.useActivatedClass_ = false;
                _this.useSelectedAttr_ = false;
                _this.ariaCurrentAttrValue_ = null;
                _this.isCheckboxList_ = false;
                _this.isRadioList_ = false;
                _this.hasTypeahead = false;
                _this.typeaheadState = initState();
                _this.sortedIndexByFirstChar = new Map;
                return _this;
            }
            Object.defineProperty(MDCListFoundation, "strings", {
                get: function() {
                    return list_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCListFoundation, "cssClasses", {
                get: function() {
                    return list_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCListFoundation, "numbers", {
                get: function() {
                    return list_constants_numbers;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCListFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClassForElementIndex: function() {
                            return undefined;
                        },
                        focusItemAtIndex: function() {
                            return undefined;
                        },
                        getAttributeForElementIndex: function() {
                            return null;
                        },
                        getFocusedElementIndex: function() {
                            return 0;
                        },
                        getListItemCount: function() {
                            return 0;
                        },
                        hasCheckboxAtIndex: function() {
                            return false;
                        },
                        hasRadioAtIndex: function() {
                            return false;
                        },
                        isCheckboxCheckedAtIndex: function() {
                            return false;
                        },
                        isFocusInsideList: function() {
                            return false;
                        },
                        isRootFocused: function() {
                            return false;
                        },
                        listItemAtIndexHasClass: function() {
                            return false;
                        },
                        notifyAction: function() {
                            return undefined;
                        },
                        removeClassForElementIndex: function() {
                            return undefined;
                        },
                        setAttributeForElementIndex: function() {
                            return undefined;
                        },
                        setCheckedCheckboxOrRadioAtIndex: function() {
                            return undefined;
                        },
                        setTabIndexForListItemChildren: function() {
                            return undefined;
                        },
                        getPrimaryTextAtIndex: function() {
                            return "";
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCListFoundation.prototype.layout = function() {
                if (this.adapter.getListItemCount() === 0) {
                    return;
                }
                if (this.adapter.hasCheckboxAtIndex(0)) {
                    this.isCheckboxList_ = true;
                } else if (this.adapter.hasRadioAtIndex(0)) {
                    this.isRadioList_ = true;
                } else {
                    this.maybeInitializeSingleSelection();
                }
                if (this.hasTypeahead) {
                    this.sortedIndexByFirstChar = this.typeaheadInitSortedIndex();
                }
            };
            MDCListFoundation.prototype.setWrapFocus = function(value) {
                this.wrapFocus_ = value;
            };
            MDCListFoundation.prototype.setVerticalOrientation = function(value) {
                this.isVertical_ = value;
            };
            MDCListFoundation.prototype.setSingleSelection = function(value) {
                this.isSingleSelectionList_ = value;
                if (value) {
                    this.maybeInitializeSingleSelection();
                }
            };
            MDCListFoundation.prototype.maybeInitializeSingleSelection = function() {
                for (var i = 0; i < this.adapter.getListItemCount(); i++) {
                    var hasSelectedClass = this.adapter.listItemAtIndexHasClass(i, list_constants_cssClasses.LIST_ITEM_SELECTED_CLASS);
                    var hasActivatedClass = this.adapter.listItemAtIndexHasClass(i, list_constants_cssClasses.LIST_ITEM_ACTIVATED_CLASS);
                    if (!(hasSelectedClass || hasActivatedClass)) {
                        continue;
                    }
                    if (hasActivatedClass) {
                        this.setUseActivatedClass(true);
                    }
                    this.isSingleSelectionList_ = true;
                    this.selectedIndex_ = i;
                    return;
                }
            };
            MDCListFoundation.prototype.setHasTypeahead = function(hasTypeahead) {
                this.hasTypeahead = hasTypeahead;
                if (hasTypeahead) {
                    this.sortedIndexByFirstChar = this.typeaheadInitSortedIndex();
                }
            };
            MDCListFoundation.prototype.isTypeaheadInProgress = function() {
                return this.hasTypeahead && isTypingInProgress(this.typeaheadState);
            };
            MDCListFoundation.prototype.setUseActivatedClass = function(useActivated) {
                this.useActivatedClass_ = useActivated;
            };
            MDCListFoundation.prototype.setUseSelectedAttribute = function(useSelected) {
                this.useSelectedAttr_ = useSelected;
            };
            MDCListFoundation.prototype.getSelectedIndex = function() {
                return this.selectedIndex_;
            };
            MDCListFoundation.prototype.setSelectedIndex = function(index) {
                if (!this.isIndexValid_(index)) {
                    return;
                }
                if (this.isCheckboxList_) {
                    this.setCheckboxAtIndex_(index);
                } else if (this.isRadioList_) {
                    this.setRadioAtIndex_(index);
                } else {
                    this.setSingleSelectionAtIndex_(index);
                }
            };
            MDCListFoundation.prototype.handleFocusIn = function(_, listItemIndex) {
                if (listItemIndex >= 0) {
                    this.focusedItemIndex = listItemIndex;
                    this.adapter.setAttributeForElementIndex(listItemIndex, "tabindex", "0");
                    this.adapter.setTabIndexForListItemChildren(listItemIndex, "0");
                }
            };
            MDCListFoundation.prototype.handleFocusOut = function(_, listItemIndex) {
                var _this = this;
                if (listItemIndex >= 0) {
                    this.adapter.setAttributeForElementIndex(listItemIndex, "tabindex", "-1");
                    this.adapter.setTabIndexForListItemChildren(listItemIndex, "-1");
                }
                setTimeout((function() {
                    if (!_this.adapter.isFocusInsideList()) {
                        _this.setTabindexToFirstSelectedOrFocusedItem();
                    }
                }), 0);
            };
            MDCListFoundation.prototype.handleKeydown = function(event, isRootListItem, listItemIndex) {
                var _this = this;
                var isArrowLeft = normalizeKey(event) === "ArrowLeft";
                var isArrowUp = normalizeKey(event) === "ArrowUp";
                var isArrowRight = normalizeKey(event) === "ArrowRight";
                var isArrowDown = normalizeKey(event) === "ArrowDown";
                var isHome = normalizeKey(event) === "Home";
                var isEnd = normalizeKey(event) === "End";
                var isEnter = normalizeKey(event) === "Enter";
                var isSpace = normalizeKey(event) === "Spacebar";
                var isLetterA = event.key === "A" || event.key === "a";
                if (this.adapter.isRootFocused()) {
                    if (isArrowUp || isEnd) {
                        event.preventDefault();
                        this.focusLastElement();
                    } else if (isArrowDown || isHome) {
                        event.preventDefault();
                        this.focusFirstElement();
                    }
                    if (this.hasTypeahead) {
                        var handleKeydownOpts = {
                            event: event,
                            focusItemAtIndex: function(index) {
                                _this.focusItemAtIndex(index);
                            },
                            focusedItemIndex: -1,
                            isTargetListItem: isRootListItem,
                            sortedIndexByFirstChar: this.sortedIndexByFirstChar,
                            isItemAtIndexDisabled: function(index) {
                                return _this.adapter.listItemAtIndexHasClass(index, list_constants_cssClasses.LIST_ITEM_DISABLED_CLASS);
                            }
                        };
                        handleKeydown(handleKeydownOpts, this.typeaheadState);
                    }
                    return;
                }
                var currentIndex = this.adapter.getFocusedElementIndex();
                if (currentIndex === -1) {
                    currentIndex = listItemIndex;
                    if (currentIndex < 0) {
                        return;
                    }
                }
                if (this.isVertical_ && isArrowDown || !this.isVertical_ && isArrowRight) {
                    preventDefaultEvent(event);
                    this.focusNextElement(currentIndex);
                } else if (this.isVertical_ && isArrowUp || !this.isVertical_ && isArrowLeft) {
                    preventDefaultEvent(event);
                    this.focusPrevElement(currentIndex);
                } else if (isHome) {
                    preventDefaultEvent(event);
                    this.focusFirstElement();
                } else if (isEnd) {
                    preventDefaultEvent(event);
                    this.focusLastElement();
                } else if (isLetterA && event.ctrlKey && this.isCheckboxList_) {
                    event.preventDefault();
                    this.toggleAll(this.selectedIndex_ === list_constants_numbers.UNSET_INDEX ? [] : this.selectedIndex_);
                } else if (isEnter || isSpace) {
                    if (isRootListItem) {
                        var target = event.target;
                        if (target && target.tagName === "A" && isEnter) {
                            return;
                        }
                        preventDefaultEvent(event);
                        if (this.adapter.listItemAtIndexHasClass(currentIndex, list_constants_cssClasses.LIST_ITEM_DISABLED_CLASS)) {
                            return;
                        }
                        if (!this.isTypeaheadInProgress()) {
                            if (this.isSelectableList_()) {
                                this.setSelectedIndexOnAction_(currentIndex);
                            }
                            this.adapter.notifyAction(currentIndex);
                        }
                    }
                }
                if (this.hasTypeahead) {
                    var handleKeydownOpts = {
                        event: event,
                        focusItemAtIndex: function(index) {
                            _this.focusItemAtIndex(index);
                        },
                        focusedItemIndex: this.focusedItemIndex,
                        isTargetListItem: isRootListItem,
                        sortedIndexByFirstChar: this.sortedIndexByFirstChar,
                        isItemAtIndexDisabled: function(index) {
                            return _this.adapter.listItemAtIndexHasClass(index, list_constants_cssClasses.LIST_ITEM_DISABLED_CLASS);
                        }
                    };
                    handleKeydown(handleKeydownOpts, this.typeaheadState);
                }
            };
            MDCListFoundation.prototype.handleClick = function(index, toggleCheckbox) {
                if (index === list_constants_numbers.UNSET_INDEX) {
                    return;
                }
                if (this.adapter.listItemAtIndexHasClass(index, list_constants_cssClasses.LIST_ITEM_DISABLED_CLASS)) {
                    return;
                }
                if (this.isSelectableList_()) {
                    this.setSelectedIndexOnAction_(index, toggleCheckbox);
                }
                this.adapter.notifyAction(index);
            };
            MDCListFoundation.prototype.focusNextElement = function(index) {
                var count = this.adapter.getListItemCount();
                var nextIndex = index + 1;
                if (nextIndex >= count) {
                    if (this.wrapFocus_) {
                        nextIndex = 0;
                    } else {
                        return index;
                    }
                }
                this.focusItemAtIndex(nextIndex);
                return nextIndex;
            };
            MDCListFoundation.prototype.focusPrevElement = function(index) {
                var prevIndex = index - 1;
                if (prevIndex < 0) {
                    if (this.wrapFocus_) {
                        prevIndex = this.adapter.getListItemCount() - 1;
                    } else {
                        return index;
                    }
                }
                this.focusItemAtIndex(prevIndex);
                return prevIndex;
            };
            MDCListFoundation.prototype.focusFirstElement = function() {
                this.focusItemAtIndex(0);
                return 0;
            };
            MDCListFoundation.prototype.focusLastElement = function() {
                var lastIndex = this.adapter.getListItemCount() - 1;
                this.focusItemAtIndex(lastIndex);
                return lastIndex;
            };
            MDCListFoundation.prototype.focusInitialElement = function() {
                var initialIndex = this.getFirstSelectedOrFocusedItemIndex();
                this.focusItemAtIndex(initialIndex);
                return initialIndex;
            };
            MDCListFoundation.prototype.setEnabled = function(itemIndex, isEnabled) {
                if (!this.isIndexValid_(itemIndex)) {
                    return;
                }
                if (isEnabled) {
                    this.adapter.removeClassForElementIndex(itemIndex, list_constants_cssClasses.LIST_ITEM_DISABLED_CLASS);
                    this.adapter.setAttributeForElementIndex(itemIndex, list_constants_strings.ARIA_DISABLED, "false");
                } else {
                    this.adapter.addClassForElementIndex(itemIndex, list_constants_cssClasses.LIST_ITEM_DISABLED_CLASS);
                    this.adapter.setAttributeForElementIndex(itemIndex, list_constants_strings.ARIA_DISABLED, "true");
                }
            };
            MDCListFoundation.prototype.setSingleSelectionAtIndex_ = function(index) {
                if (this.selectedIndex_ === index) {
                    return;
                }
                var selectedClassName = list_constants_cssClasses.LIST_ITEM_SELECTED_CLASS;
                if (this.useActivatedClass_) {
                    selectedClassName = list_constants_cssClasses.LIST_ITEM_ACTIVATED_CLASS;
                }
                if (this.selectedIndex_ !== list_constants_numbers.UNSET_INDEX) {
                    this.adapter.removeClassForElementIndex(this.selectedIndex_, selectedClassName);
                }
                this.setAriaForSingleSelectionAtIndex_(index);
                this.setTabindexAtIndex(index);
                if (index !== list_constants_numbers.UNSET_INDEX) {
                    this.adapter.addClassForElementIndex(index, selectedClassName);
                }
                this.selectedIndex_ = index;
            };
            MDCListFoundation.prototype.setAriaForSingleSelectionAtIndex_ = function(index) {
                if (this.selectedIndex_ === list_constants_numbers.UNSET_INDEX) {
                    this.ariaCurrentAttrValue_ = this.adapter.getAttributeForElementIndex(index, list_constants_strings.ARIA_CURRENT);
                }
                var isAriaCurrent = this.ariaCurrentAttrValue_ !== null;
                var ariaAttribute = isAriaCurrent ? list_constants_strings.ARIA_CURRENT : list_constants_strings.ARIA_SELECTED;
                if (this.selectedIndex_ !== list_constants_numbers.UNSET_INDEX) {
                    this.adapter.setAttributeForElementIndex(this.selectedIndex_, ariaAttribute, "false");
                }
                if (index !== list_constants_numbers.UNSET_INDEX) {
                    var ariaAttributeValue = isAriaCurrent ? this.ariaCurrentAttrValue_ : "true";
                    this.adapter.setAttributeForElementIndex(index, ariaAttribute, ariaAttributeValue);
                }
            };
            MDCListFoundation.prototype.getSelectionAttribute = function() {
                return this.useSelectedAttr_ ? list_constants_strings.ARIA_SELECTED : list_constants_strings.ARIA_CHECKED;
            };
            MDCListFoundation.prototype.setRadioAtIndex_ = function(index) {
                var selectionAttribute = this.getSelectionAttribute();
                this.adapter.setCheckedCheckboxOrRadioAtIndex(index, true);
                if (this.selectedIndex_ !== list_constants_numbers.UNSET_INDEX) {
                    this.adapter.setAttributeForElementIndex(this.selectedIndex_, selectionAttribute, "false");
                }
                this.adapter.setAttributeForElementIndex(index, selectionAttribute, "true");
                this.selectedIndex_ = index;
            };
            MDCListFoundation.prototype.setCheckboxAtIndex_ = function(index) {
                var selectionAttribute = this.getSelectionAttribute();
                for (var i = 0; i < this.adapter.getListItemCount(); i++) {
                    var isChecked = false;
                    if (index.indexOf(i) >= 0) {
                        isChecked = true;
                    }
                    this.adapter.setCheckedCheckboxOrRadioAtIndex(i, isChecked);
                    this.adapter.setAttributeForElementIndex(i, selectionAttribute, isChecked ? "true" : "false");
                }
                this.selectedIndex_ = index;
            };
            MDCListFoundation.prototype.setTabindexAtIndex = function(index) {
                if (this.focusedItemIndex === list_constants_numbers.UNSET_INDEX && index !== 0) {
                    this.adapter.setAttributeForElementIndex(0, "tabindex", "-1");
                } else if (this.focusedItemIndex >= 0 && this.focusedItemIndex !== index) {
                    this.adapter.setAttributeForElementIndex(this.focusedItemIndex, "tabindex", "-1");
                }
                if (!(this.selectedIndex_ instanceof Array) && this.selectedIndex_ !== index) {
                    this.adapter.setAttributeForElementIndex(this.selectedIndex_, "tabindex", "-1");
                }
                if (index !== list_constants_numbers.UNSET_INDEX) {
                    this.adapter.setAttributeForElementIndex(index, "tabindex", "0");
                }
            };
            MDCListFoundation.prototype.isSelectableList_ = function() {
                return this.isSingleSelectionList_ || this.isCheckboxList_ || this.isRadioList_;
            };
            MDCListFoundation.prototype.setTabindexToFirstSelectedOrFocusedItem = function() {
                var targetIndex = this.getFirstSelectedOrFocusedItemIndex();
                this.setTabindexAtIndex(targetIndex);
            };
            MDCListFoundation.prototype.getFirstSelectedOrFocusedItemIndex = function() {
                var targetIndex = this.focusedItemIndex >= 0 ? this.focusedItemIndex : 0;
                if (this.isSelectableList_()) {
                    if (typeof this.selectedIndex_ === "number" && this.selectedIndex_ !== list_constants_numbers.UNSET_INDEX) {
                        targetIndex = this.selectedIndex_;
                    } else if (isNumberArray(this.selectedIndex_) && this.selectedIndex_.length > 0) {
                        targetIndex = this.selectedIndex_.reduce((function(currentIndex, minIndex) {
                            return Math.min(currentIndex, minIndex);
                        }));
                    }
                }
                return targetIndex;
            };
            MDCListFoundation.prototype.isIndexValid_ = function(index) {
                var _this = this;
                if (index instanceof Array) {
                    if (!this.isCheckboxList_) {
                        throw new Error("MDCListFoundation: Array of index is only supported for checkbox based list");
                    }
                    if (index.length === 0) {
                        return true;
                    } else {
                        return index.some((function(i) {
                            return _this.isIndexInRange_(i);
                        }));
                    }
                } else if (typeof index === "number") {
                    if (this.isCheckboxList_) {
                        throw new Error("MDCListFoundation: Expected array of index for checkbox based list but got number: " + index);
                    }
                    return this.isIndexInRange_(index) || this.isSingleSelectionList_ && index === list_constants_numbers.UNSET_INDEX;
                } else {
                    return false;
                }
            };
            MDCListFoundation.prototype.isIndexInRange_ = function(index) {
                var listSize = this.adapter.getListItemCount();
                return index >= 0 && index < listSize;
            };
            MDCListFoundation.prototype.setSelectedIndexOnAction_ = function(index, toggleCheckbox) {
                if (toggleCheckbox === void 0) {
                    toggleCheckbox = true;
                }
                if (this.isCheckboxList_) {
                    this.toggleCheckboxAtIndex_(index, toggleCheckbox);
                } else {
                    this.setSelectedIndex(index);
                }
            };
            MDCListFoundation.prototype.toggleCheckboxAtIndex_ = function(index, toggleCheckbox) {
                var selectionAttribute = this.getSelectionAttribute();
                var isChecked = this.adapter.isCheckboxCheckedAtIndex(index);
                if (toggleCheckbox) {
                    isChecked = !isChecked;
                    this.adapter.setCheckedCheckboxOrRadioAtIndex(index, isChecked);
                }
                this.adapter.setAttributeForElementIndex(index, selectionAttribute, isChecked ? "true" : "false");
                var selectedIndexes = this.selectedIndex_ === list_constants_numbers.UNSET_INDEX ? [] : this.selectedIndex_.slice();
                if (isChecked) {
                    selectedIndexes.push(index);
                } else {
                    selectedIndexes = selectedIndexes.filter((function(i) {
                        return i !== index;
                    }));
                }
                this.selectedIndex_ = selectedIndexes;
            };
            MDCListFoundation.prototype.focusItemAtIndex = function(index) {
                this.adapter.focusItemAtIndex(index);
                this.focusedItemIndex = index;
            };
            MDCListFoundation.prototype.toggleAll = function(currentlySelectedIndexes) {
                var count = this.adapter.getListItemCount();
                if (currentlySelectedIndexes.length === count) {
                    this.setCheckboxAtIndex_([]);
                } else {
                    var allIndexes = [];
                    for (var i = 0; i < count; i++) {
                        if (!this.adapter.listItemAtIndexHasClass(i, list_constants_cssClasses.LIST_ITEM_DISABLED_CLASS) || currentlySelectedIndexes.indexOf(i) > -1) {
                            allIndexes.push(i);
                        }
                    }
                    this.setCheckboxAtIndex_(allIndexes);
                }
            };
            MDCListFoundation.prototype.typeaheadMatchItem = function(nextChar, startingIndex, skipFocus) {
                var _this = this;
                if (skipFocus === void 0) {
                    skipFocus = false;
                }
                var opts = {
                    focusItemAtIndex: function(index) {
                        _this.focusItemAtIndex(index);
                    },
                    focusedItemIndex: startingIndex ? startingIndex : this.focusedItemIndex,
                    nextChar: nextChar,
                    sortedIndexByFirstChar: this.sortedIndexByFirstChar,
                    skipFocus: skipFocus,
                    isItemAtIndexDisabled: function(index) {
                        return _this.adapter.listItemAtIndexHasClass(index, list_constants_cssClasses.LIST_ITEM_DISABLED_CLASS);
                    }
                };
                return matchItem(opts, this.typeaheadState);
            };
            MDCListFoundation.prototype.typeaheadInitSortedIndex = function() {
                return initSortedIndex(this.adapter.getListItemCount(), this.adapter.getPrimaryTextAtIndex);
            };
            MDCListFoundation.prototype.clearTypeaheadBuffer = function() {
                clearBuffer(this.typeaheadState);
            };
            return MDCListFoundation;
        }(MDCFoundation);
        const list_foundation = null && MDCListFoundation;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCList = function(_super) {
            __extends(MDCList, _super);
            function MDCList() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Object.defineProperty(MDCList.prototype, "vertical", {
                set: function(value) {
                    this.foundation.setVerticalOrientation(value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCList.prototype, "listElements", {
                get: function() {
                    return [].slice.call(this.root.querySelectorAll("." + list_constants_cssClasses.LIST_ITEM_CLASS));
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCList.prototype, "wrapFocus", {
                set: function(value) {
                    this.foundation.setWrapFocus(value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCList.prototype, "typeaheadInProgress", {
                get: function() {
                    return this.foundation.isTypeaheadInProgress();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCList.prototype, "hasTypeahead", {
                set: function(hasTypeahead) {
                    this.foundation.setHasTypeahead(hasTypeahead);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCList.prototype, "singleSelection", {
                set: function(isSingleSelectionList) {
                    this.foundation.setSingleSelection(isSingleSelectionList);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCList.prototype, "selectedIndex", {
                get: function() {
                    return this.foundation.getSelectedIndex();
                },
                set: function(index) {
                    this.foundation.setSelectedIndex(index);
                },
                enumerable: true,
                configurable: true
            });
            MDCList.attachTo = function(root) {
                return new MDCList(root);
            };
            MDCList.prototype.initialSyncWithDOM = function() {
                this.handleClick_ = this.handleClickEvent_.bind(this);
                this.handleKeydown_ = this.handleKeydownEvent_.bind(this);
                this.focusInEventListener_ = this.handleFocusInEvent_.bind(this);
                this.focusOutEventListener_ = this.handleFocusOutEvent_.bind(this);
                this.listen("keydown", this.handleKeydown_);
                this.listen("click", this.handleClick_);
                this.listen("focusin", this.focusInEventListener_);
                this.listen("focusout", this.focusOutEventListener_);
                this.layout();
                this.initializeListType();
            };
            MDCList.prototype.destroy = function() {
                this.unlisten("keydown", this.handleKeydown_);
                this.unlisten("click", this.handleClick_);
                this.unlisten("focusin", this.focusInEventListener_);
                this.unlisten("focusout", this.focusOutEventListener_);
            };
            MDCList.prototype.layout = function() {
                var direction = this.root.getAttribute(list_constants_strings.ARIA_ORIENTATION);
                this.vertical = direction !== list_constants_strings.ARIA_ORIENTATION_HORIZONTAL;
                [].slice.call(this.root.querySelectorAll(".mdc-list-item:not([tabindex])")).forEach((function(el) {
                    el.setAttribute("tabindex", "-1");
                }));
                [].slice.call(this.root.querySelectorAll(list_constants_strings.FOCUSABLE_CHILD_ELEMENTS)).forEach((function(el) {
                    return el.setAttribute("tabindex", "-1");
                }));
                this.foundation.layout();
            };
            MDCList.prototype.getPrimaryText = function(item) {
                var primaryText = item.querySelector("." + list_constants_cssClasses.LIST_ITEM_PRIMARY_TEXT_CLASS);
                if (primaryText) {
                    return primaryText.textContent || "";
                }
                var singleLineText = item.querySelector("." + list_constants_cssClasses.LIST_ITEM_TEXT_CLASS);
                return singleLineText && singleLineText.textContent || "";
            };
            MDCList.prototype.initializeListType = function() {
                var _this = this;
                var checkboxListItems = this.root.querySelectorAll(list_constants_strings.ARIA_ROLE_CHECKBOX_SELECTOR);
                var radioSelectedListItem = this.root.querySelector(list_constants_strings.ARIA_CHECKED_RADIO_SELECTOR);
                if (checkboxListItems.length) {
                    var preselectedItems = this.root.querySelectorAll(list_constants_strings.ARIA_CHECKED_CHECKBOX_SELECTOR);
                    this.selectedIndex = [].map.call(preselectedItems, (function(listItem) {
                        return _this.listElements.indexOf(listItem);
                    }));
                } else if (radioSelectedListItem) {
                    this.selectedIndex = this.listElements.indexOf(radioSelectedListItem);
                }
            };
            MDCList.prototype.setEnabled = function(itemIndex, isEnabled) {
                this.foundation.setEnabled(itemIndex, isEnabled);
            };
            MDCList.prototype.typeaheadMatchItem = function(nextChar, startingIndex) {
                return this.foundation.typeaheadMatchItem(nextChar, startingIndex, true);
            };
            MDCList.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    addClassForElementIndex: function(index, className) {
                        var element = _this.listElements[index];
                        if (element) {
                            element.classList.add(className);
                        }
                    },
                    focusItemAtIndex: function(index) {
                        var element = _this.listElements[index];
                        if (element) {
                            element.focus();
                        }
                    },
                    getAttributeForElementIndex: function(index, attr) {
                        return _this.listElements[index].getAttribute(attr);
                    },
                    getFocusedElementIndex: function() {
                        return _this.listElements.indexOf(document.activeElement);
                    },
                    getListItemCount: function() {
                        return _this.listElements.length;
                    },
                    getPrimaryTextAtIndex: function(index) {
                        return _this.getPrimaryText(_this.listElements[index]);
                    },
                    hasCheckboxAtIndex: function(index) {
                        var listItem = _this.listElements[index];
                        return !!listItem.querySelector(list_constants_strings.CHECKBOX_SELECTOR);
                    },
                    hasRadioAtIndex: function(index) {
                        var listItem = _this.listElements[index];
                        return !!listItem.querySelector(list_constants_strings.RADIO_SELECTOR);
                    },
                    isCheckboxCheckedAtIndex: function(index) {
                        var listItem = _this.listElements[index];
                        var toggleEl = listItem.querySelector(list_constants_strings.CHECKBOX_SELECTOR);
                        return toggleEl.checked;
                    },
                    isFocusInsideList: function() {
                        return _this.root !== document.activeElement && _this.root.contains(document.activeElement);
                    },
                    isRootFocused: function() {
                        return document.activeElement === _this.root;
                    },
                    listItemAtIndexHasClass: function(index, className) {
                        return _this.listElements[index].classList.contains(className);
                    },
                    notifyAction: function(index) {
                        _this.emit(list_constants_strings.ACTION_EVENT, {
                            index: index
                        }, true);
                    },
                    removeClassForElementIndex: function(index, className) {
                        var element = _this.listElements[index];
                        if (element) {
                            element.classList.remove(className);
                        }
                    },
                    setAttributeForElementIndex: function(index, attr, value) {
                        var element = _this.listElements[index];
                        if (element) {
                            element.setAttribute(attr, value);
                        }
                    },
                    setCheckedCheckboxOrRadioAtIndex: function(index, isChecked) {
                        var listItem = _this.listElements[index];
                        var toggleEl = listItem.querySelector(list_constants_strings.CHECKBOX_RADIO_SELECTOR);
                        toggleEl.checked = isChecked;
                        var event = document.createEvent("Event");
                        event.initEvent("change", true, true);
                        toggleEl.dispatchEvent(event);
                    },
                    setTabIndexForListItemChildren: function(listItemIndex, tabIndexValue) {
                        var element = _this.listElements[listItemIndex];
                        var listItemChildren = [].slice.call(element.querySelectorAll(list_constants_strings.CHILD_ELEMENTS_TO_TOGGLE_TABINDEX));
                        listItemChildren.forEach((function(el) {
                            return el.setAttribute("tabindex", tabIndexValue);
                        }));
                    }
                };
                return new MDCListFoundation(adapter);
            };
            MDCList.prototype.getListItemIndex_ = function(evt) {
                var eventTarget = evt.target;
                var nearestParent = closest(eventTarget, "." + list_constants_cssClasses.LIST_ITEM_CLASS + ", ." + list_constants_cssClasses.ROOT);
                if (nearestParent && matches(nearestParent, "." + list_constants_cssClasses.LIST_ITEM_CLASS)) {
                    return this.listElements.indexOf(nearestParent);
                }
                return -1;
            };
            MDCList.prototype.handleFocusInEvent_ = function(evt) {
                var index = this.getListItemIndex_(evt);
                this.foundation.handleFocusIn(evt, index);
            };
            MDCList.prototype.handleFocusOutEvent_ = function(evt) {
                var index = this.getListItemIndex_(evt);
                this.foundation.handleFocusOut(evt, index);
            };
            MDCList.prototype.handleKeydownEvent_ = function(evt) {
                var index = this.getListItemIndex_(evt);
                var target = evt.target;
                this.foundation.handleKeydown(evt, target.classList.contains(list_constants_cssClasses.LIST_ITEM_CLASS), index);
            };
            MDCList.prototype.handleClickEvent_ = function(evt) {
                var index = this.getListItemIndex_(evt);
                var target = evt.target;
                var toggleCheckbox = !matches(target, list_constants_strings.CHECKBOX_RADIO_SELECTOR);
                this.foundation.handleClick(index, toggleCheckbox);
            };
            return MDCList;
        }(MDCComponent);
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var menu_surface_constants_cssClasses = {
            ANCHOR: "mdc-menu-surface--anchor",
            ANIMATING_CLOSED: "mdc-menu-surface--animating-closed",
            ANIMATING_OPEN: "mdc-menu-surface--animating-open",
            FIXED: "mdc-menu-surface--fixed",
            IS_OPEN_BELOW: "mdc-menu-surface--is-open-below",
            OPEN: "mdc-menu-surface--open",
            ROOT: "mdc-menu-surface"
        };
        var menu_surface_constants_strings = {
            CLOSED_EVENT: "MDCMenuSurface:closed",
            OPENED_EVENT: "MDCMenuSurface:opened",
            FOCUSABLE_ELEMENTS: [ "button:not(:disabled)", '[href]:not([aria-disabled="true"])', "input:not(:disabled)", "select:not(:disabled)", "textarea:not(:disabled)", '[tabindex]:not([tabindex="-1"]):not([aria-disabled="true"])' ].join(", ")
        };
        var menu_surface_constants_numbers = {
            TRANSITION_OPEN_DURATION: 120,
            TRANSITION_CLOSE_DURATION: 75,
            MARGIN_TO_EDGE: 32,
            ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: .67
        };
        var CornerBit;
        (function(CornerBit) {
            CornerBit[CornerBit["BOTTOM"] = 1] = "BOTTOM";
            CornerBit[CornerBit["CENTER"] = 2] = "CENTER";
            CornerBit[CornerBit["RIGHT"] = 4] = "RIGHT";
            CornerBit[CornerBit["FLIP_RTL"] = 8] = "FLIP_RTL";
        })(CornerBit || (CornerBit = {}));
        var Corner;
        (function(Corner) {
            Corner[Corner["TOP_LEFT"] = 0] = "TOP_LEFT";
            Corner[Corner["TOP_RIGHT"] = 4] = "TOP_RIGHT";
            Corner[Corner["BOTTOM_LEFT"] = 1] = "BOTTOM_LEFT";
            Corner[Corner["BOTTOM_RIGHT"] = 5] = "BOTTOM_RIGHT";
            Corner[Corner["TOP_START"] = 8] = "TOP_START";
            Corner[Corner["TOP_END"] = 12] = "TOP_END";
            Corner[Corner["BOTTOM_START"] = 9] = "BOTTOM_START";
            Corner[Corner["BOTTOM_END"] = 13] = "BOTTOM_END";
        })(Corner || (Corner = {}));
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCMenuSurfaceFoundation = function(_super) {
            __extends(MDCMenuSurfaceFoundation, _super);
            function MDCMenuSurfaceFoundation(adapter) {
                var _this = _super.call(this, __assign(__assign({}, MDCMenuSurfaceFoundation.defaultAdapter), adapter)) || this;
                _this.isSurfaceOpen = false;
                _this.isQuickOpen = false;
                _this.isHoistedElement = false;
                _this.isFixedPosition = false;
                _this.openAnimationEndTimerId = 0;
                _this.closeAnimationEndTimerId = 0;
                _this.animationRequestId = 0;
                _this.anchorCorner = Corner.TOP_START;
                _this.originCorner = Corner.TOP_START;
                _this.anchorMargin = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                };
                _this.position = {
                    x: 0,
                    y: 0
                };
                return _this;
            }
            Object.defineProperty(MDCMenuSurfaceFoundation, "cssClasses", {
                get: function() {
                    return menu_surface_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCMenuSurfaceFoundation, "strings", {
                get: function() {
                    return menu_surface_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCMenuSurfaceFoundation, "numbers", {
                get: function() {
                    return menu_surface_constants_numbers;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCMenuSurfaceFoundation, "Corner", {
                get: function() {
                    return Corner;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCMenuSurfaceFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClass: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        hasClass: function() {
                            return false;
                        },
                        hasAnchor: function() {
                            return false;
                        },
                        isElementInContainer: function() {
                            return false;
                        },
                        isFocused: function() {
                            return false;
                        },
                        isRtl: function() {
                            return false;
                        },
                        getInnerDimensions: function() {
                            return {
                                height: 0,
                                width: 0
                            };
                        },
                        getAnchorDimensions: function() {
                            return null;
                        },
                        getWindowDimensions: function() {
                            return {
                                height: 0,
                                width: 0
                            };
                        },
                        getBodyDimensions: function() {
                            return {
                                height: 0,
                                width: 0
                            };
                        },
                        getWindowScroll: function() {
                            return {
                                x: 0,
                                y: 0
                            };
                        },
                        setPosition: function() {
                            return undefined;
                        },
                        setMaxHeight: function() {
                            return undefined;
                        },
                        setTransformOrigin: function() {
                            return undefined;
                        },
                        saveFocus: function() {
                            return undefined;
                        },
                        restoreFocus: function() {
                            return undefined;
                        },
                        notifyClose: function() {
                            return undefined;
                        },
                        notifyOpen: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCMenuSurfaceFoundation.prototype.init = function() {
                var _a = MDCMenuSurfaceFoundation.cssClasses, ROOT = _a.ROOT, OPEN = _a.OPEN;
                if (!this.adapter.hasClass(ROOT)) {
                    throw new Error(ROOT + " class required in root element.");
                }
                if (this.adapter.hasClass(OPEN)) {
                    this.isSurfaceOpen = true;
                }
            };
            MDCMenuSurfaceFoundation.prototype.destroy = function() {
                clearTimeout(this.openAnimationEndTimerId);
                clearTimeout(this.closeAnimationEndTimerId);
                cancelAnimationFrame(this.animationRequestId);
            };
            MDCMenuSurfaceFoundation.prototype.setAnchorCorner = function(corner) {
                this.anchorCorner = corner;
            };
            MDCMenuSurfaceFoundation.prototype.flipCornerHorizontally = function() {
                this.originCorner = this.originCorner ^ CornerBit.RIGHT;
            };
            MDCMenuSurfaceFoundation.prototype.setAnchorMargin = function(margin) {
                this.anchorMargin.top = margin.top || 0;
                this.anchorMargin.right = margin.right || 0;
                this.anchorMargin.bottom = margin.bottom || 0;
                this.anchorMargin.left = margin.left || 0;
            };
            MDCMenuSurfaceFoundation.prototype.setIsHoisted = function(isHoisted) {
                this.isHoistedElement = isHoisted;
            };
            MDCMenuSurfaceFoundation.prototype.setFixedPosition = function(isFixedPosition) {
                this.isFixedPosition = isFixedPosition;
            };
            MDCMenuSurfaceFoundation.prototype.setAbsolutePosition = function(x, y) {
                this.position.x = this.isFinite(x) ? x : 0;
                this.position.y = this.isFinite(y) ? y : 0;
            };
            MDCMenuSurfaceFoundation.prototype.setQuickOpen = function(quickOpen) {
                this.isQuickOpen = quickOpen;
            };
            MDCMenuSurfaceFoundation.prototype.isOpen = function() {
                return this.isSurfaceOpen;
            };
            MDCMenuSurfaceFoundation.prototype.open = function() {
                var _this = this;
                if (this.isSurfaceOpen) {
                    return;
                }
                this.adapter.saveFocus();
                if (this.isQuickOpen) {
                    this.isSurfaceOpen = true;
                    this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
                    this.dimensions = this.adapter.getInnerDimensions();
                    this.autoposition();
                    this.adapter.notifyOpen();
                } else {
                    this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);
                    this.animationRequestId = requestAnimationFrame((function() {
                        _this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
                        _this.dimensions = _this.adapter.getInnerDimensions();
                        _this.autoposition();
                        _this.openAnimationEndTimerId = setTimeout((function() {
                            _this.openAnimationEndTimerId = 0;
                            _this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);
                            _this.adapter.notifyOpen();
                        }), menu_surface_constants_numbers.TRANSITION_OPEN_DURATION);
                    }));
                    this.isSurfaceOpen = true;
                }
            };
            MDCMenuSurfaceFoundation.prototype.close = function(skipRestoreFocus) {
                var _this = this;
                if (skipRestoreFocus === void 0) {
                    skipRestoreFocus = false;
                }
                if (!this.isSurfaceOpen) {
                    return;
                }
                if (this.isQuickOpen) {
                    this.isSurfaceOpen = false;
                    if (!skipRestoreFocus) {
                        this.maybeRestoreFocus();
                    }
                    this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
                    this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW);
                    this.adapter.notifyClose();
                } else {
                    this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);
                    requestAnimationFrame((function() {
                        _this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
                        _this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW);
                        _this.closeAnimationEndTimerId = setTimeout((function() {
                            _this.closeAnimationEndTimerId = 0;
                            _this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);
                            _this.adapter.notifyClose();
                        }), menu_surface_constants_numbers.TRANSITION_CLOSE_DURATION);
                    }));
                    this.isSurfaceOpen = false;
                    if (!skipRestoreFocus) {
                        this.maybeRestoreFocus();
                    }
                }
            };
            MDCMenuSurfaceFoundation.prototype.handleBodyClick = function(evt) {
                var el = evt.target;
                if (this.adapter.isElementInContainer(el)) {
                    return;
                }
                this.close();
            };
            MDCMenuSurfaceFoundation.prototype.handleKeydown = function(evt) {
                var keyCode = evt.keyCode, key = evt.key;
                var isEscape = key === "Escape" || keyCode === 27;
                if (isEscape) {
                    this.close();
                }
            };
            MDCMenuSurfaceFoundation.prototype.autoposition = function() {
                var _a;
                this.measurements = this.getAutoLayoutmeasurements();
                var corner = this.getoriginCorner();
                var maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight(corner);
                var verticalAlignment = this.hasBit(corner, CornerBit.BOTTOM) ? "bottom" : "top";
                var horizontalAlignment = this.hasBit(corner, CornerBit.RIGHT) ? "right" : "left";
                var horizontalOffset = this.getHorizontalOriginOffset(corner);
                var verticalOffset = this.getVerticalOriginOffset(corner);
                var _b = this.measurements, anchorSize = _b.anchorSize, surfaceSize = _b.surfaceSize;
                var position = (_a = {}, _a[horizontalAlignment] = horizontalOffset, _a[verticalAlignment] = verticalOffset, 
                _a);
                if (anchorSize.width / surfaceSize.width > menu_surface_constants_numbers.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {
                    horizontalAlignment = "center";
                }
                if (this.isHoistedElement || this.isFixedPosition) {
                    this.adjustPositionForHoistedElement(position);
                }
                this.adapter.setTransformOrigin(horizontalAlignment + " " + verticalAlignment);
                this.adapter.setPosition(position);
                this.adapter.setMaxHeight(maxMenuSurfaceHeight ? maxMenuSurfaceHeight + "px" : "");
                if (!this.hasBit(corner, CornerBit.BOTTOM)) {
                    this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW);
                }
            };
            MDCMenuSurfaceFoundation.prototype.getAutoLayoutmeasurements = function() {
                var anchorRect = this.adapter.getAnchorDimensions();
                var bodySize = this.adapter.getBodyDimensions();
                var viewportSize = this.adapter.getWindowDimensions();
                var windowScroll = this.adapter.getWindowScroll();
                if (!anchorRect) {
                    anchorRect = {
                        top: this.position.y,
                        right: this.position.x,
                        bottom: this.position.y,
                        left: this.position.x,
                        width: 0,
                        height: 0
                    };
                }
                return {
                    anchorSize: anchorRect,
                    bodySize: bodySize,
                    surfaceSize: this.dimensions,
                    viewportDistance: {
                        top: anchorRect.top,
                        right: viewportSize.width - anchorRect.right,
                        bottom: viewportSize.height - anchorRect.bottom,
                        left: anchorRect.left
                    },
                    viewportSize: viewportSize,
                    windowScroll: windowScroll
                };
            };
            MDCMenuSurfaceFoundation.prototype.getoriginCorner = function() {
                var corner = this.originCorner;
                var _a = this.measurements, viewportDistance = _a.viewportDistance, anchorSize = _a.anchorSize, surfaceSize = _a.surfaceSize;
                var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation.numbers.MARGIN_TO_EDGE;
                var isAnchoredToBottom = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
                var availableTop;
                var availableBottom;
                if (isAnchoredToBottom) {
                    availableTop = viewportDistance.top - MARGIN_TO_EDGE + anchorSize.height + this.anchorMargin.bottom;
                    availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE - this.anchorMargin.bottom;
                } else {
                    availableTop = viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.top;
                    availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE + anchorSize.height - this.anchorMargin.top;
                }
                var isAvailableBottom = availableBottom - surfaceSize.height > 0;
                if (!isAvailableBottom && availableTop >= availableBottom) {
                    corner = this.setBit(corner, CornerBit.BOTTOM);
                }
                var isRtl = this.adapter.isRtl();
                var isFlipRtl = this.hasBit(this.anchorCorner, CornerBit.FLIP_RTL);
                var hasRightBit = this.hasBit(this.anchorCorner, CornerBit.RIGHT) || this.hasBit(corner, CornerBit.RIGHT);
                var isAnchoredToRight = false;
                if (isRtl && isFlipRtl) {
                    isAnchoredToRight = !hasRightBit;
                } else {
                    isAnchoredToRight = hasRightBit;
                }
                var availableLeft;
                var availableRight;
                if (isAnchoredToRight) {
                    availableLeft = viewportDistance.left + anchorSize.width + this.anchorMargin.right;
                    availableRight = viewportDistance.right - this.anchorMargin.right;
                } else {
                    availableLeft = viewportDistance.left + this.anchorMargin.left;
                    availableRight = viewportDistance.right + anchorSize.width - this.anchorMargin.left;
                }
                var isAvailableLeft = availableLeft - surfaceSize.width > 0;
                var isAvailableRight = availableRight - surfaceSize.width > 0;
                var isOriginCornerAlignedToEnd = this.hasBit(corner, CornerBit.FLIP_RTL) && this.hasBit(corner, CornerBit.RIGHT);
                if (isAvailableRight && isOriginCornerAlignedToEnd && isRtl || !isAvailableLeft && isOriginCornerAlignedToEnd) {
                    corner = this.unsetBit(corner, CornerBit.RIGHT);
                } else if (isAvailableLeft && isAnchoredToRight && isRtl || isAvailableLeft && !isAnchoredToRight && hasRightBit || !isAvailableRight && availableLeft >= availableRight) {
                    corner = this.setBit(corner, CornerBit.RIGHT);
                }
                return corner;
            };
            MDCMenuSurfaceFoundation.prototype.getMenuSurfaceMaxHeight = function(corner) {
                var viewportDistance = this.measurements.viewportDistance;
                var maxHeight = 0;
                var isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);
                var isBottomAnchored = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
                var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation.numbers.MARGIN_TO_EDGE;
                if (isBottomAligned) {
                    maxHeight = viewportDistance.top + this.anchorMargin.top - MARGIN_TO_EDGE;
                    if (!isBottomAnchored) {
                        maxHeight += this.measurements.anchorSize.height;
                    }
                } else {
                    maxHeight = viewportDistance.bottom - this.anchorMargin.bottom + this.measurements.anchorSize.height - MARGIN_TO_EDGE;
                    if (isBottomAnchored) {
                        maxHeight -= this.measurements.anchorSize.height;
                    }
                }
                return maxHeight;
            };
            MDCMenuSurfaceFoundation.prototype.getHorizontalOriginOffset = function(corner) {
                var anchorSize = this.measurements.anchorSize;
                var isRightAligned = this.hasBit(corner, CornerBit.RIGHT);
                var avoidHorizontalOverlap = this.hasBit(this.anchorCorner, CornerBit.RIGHT);
                if (isRightAligned) {
                    var rightOffset = avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin.left : this.anchorMargin.right;
                    if (this.isHoistedElement || this.isFixedPosition) {
                        return rightOffset - (this.measurements.viewportSize.width - this.measurements.bodySize.width);
                    }
                    return rightOffset;
                }
                return avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin.right : this.anchorMargin.left;
            };
            MDCMenuSurfaceFoundation.prototype.getVerticalOriginOffset = function(corner) {
                var anchorSize = this.measurements.anchorSize;
                var isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);
                var avoidVerticalOverlap = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
                var y = 0;
                if (isBottomAligned) {
                    y = avoidVerticalOverlap ? anchorSize.height - this.anchorMargin.top : -this.anchorMargin.bottom;
                } else {
                    y = avoidVerticalOverlap ? anchorSize.height + this.anchorMargin.bottom : this.anchorMargin.top;
                }
                return y;
            };
            MDCMenuSurfaceFoundation.prototype.adjustPositionForHoistedElement = function(position) {
                var e_1, _a;
                var _b = this.measurements, windowScroll = _b.windowScroll, viewportDistance = _b.viewportDistance;
                var props = Object.keys(position);
                try {
                    for (var props_1 = __values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {
                        var prop = props_1_1.value;
                        var value = position[prop] || 0;
                        value += viewportDistance[prop];
                        if (!this.isFixedPosition) {
                            if (prop === "top") {
                                value += windowScroll.y;
                            } else if (prop === "bottom") {
                                value -= windowScroll.y;
                            } else if (prop === "left") {
                                value += windowScroll.x;
                            } else {
                                value -= windowScroll.x;
                            }
                        }
                        position[prop] = value;
                    }
                } catch (e_1_1) {
                    e_1 = {
                        error: e_1_1
                    };
                } finally {
                    try {
                        if (props_1_1 && !props_1_1.done && (_a = props_1.return)) _a.call(props_1);
                    } finally {
                        if (e_1) throw e_1.error;
                    }
                }
            };
            MDCMenuSurfaceFoundation.prototype.maybeRestoreFocus = function() {
                var isRootFocused = this.adapter.isFocused();
                var childHasFocus = document.activeElement && this.adapter.isElementInContainer(document.activeElement);
                if (isRootFocused || childHasFocus) {
                    this.adapter.restoreFocus();
                }
            };
            MDCMenuSurfaceFoundation.prototype.hasBit = function(corner, bit) {
                return Boolean(corner & bit);
            };
            MDCMenuSurfaceFoundation.prototype.setBit = function(corner, bit) {
                return corner | bit;
            };
            MDCMenuSurfaceFoundation.prototype.unsetBit = function(corner, bit) {
                return corner ^ bit;
            };
            MDCMenuSurfaceFoundation.prototype.isFinite = function(num) {
                return typeof num === "number" && isFinite(num);
            };
            return MDCMenuSurfaceFoundation;
        }(MDCFoundation);
        const menu_surface_foundation = null && MDCMenuSurfaceFoundation;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var cachedCssTransformPropertyName_;
        function getTransformPropertyName(globalObj, forceRefresh) {
            if (forceRefresh === void 0) {
                forceRefresh = false;
            }
            if (cachedCssTransformPropertyName_ === undefined || forceRefresh) {
                var el = globalObj.document.createElement("div");
                cachedCssTransformPropertyName_ = "transform" in el.style ? "transform" : "webkitTransform";
            }
            return cachedCssTransformPropertyName_;
        }
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCMenuSurface = function(_super) {
            __extends(MDCMenuSurface, _super);
            function MDCMenuSurface() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCMenuSurface.attachTo = function(root) {
                return new MDCMenuSurface(root);
            };
            MDCMenuSurface.prototype.initialSyncWithDOM = function() {
                var _this = this;
                var parentEl = this.root.parentElement;
                this.anchorElement = parentEl && parentEl.classList.contains(menu_surface_constants_cssClasses.ANCHOR) ? parentEl : null;
                if (this.root.classList.contains(menu_surface_constants_cssClasses.FIXED)) {
                    this.setFixedPosition(true);
                }
                this.handleKeydown = function(event) {
                    _this.foundation.handleKeydown(event);
                };
                this.handleBodyClick = function(event) {
                    _this.foundation.handleBodyClick(event);
                };
                this.registerBodyClickListener = function() {
                    document.body.addEventListener("click", _this.handleBodyClick, {
                        capture: true
                    });
                };
                this.deregisterBodyClickListener = function() {
                    document.body.removeEventListener("click", _this.handleBodyClick, {
                        capture: true
                    });
                };
                this.listen("keydown", this.handleKeydown);
                this.listen(menu_surface_constants_strings.OPENED_EVENT, this.registerBodyClickListener);
                this.listen(menu_surface_constants_strings.CLOSED_EVENT, this.deregisterBodyClickListener);
            };
            MDCMenuSurface.prototype.destroy = function() {
                this.unlisten("keydown", this.handleKeydown);
                this.unlisten(menu_surface_constants_strings.OPENED_EVENT, this.registerBodyClickListener);
                this.unlisten(menu_surface_constants_strings.CLOSED_EVENT, this.deregisterBodyClickListener);
                _super.prototype.destroy.call(this);
            };
            MDCMenuSurface.prototype.isOpen = function() {
                return this.foundation.isOpen();
            };
            MDCMenuSurface.prototype.open = function() {
                this.foundation.open();
            };
            MDCMenuSurface.prototype.close = function(skipRestoreFocus) {
                if (skipRestoreFocus === void 0) {
                    skipRestoreFocus = false;
                }
                this.foundation.close(skipRestoreFocus);
            };
            Object.defineProperty(MDCMenuSurface.prototype, "quickOpen", {
                set: function(quickOpen) {
                    this.foundation.setQuickOpen(quickOpen);
                },
                enumerable: true,
                configurable: true
            });
            MDCMenuSurface.prototype.setIsHoisted = function(isHoisted) {
                this.foundation.setIsHoisted(isHoisted);
            };
            MDCMenuSurface.prototype.setMenuSurfaceAnchorElement = function(element) {
                this.anchorElement = element;
            };
            MDCMenuSurface.prototype.setFixedPosition = function(isFixed) {
                if (isFixed) {
                    this.root.classList.add(menu_surface_constants_cssClasses.FIXED);
                } else {
                    this.root.classList.remove(menu_surface_constants_cssClasses.FIXED);
                }
                this.foundation.setFixedPosition(isFixed);
            };
            MDCMenuSurface.prototype.setAbsolutePosition = function(x, y) {
                this.foundation.setAbsolutePosition(x, y);
                this.setIsHoisted(true);
            };
            MDCMenuSurface.prototype.setAnchorCorner = function(corner) {
                this.foundation.setAnchorCorner(corner);
            };
            MDCMenuSurface.prototype.setAnchorMargin = function(margin) {
                this.foundation.setAnchorMargin(margin);
            };
            MDCMenuSurface.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    addClass: function(className) {
                        return _this.root.classList.add(className);
                    },
                    removeClass: function(className) {
                        return _this.root.classList.remove(className);
                    },
                    hasClass: function(className) {
                        return _this.root.classList.contains(className);
                    },
                    hasAnchor: function() {
                        return !!_this.anchorElement;
                    },
                    notifyClose: function() {
                        return _this.emit(MDCMenuSurfaceFoundation.strings.CLOSED_EVENT, {});
                    },
                    notifyOpen: function() {
                        return _this.emit(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, {});
                    },
                    isElementInContainer: function(el) {
                        return _this.root.contains(el);
                    },
                    isRtl: function() {
                        return getComputedStyle(_this.root).getPropertyValue("direction") === "rtl";
                    },
                    setTransformOrigin: function(origin) {
                        var propertyName = getTransformPropertyName(window) + "-origin";
                        _this.root.style.setProperty(propertyName, origin);
                    },
                    isFocused: function() {
                        return document.activeElement === _this.root;
                    },
                    saveFocus: function() {
                        _this.previousFocus = document.activeElement;
                    },
                    restoreFocus: function() {
                        if (_this.root.contains(document.activeElement)) {
                            if (_this.previousFocus && _this.previousFocus.focus) {
                                _this.previousFocus.focus();
                            }
                        }
                    },
                    getInnerDimensions: function() {
                        return {
                            width: _this.root.offsetWidth,
                            height: _this.root.offsetHeight
                        };
                    },
                    getAnchorDimensions: function() {
                        return _this.anchorElement ? _this.anchorElement.getBoundingClientRect() : null;
                    },
                    getWindowDimensions: function() {
                        return {
                            width: window.innerWidth,
                            height: window.innerHeight
                        };
                    },
                    getBodyDimensions: function() {
                        return {
                            width: document.body.clientWidth,
                            height: document.body.clientHeight
                        };
                    },
                    getWindowScroll: function() {
                        return {
                            x: window.pageXOffset,
                            y: window.pageYOffset
                        };
                    },
                    setPosition: function(position) {
                        var rootHTML = _this.root;
                        rootHTML.style.left = "left" in position ? position.left + "px" : "";
                        rootHTML.style.right = "right" in position ? position.right + "px" : "";
                        rootHTML.style.top = "top" in position ? position.top + "px" : "";
                        rootHTML.style.bottom = "bottom" in position ? position.bottom + "px" : "";
                    },
                    setMaxHeight: function(height) {
                        _this.root.style.maxHeight = height;
                    }
                };
                return new MDCMenuSurfaceFoundation(adapter);
            };
            return MDCMenuSurface;
        }(MDCComponent);
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var menu_constants_cssClasses = {
            MENU_SELECTED_LIST_ITEM: "mdc-menu-item--selected",
            MENU_SELECTION_GROUP: "mdc-menu__selection-group",
            ROOT: "mdc-menu"
        };
        var menu_constants_strings = {
            ARIA_CHECKED_ATTR: "aria-checked",
            ARIA_DISABLED_ATTR: "aria-disabled",
            CHECKBOX_SELECTOR: 'input[type="checkbox"]',
            LIST_SELECTOR: ".mdc-list",
            SELECTED_EVENT: "MDCMenu:selected"
        };
        var menu_constants_numbers = {
            FOCUS_ROOT_INDEX: -1
        };
        var DefaultFocusState;
        (function(DefaultFocusState) {
            DefaultFocusState[DefaultFocusState["NONE"] = 0] = "NONE";
            DefaultFocusState[DefaultFocusState["LIST_ROOT"] = 1] = "LIST_ROOT";
            DefaultFocusState[DefaultFocusState["FIRST_ITEM"] = 2] = "FIRST_ITEM";
            DefaultFocusState[DefaultFocusState["LAST_ITEM"] = 3] = "LAST_ITEM";
        })(DefaultFocusState || (DefaultFocusState = {}));
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCMenuFoundation = function(_super) {
            __extends(MDCMenuFoundation, _super);
            function MDCMenuFoundation(adapter) {
                var _this = _super.call(this, __assign(__assign({}, MDCMenuFoundation.defaultAdapter), adapter)) || this;
                _this.closeAnimationEndTimerId_ = 0;
                _this.defaultFocusState_ = DefaultFocusState.LIST_ROOT;
                return _this;
            }
            Object.defineProperty(MDCMenuFoundation, "cssClasses", {
                get: function() {
                    return menu_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCMenuFoundation, "strings", {
                get: function() {
                    return menu_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCMenuFoundation, "numbers", {
                get: function() {
                    return menu_constants_numbers;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCMenuFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClassToElementAtIndex: function() {
                            return undefined;
                        },
                        removeClassFromElementAtIndex: function() {
                            return undefined;
                        },
                        addAttributeToElementAtIndex: function() {
                            return undefined;
                        },
                        removeAttributeFromElementAtIndex: function() {
                            return undefined;
                        },
                        elementContainsClass: function() {
                            return false;
                        },
                        closeSurface: function() {
                            return undefined;
                        },
                        getElementIndex: function() {
                            return -1;
                        },
                        notifySelected: function() {
                            return undefined;
                        },
                        getMenuItemCount: function() {
                            return 0;
                        },
                        focusItemAtIndex: function() {
                            return undefined;
                        },
                        focusListRoot: function() {
                            return undefined;
                        },
                        getSelectedSiblingOfItemAtIndex: function() {
                            return -1;
                        },
                        isSelectableItemAtIndex: function() {
                            return false;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCMenuFoundation.prototype.destroy = function() {
                if (this.closeAnimationEndTimerId_) {
                    clearTimeout(this.closeAnimationEndTimerId_);
                }
                this.adapter.closeSurface();
            };
            MDCMenuFoundation.prototype.handleKeydown = function(evt) {
                var key = evt.key, keyCode = evt.keyCode;
                var isTab = key === "Tab" || keyCode === 9;
                if (isTab) {
                    this.adapter.closeSurface(true);
                }
            };
            MDCMenuFoundation.prototype.handleItemAction = function(listItem) {
                var _this = this;
                var index = this.adapter.getElementIndex(listItem);
                if (index < 0) {
                    return;
                }
                this.adapter.notifySelected({
                    index: index
                });
                this.adapter.closeSurface();
                this.closeAnimationEndTimerId_ = setTimeout((function() {
                    var recomputedIndex = _this.adapter.getElementIndex(listItem);
                    if (recomputedIndex >= 0 && _this.adapter.isSelectableItemAtIndex(recomputedIndex)) {
                        _this.setSelectedIndex(recomputedIndex);
                    }
                }), MDCMenuSurfaceFoundation.numbers.TRANSITION_CLOSE_DURATION);
            };
            MDCMenuFoundation.prototype.handleMenuSurfaceOpened = function() {
                switch (this.defaultFocusState_) {
                  case DefaultFocusState.FIRST_ITEM:
                    this.adapter.focusItemAtIndex(0);
                    break;

                  case DefaultFocusState.LAST_ITEM:
                    this.adapter.focusItemAtIndex(this.adapter.getMenuItemCount() - 1);
                    break;

                  case DefaultFocusState.NONE:
                    break;

                  default:
                    this.adapter.focusListRoot();
                    break;
                }
            };
            MDCMenuFoundation.prototype.setDefaultFocusState = function(focusState) {
                this.defaultFocusState_ = focusState;
            };
            MDCMenuFoundation.prototype.setSelectedIndex = function(index) {
                this.validatedIndex_(index);
                if (!this.adapter.isSelectableItemAtIndex(index)) {
                    throw new Error("MDCMenuFoundation: No selection group at specified index.");
                }
                var prevSelectedIndex = this.adapter.getSelectedSiblingOfItemAtIndex(index);
                if (prevSelectedIndex >= 0) {
                    this.adapter.removeAttributeFromElementAtIndex(prevSelectedIndex, menu_constants_strings.ARIA_CHECKED_ATTR);
                    this.adapter.removeClassFromElementAtIndex(prevSelectedIndex, menu_constants_cssClasses.MENU_SELECTED_LIST_ITEM);
                }
                this.adapter.addClassToElementAtIndex(index, menu_constants_cssClasses.MENU_SELECTED_LIST_ITEM);
                this.adapter.addAttributeToElementAtIndex(index, menu_constants_strings.ARIA_CHECKED_ATTR, "true");
            };
            MDCMenuFoundation.prototype.setEnabled = function(index, isEnabled) {
                this.validatedIndex_(index);
                if (isEnabled) {
                    this.adapter.removeClassFromElementAtIndex(index, list_constants_cssClasses.LIST_ITEM_DISABLED_CLASS);
                    this.adapter.addAttributeToElementAtIndex(index, menu_constants_strings.ARIA_DISABLED_ATTR, "false");
                } else {
                    this.adapter.addClassToElementAtIndex(index, list_constants_cssClasses.LIST_ITEM_DISABLED_CLASS);
                    this.adapter.addAttributeToElementAtIndex(index, menu_constants_strings.ARIA_DISABLED_ATTR, "true");
                }
            };
            MDCMenuFoundation.prototype.validatedIndex_ = function(index) {
                var menuSize = this.adapter.getMenuItemCount();
                var isIndexInRange = index >= 0 && index < menuSize;
                if (!isIndexInRange) {
                    throw new Error("MDCMenuFoundation: No list item at specified index.");
                }
            };
            return MDCMenuFoundation;
        }(MDCFoundation);
        const menu_foundation = null && MDCMenuFoundation;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCMenu = function(_super) {
            __extends(MDCMenu, _super);
            function MDCMenu() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCMenu.attachTo = function(root) {
                return new MDCMenu(root);
            };
            MDCMenu.prototype.initialize = function(menuSurfaceFactory, listFactory) {
                if (menuSurfaceFactory === void 0) {
                    menuSurfaceFactory = function(el) {
                        return new MDCMenuSurface(el);
                    };
                }
                if (listFactory === void 0) {
                    listFactory = function(el) {
                        return new MDCList(el);
                    };
                }
                this.menuSurfaceFactory_ = menuSurfaceFactory;
                this.listFactory_ = listFactory;
            };
            MDCMenu.prototype.initialSyncWithDOM = function() {
                var _this = this;
                this.menuSurface_ = this.menuSurfaceFactory_(this.root);
                var list = this.root.querySelector(menu_constants_strings.LIST_SELECTOR);
                if (list) {
                    this.list_ = this.listFactory_(list);
                    this.list_.wrapFocus = true;
                } else {
                    this.list_ = null;
                }
                this.handleKeydown_ = function(evt) {
                    return _this.foundation.handleKeydown(evt);
                };
                this.handleItemAction_ = function(evt) {
                    return _this.foundation.handleItemAction(_this.items[evt.detail.index]);
                };
                this.handleMenuSurfaceOpened_ = function() {
                    return _this.foundation.handleMenuSurfaceOpened();
                };
                this.menuSurface_.listen(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, this.handleMenuSurfaceOpened_);
                this.listen("keydown", this.handleKeydown_);
                this.listen(MDCListFoundation.strings.ACTION_EVENT, this.handleItemAction_);
            };
            MDCMenu.prototype.destroy = function() {
                if (this.list_) {
                    this.list_.destroy();
                }
                this.menuSurface_.destroy();
                this.menuSurface_.unlisten(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, this.handleMenuSurfaceOpened_);
                this.unlisten("keydown", this.handleKeydown_);
                this.unlisten(MDCListFoundation.strings.ACTION_EVENT, this.handleItemAction_);
                _super.prototype.destroy.call(this);
            };
            Object.defineProperty(MDCMenu.prototype, "open", {
                get: function() {
                    return this.menuSurface_.isOpen();
                },
                set: function(value) {
                    if (value) {
                        this.menuSurface_.open();
                    } else {
                        this.menuSurface_.close();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCMenu.prototype, "wrapFocus", {
                get: function() {
                    return this.list_ ? this.list_.wrapFocus : false;
                },
                set: function(value) {
                    if (this.list_) {
                        this.list_.wrapFocus = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCMenu.prototype, "hasTypeahead", {
                set: function(value) {
                    if (this.list_) {
                        this.list_.hasTypeahead = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCMenu.prototype, "typeaheadInProgress", {
                get: function() {
                    return this.list_ ? this.list_.typeaheadInProgress : false;
                },
                enumerable: true,
                configurable: true
            });
            MDCMenu.prototype.typeaheadMatchItem = function(nextChar, startingIndex) {
                if (this.list_) {
                    return this.list_.typeaheadMatchItem(nextChar, startingIndex);
                }
                return -1;
            };
            MDCMenu.prototype.layout = function() {
                if (this.list_) {
                    this.list_.layout();
                }
            };
            Object.defineProperty(MDCMenu.prototype, "items", {
                get: function() {
                    return this.list_ ? this.list_.listElements : [];
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCMenu.prototype, "singleSelection", {
                set: function(singleSelection) {
                    if (this.list_) {
                        this.list_.singleSelection = singleSelection;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCMenu.prototype, "selectedIndex", {
                get: function() {
                    return this.list_ ? this.list_.selectedIndex : list_constants_numbers.UNSET_INDEX;
                },
                set: function(index) {
                    if (this.list_) {
                        this.list_.selectedIndex = index;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCMenu.prototype, "quickOpen", {
                set: function(quickOpen) {
                    this.menuSurface_.quickOpen = quickOpen;
                },
                enumerable: true,
                configurable: true
            });
            MDCMenu.prototype.setDefaultFocusState = function(focusState) {
                this.foundation.setDefaultFocusState(focusState);
            };
            MDCMenu.prototype.setAnchorCorner = function(corner) {
                this.menuSurface_.setAnchorCorner(corner);
            };
            MDCMenu.prototype.setAnchorMargin = function(margin) {
                this.menuSurface_.setAnchorMargin(margin);
            };
            MDCMenu.prototype.setSelectedIndex = function(index) {
                this.foundation.setSelectedIndex(index);
            };
            MDCMenu.prototype.setEnabled = function(index, isEnabled) {
                this.foundation.setEnabled(index, isEnabled);
            };
            MDCMenu.prototype.getOptionByIndex = function(index) {
                var items = this.items;
                if (index < items.length) {
                    return this.items[index];
                } else {
                    return null;
                }
            };
            MDCMenu.prototype.getPrimaryTextAtIndex = function(index) {
                var item = this.getOptionByIndex(index);
                if (item && this.list_) {
                    return this.list_.getPrimaryText(item) || "";
                }
                return "";
            };
            MDCMenu.prototype.setFixedPosition = function(isFixed) {
                this.menuSurface_.setFixedPosition(isFixed);
            };
            MDCMenu.prototype.setIsHoisted = function(isHoisted) {
                this.menuSurface_.setIsHoisted(isHoisted);
            };
            MDCMenu.prototype.setAbsolutePosition = function(x, y) {
                this.menuSurface_.setAbsolutePosition(x, y);
            };
            MDCMenu.prototype.setAnchorElement = function(element) {
                this.menuSurface_.anchorElement = element;
            };
            MDCMenu.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    addClassToElementAtIndex: function(index, className) {
                        var list = _this.items;
                        list[index].classList.add(className);
                    },
                    removeClassFromElementAtIndex: function(index, className) {
                        var list = _this.items;
                        list[index].classList.remove(className);
                    },
                    addAttributeToElementAtIndex: function(index, attr, value) {
                        var list = _this.items;
                        list[index].setAttribute(attr, value);
                    },
                    removeAttributeFromElementAtIndex: function(index, attr) {
                        var list = _this.items;
                        list[index].removeAttribute(attr);
                    },
                    elementContainsClass: function(element, className) {
                        return element.classList.contains(className);
                    },
                    closeSurface: function(skipRestoreFocus) {
                        return _this.menuSurface_.close(skipRestoreFocus);
                    },
                    getElementIndex: function(element) {
                        return _this.items.indexOf(element);
                    },
                    notifySelected: function(evtData) {
                        return _this.emit(menu_constants_strings.SELECTED_EVENT, {
                            index: evtData.index,
                            item: _this.items[evtData.index]
                        });
                    },
                    getMenuItemCount: function() {
                        return _this.items.length;
                    },
                    focusItemAtIndex: function(index) {
                        return _this.items[index].focus();
                    },
                    focusListRoot: function() {
                        return _this.root.querySelector(menu_constants_strings.LIST_SELECTOR).focus();
                    },
                    isSelectableItemAtIndex: function(index) {
                        return !!closest(_this.items[index], "." + menu_constants_cssClasses.MENU_SELECTION_GROUP);
                    },
                    getSelectedSiblingOfItemAtIndex: function(index) {
                        var selectionGroupEl = closest(_this.items[index], "." + menu_constants_cssClasses.MENU_SELECTION_GROUP);
                        var selectedItemEl = selectionGroupEl.querySelector("." + menu_constants_cssClasses.MENU_SELECTED_LIST_ITEM);
                        return selectedItemEl ? _this.items.indexOf(selectedItemEl) : -1;
                    }
                };
                return new MDCMenuFoundation(adapter);
            };
            return MDCMenu;
        }(MDCComponent);
        function init(textElem, menuElem, dotNetObject) {
            textElem._textField = MDCTextField.attachTo(textElem);
            menuElem._menu = MDCMenu.attachTo(menuElem);
            menuElem._menu.foundation.handleItemAction = function(listItem) {
                menuElem._menu.open = false;
                dotNetObject.invokeMethodAsync("NotifySelected", listItem.innerText);
            };
            menuElem._menu.foundation.adapter.handleMenuSurfaceOpened = function() {
                menuElem._menu.foundation.setDefaultFocusState(0);
            };
            var closedCallback = function closedCallback() {
                dotNetObject.invokeMethodAsync("NotifyClosed");
            };
            menuElem._menu.listen("MDCMenuSurface:closed", closedCallback);
        }
        function MBAutocompleteTextField_open(menuElem) {
            menuElem._menu.open = true;
            menuElem._menu.foundation.setDefaultFocusState(0);
        }
        function MBAutocompleteTextField_close(menuElem) {
            menuElem._menu.open = false;
        }
        function setValue(textElem, value) {
            textElem._textField.value = value;
        }
        function setDisabled(textElem, disabled) {
            textElem._textField.disabled = disabled;
        }
        var regenerator = __webpack_require__(757);
        var regenerator_default = __webpack_require__.n(regenerator);
        var asyncToGenerator = __webpack_require__(926);
        var asyncToGenerator_default = __webpack_require__.n(asyncToGenerator);
        var fps = 60;
        var waitDelay = 1e3 / fps;
        function sleep(ms) {
            return new Promise((function(resolve) {
                return setTimeout(resolve, ms);
            }));
        }
        function openBlade(_x, _x2, _x3) {
            return _openBlade.apply(this, arguments);
        }
        function _openBlade() {
            _openBlade = asyncToGenerator_default()(regenerator_default().mark((function _callee(bladeElem, bladeContentElem, transitionMs) {
                var transition, bladeContentWidth, intervals, i;
                return regenerator_default().wrap((function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            transition = "width " + transitionMs + "ms";
                            bladeContentWidth = bladeContentElem.getBoundingClientRect().width;
                            bladeElem.style.transition = transition;
                            bladeElem.style.width = bladeContentWidth + "px";
                            bladeElem.scrollIntoView();
                            intervals = Math.ceil(transitionMs / waitDelay) + 1;
                            i = 0;

                          case 7:
                            if (!(i < intervals)) {
                                _context.next = 14;
                                break;
                            }
                            _context.next = 10;
                            return sleep(waitDelay);

                          case 10:
                            bladeElem.scrollIntoView();

                          case 11:
                            i++;
                            _context.next = 7;
                            break;

                          case 14:
                          case "end":
                            return _context.stop();
                        }
                    }
                }), _callee);
            })));
            return _openBlade.apply(this, arguments);
        }
        function closeBlade(bladeElem) {
            bladeElem.style.width = "0px";
        }
        function MBButton_init(elem) {
            elem._ripple = MDCRipple.attachTo(elem);
        }
        function MBCard_init(elem) {
            elem._ripple = MDCRipple.attachTo(elem);
        }
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var AnnouncerPriority;
        (function(AnnouncerPriority) {
            AnnouncerPriority["POLITE"] = "polite";
            AnnouncerPriority["ASSERTIVE"] = "assertive";
        })(AnnouncerPriority || (AnnouncerPriority = {}));
        var DATA_MDC_DOM_ANNOUNCE = "data-mdc-dom-announce";
        function announce(message, priority) {
            Announcer.getInstance().say(message, priority);
        }
        var Announcer = function() {
            function Announcer() {
                this.liveRegions = new Map;
            }
            Announcer.getInstance = function() {
                if (!Announcer.instance) {
                    Announcer.instance = new Announcer;
                }
                return Announcer.instance;
            };
            Announcer.prototype.say = function(message, priority) {
                if (priority === void 0) {
                    priority = AnnouncerPriority.POLITE;
                }
                var liveRegion = this.getLiveRegion(priority);
                liveRegion.textContent = "";
                setTimeout((function() {
                    liveRegion.textContent = message;
                    document.addEventListener("click", clearLiveRegion);
                }), 1);
                function clearLiveRegion() {
                    liveRegion.textContent = "";
                    document.removeEventListener("click", clearLiveRegion);
                }
            };
            Announcer.prototype.getLiveRegion = function(priority) {
                var existingLiveRegion = this.liveRegions.get(priority);
                if (existingLiveRegion && document.body.contains(existingLiveRegion)) {
                    return existingLiveRegion;
                }
                var liveRegion = this.createLiveRegion(priority);
                this.liveRegions.set(priority, liveRegion);
                return liveRegion;
            };
            Announcer.prototype.createLiveRegion = function(priority) {
                var el = document.createElement("div");
                el.style.position = "absolute";
                el.style.top = "-9999px";
                el.style.left = "-9999px";
                el.style.height = "1px";
                el.style.overflow = "hidden";
                el.setAttribute("aria-atomic", "true");
                el.setAttribute("aria-live", priority);
                el.setAttribute(DATA_MDC_DOM_ANNOUNCE, "true");
                document.body.appendChild(el);
                return el;
            };
            return Announcer;
        }();
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var InteractionTrigger;
        (function(InteractionTrigger) {
            InteractionTrigger[InteractionTrigger["UNSPECIFIED"] = 0] = "UNSPECIFIED";
            InteractionTrigger[InteractionTrigger["CLICK"] = 1] = "CLICK";
            InteractionTrigger[InteractionTrigger["BACKSPACE_KEY"] = 2] = "BACKSPACE_KEY";
            InteractionTrigger[InteractionTrigger["DELETE_KEY"] = 3] = "DELETE_KEY";
            InteractionTrigger[InteractionTrigger["SPACEBAR_KEY"] = 4] = "SPACEBAR_KEY";
            InteractionTrigger[InteractionTrigger["ENTER_KEY"] = 5] = "ENTER_KEY";
        })(InteractionTrigger || (InteractionTrigger = {}));
        var trailingaction_constants_strings = {
            ARIA_HIDDEN: "aria-hidden",
            INTERACTION_EVENT: "MDCChipTrailingAction:interaction",
            NAVIGATION_EVENT: "MDCChipTrailingAction:navigation",
            TAB_INDEX: "tabindex"
        };
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCChipTrailingActionFoundation = function(_super) {
            __extends(MDCChipTrailingActionFoundation, _super);
            function MDCChipTrailingActionFoundation(adapter) {
                return _super.call(this, __assign(__assign({}, MDCChipTrailingActionFoundation.defaultAdapter), adapter)) || this;
            }
            Object.defineProperty(MDCChipTrailingActionFoundation, "strings", {
                get: function() {
                    return trailingaction_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCChipTrailingActionFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        focus: function() {
                            return undefined;
                        },
                        getAttribute: function() {
                            return null;
                        },
                        setAttribute: function() {
                            return undefined;
                        },
                        notifyInteraction: function() {
                            return undefined;
                        },
                        notifyNavigation: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCChipTrailingActionFoundation.prototype.handleClick = function(evt) {
                evt.stopPropagation();
                this.adapter.notifyInteraction(InteractionTrigger.CLICK);
            };
            MDCChipTrailingActionFoundation.prototype.handleKeydown = function(evt) {
                evt.stopPropagation();
                var key = normalizeKey(evt);
                if (this.shouldNotifyInteractionFromKey_(key)) {
                    var trigger = this.getTriggerFromKey_(key);
                    this.adapter.notifyInteraction(trigger);
                    return;
                }
                if (isNavigationEvent(evt)) {
                    this.adapter.notifyNavigation(key);
                    return;
                }
            };
            MDCChipTrailingActionFoundation.prototype.removeFocus = function() {
                this.adapter.setAttribute(trailingaction_constants_strings.TAB_INDEX, "-1");
            };
            MDCChipTrailingActionFoundation.prototype.focus = function() {
                this.adapter.setAttribute(trailingaction_constants_strings.TAB_INDEX, "0");
                this.adapter.focus();
            };
            MDCChipTrailingActionFoundation.prototype.isNavigable = function() {
                return this.adapter.getAttribute(trailingaction_constants_strings.ARIA_HIDDEN) !== "true";
            };
            MDCChipTrailingActionFoundation.prototype.shouldNotifyInteractionFromKey_ = function(key) {
                var isFromActionKey = key === KEY.ENTER || key === KEY.SPACEBAR;
                var isFromDeleteKey = key === KEY.BACKSPACE || key === KEY.DELETE;
                return isFromActionKey || isFromDeleteKey;
            };
            MDCChipTrailingActionFoundation.prototype.getTriggerFromKey_ = function(key) {
                if (key === KEY.SPACEBAR) {
                    return InteractionTrigger.SPACEBAR_KEY;
                }
                if (key === KEY.ENTER) {
                    return InteractionTrigger.ENTER_KEY;
                }
                if (key === KEY.DELETE) {
                    return InteractionTrigger.DELETE_KEY;
                }
                if (key === KEY.BACKSPACE) {
                    return InteractionTrigger.BACKSPACE_KEY;
                }
                return InteractionTrigger.UNSPECIFIED;
            };
            return MDCChipTrailingActionFoundation;
        }(MDCFoundation);
        const trailingaction_foundation = null && MDCChipTrailingActionFoundation;
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCChipTrailingAction = function(_super) {
            __extends(MDCChipTrailingAction, _super);
            function MDCChipTrailingAction() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Object.defineProperty(MDCChipTrailingAction.prototype, "ripple", {
                get: function() {
                    return this.ripple_;
                },
                enumerable: true,
                configurable: true
            });
            MDCChipTrailingAction.attachTo = function(root) {
                return new MDCChipTrailingAction(root);
            };
            MDCChipTrailingAction.prototype.initialize = function(rippleFactory) {
                if (rippleFactory === void 0) {
                    rippleFactory = function(el, foundation) {
                        return new MDCRipple(el, foundation);
                    };
                }
                var rippleAdapter = MDCRipple.createAdapter(this);
                this.ripple_ = rippleFactory(this.root, new MDCRippleFoundation(rippleAdapter));
            };
            MDCChipTrailingAction.prototype.initialSyncWithDOM = function() {
                var _this = this;
                this.handleClick_ = function(evt) {
                    _this.foundation.handleClick(evt);
                };
                this.handleKeydown_ = function(evt) {
                    _this.foundation.handleKeydown(evt);
                };
                this.listen("click", this.handleClick_);
                this.listen("keydown", this.handleKeydown_);
            };
            MDCChipTrailingAction.prototype.destroy = function() {
                this.ripple_.destroy();
                this.unlisten("click", this.handleClick_);
                this.unlisten("keydown", this.handleKeydown_);
                _super.prototype.destroy.call(this);
            };
            MDCChipTrailingAction.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    focus: function() {
                        _this.root.focus();
                    },
                    getAttribute: function(attr) {
                        return _this.root.getAttribute(attr);
                    },
                    notifyInteraction: function(trigger) {
                        return _this.emit(trailingaction_constants_strings.INTERACTION_EVENT, {
                            trigger: trigger
                        }, true);
                    },
                    notifyNavigation: function(key) {
                        _this.emit(trailingaction_constants_strings.NAVIGATION_EVENT, {
                            key: key
                        }, true);
                    },
                    setAttribute: function(attr, value) {
                        _this.root.setAttribute(attr, value);
                    }
                };
                return new MDCChipTrailingActionFoundation(adapter);
            };
            MDCChipTrailingAction.prototype.isNavigable = function() {
                return this.foundation.isNavigable();
            };
            MDCChipTrailingAction.prototype.focus = function() {
                this.foundation.focus();
            };
            MDCChipTrailingAction.prototype.removeFocus = function() {
                this.foundation.removeFocus();
            };
            return MDCChipTrailingAction;
        }(MDCComponent);
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var Direction;
        (function(Direction) {
            Direction["LEFT"] = "left";
            Direction["RIGHT"] = "right";
        })(Direction || (Direction = {}));
        var EventSource;
        (function(EventSource) {
            EventSource["PRIMARY"] = "primary";
            EventSource["TRAILING"] = "trailing";
            EventSource["NONE"] = "none";
        })(EventSource || (EventSource = {}));
        var chip_constants_strings = {
            ADDED_ANNOUNCEMENT_ATTRIBUTE: "data-mdc-chip-added-announcement",
            ARIA_CHECKED: "aria-checked",
            ARROW_DOWN_KEY: "ArrowDown",
            ARROW_LEFT_KEY: "ArrowLeft",
            ARROW_RIGHT_KEY: "ArrowRight",
            ARROW_UP_KEY: "ArrowUp",
            BACKSPACE_KEY: "Backspace",
            CHECKMARK_SELECTOR: ".mdc-chip__checkmark",
            DELETE_KEY: "Delete",
            END_KEY: "End",
            ENTER_KEY: "Enter",
            ENTRY_ANIMATION_NAME: "mdc-chip-entry",
            HOME_KEY: "Home",
            IE_ARROW_DOWN_KEY: "Down",
            IE_ARROW_LEFT_KEY: "Left",
            IE_ARROW_RIGHT_KEY: "Right",
            IE_ARROW_UP_KEY: "Up",
            IE_DELETE_KEY: "Del",
            INTERACTION_EVENT: "MDCChip:interaction",
            LEADING_ICON_SELECTOR: ".mdc-chip__icon--leading",
            NAVIGATION_EVENT: "MDCChip:navigation",
            PRIMARY_ACTION_SELECTOR: ".mdc-chip__primary-action",
            REMOVED_ANNOUNCEMENT_ATTRIBUTE: "data-mdc-chip-removed-announcement",
            REMOVAL_EVENT: "MDCChip:removal",
            SELECTION_EVENT: "MDCChip:selection",
            SPACEBAR_KEY: " ",
            TAB_INDEX: "tabindex",
            TRAILING_ACTION_SELECTOR: ".mdc-chip-trailing-action",
            TRAILING_ICON_INTERACTION_EVENT: "MDCChip:trailingIconInteraction",
            TRAILING_ICON_SELECTOR: ".mdc-chip__icon--trailing"
        };
        var chip_constants_cssClasses = {
            CHECKMARK: "mdc-chip__checkmark",
            CHIP_EXIT: "mdc-chip--exit",
            DELETABLE: "mdc-chip--deletable",
            EDITABLE: "mdc-chip--editable",
            EDITING: "mdc-chip--editing",
            HIDDEN_LEADING_ICON: "mdc-chip__icon--leading-hidden",
            LEADING_ICON: "mdc-chip__icon--leading",
            PRIMARY_ACTION: "mdc-chip__primary-action",
            PRIMARY_ACTION_FOCUSED: "mdc-chip--primary-action-focused",
            SELECTED: "mdc-chip--selected",
            TEXT: "mdc-chip__text",
            TRAILING_ACTION: "mdc-chip__trailing-action",
            TRAILING_ICON: "mdc-chip__icon--trailing"
        };
        var constants_navigationKeys = new Set;
        constants_navigationKeys.add(chip_constants_strings.ARROW_LEFT_KEY);
        constants_navigationKeys.add(chip_constants_strings.ARROW_RIGHT_KEY);
        constants_navigationKeys.add(chip_constants_strings.ARROW_DOWN_KEY);
        constants_navigationKeys.add(chip_constants_strings.ARROW_UP_KEY);
        constants_navigationKeys.add(chip_constants_strings.END_KEY);
        constants_navigationKeys.add(chip_constants_strings.HOME_KEY);
        constants_navigationKeys.add(chip_constants_strings.IE_ARROW_LEFT_KEY);
        constants_navigationKeys.add(chip_constants_strings.IE_ARROW_RIGHT_KEY);
        constants_navigationKeys.add(chip_constants_strings.IE_ARROW_DOWN_KEY);
        constants_navigationKeys.add(chip_constants_strings.IE_ARROW_UP_KEY);
        var jumpChipKeys = new Set;
        jumpChipKeys.add(chip_constants_strings.ARROW_UP_KEY);
        jumpChipKeys.add(chip_constants_strings.ARROW_DOWN_KEY);
        jumpChipKeys.add(chip_constants_strings.HOME_KEY);
        jumpChipKeys.add(chip_constants_strings.END_KEY);
        jumpChipKeys.add(chip_constants_strings.IE_ARROW_UP_KEY);
        jumpChipKeys.add(chip_constants_strings.IE_ARROW_DOWN_KEY);
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var emptyClientRect = {
            bottom: 0,
            height: 0,
            left: 0,
            right: 0,
            top: 0,
            width: 0
        };
        var FocusBehavior;
        (function(FocusBehavior) {
            FocusBehavior[FocusBehavior["SHOULD_FOCUS"] = 0] = "SHOULD_FOCUS";
            FocusBehavior[FocusBehavior["SHOULD_NOT_FOCUS"] = 1] = "SHOULD_NOT_FOCUS";
        })(FocusBehavior || (FocusBehavior = {}));
        var MDCChipFoundation = function(_super) {
            __extends(MDCChipFoundation, _super);
            function MDCChipFoundation(adapter) {
                var _this = _super.call(this, __assign(__assign({}, MDCChipFoundation.defaultAdapter), adapter)) || this;
                _this.shouldRemoveOnTrailingIconClick_ = true;
                _this.shouldFocusPrimaryActionOnClick_ = true;
                return _this;
            }
            Object.defineProperty(MDCChipFoundation, "strings", {
                get: function() {
                    return chip_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCChipFoundation, "cssClasses", {
                get: function() {
                    return chip_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCChipFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClass: function() {
                            return undefined;
                        },
                        addClassToLeadingIcon: function() {
                            return undefined;
                        },
                        eventTargetHasClass: function() {
                            return false;
                        },
                        focusPrimaryAction: function() {
                            return undefined;
                        },
                        focusTrailingAction: function() {
                            return undefined;
                        },
                        getAttribute: function() {
                            return null;
                        },
                        getCheckmarkBoundingClientRect: function() {
                            return emptyClientRect;
                        },
                        getComputedStyleValue: function() {
                            return "";
                        },
                        getRootBoundingClientRect: function() {
                            return emptyClientRect;
                        },
                        hasClass: function() {
                            return false;
                        },
                        hasLeadingIcon: function() {
                            return false;
                        },
                        isRTL: function() {
                            return false;
                        },
                        isTrailingActionNavigable: function() {
                            return false;
                        },
                        notifyEditFinish: function() {
                            return undefined;
                        },
                        notifyEditStart: function() {
                            return undefined;
                        },
                        notifyInteraction: function() {
                            return undefined;
                        },
                        notifyNavigation: function() {
                            return undefined;
                        },
                        notifyRemoval: function() {
                            return undefined;
                        },
                        notifySelection: function() {
                            return undefined;
                        },
                        notifyTrailingIconInteraction: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        removeClassFromLeadingIcon: function() {
                            return undefined;
                        },
                        removeTrailingActionFocus: function() {
                            return undefined;
                        },
                        setPrimaryActionAttr: function() {
                            return undefined;
                        },
                        setStyleProperty: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCChipFoundation.prototype.isSelected = function() {
                return this.adapter.hasClass(chip_constants_cssClasses.SELECTED);
            };
            MDCChipFoundation.prototype.isEditable = function() {
                return this.adapter.hasClass(chip_constants_cssClasses.EDITABLE);
            };
            MDCChipFoundation.prototype.isEditing = function() {
                return this.adapter.hasClass(chip_constants_cssClasses.EDITING);
            };
            MDCChipFoundation.prototype.setSelected = function(selected) {
                this.setSelected_(selected);
                this.notifySelection_(selected);
            };
            MDCChipFoundation.prototype.setSelectedFromChipSet = function(selected, shouldNotifyClients) {
                this.setSelected_(selected);
                if (shouldNotifyClients) {
                    this.notifyIgnoredSelection_(selected);
                }
            };
            MDCChipFoundation.prototype.getShouldRemoveOnTrailingIconClick = function() {
                return this.shouldRemoveOnTrailingIconClick_;
            };
            MDCChipFoundation.prototype.setShouldRemoveOnTrailingIconClick = function(shouldRemove) {
                this.shouldRemoveOnTrailingIconClick_ = shouldRemove;
            };
            MDCChipFoundation.prototype.setShouldFocusPrimaryActionOnClick = function(shouldFocus) {
                this.shouldFocusPrimaryActionOnClick_ = shouldFocus;
            };
            MDCChipFoundation.prototype.getDimensions = function() {
                var _this = this;
                var getRootRect = function() {
                    return _this.adapter.getRootBoundingClientRect();
                };
                var getCheckmarkRect = function() {
                    return _this.adapter.getCheckmarkBoundingClientRect();
                };
                if (!this.adapter.hasLeadingIcon()) {
                    var checkmarkRect = getCheckmarkRect();
                    if (checkmarkRect) {
                        var rootRect = getRootRect();
                        return {
                            bottom: rootRect.bottom,
                            height: rootRect.height,
                            left: rootRect.left,
                            right: rootRect.right,
                            top: rootRect.top,
                            width: rootRect.width + checkmarkRect.height
                        };
                    }
                }
                return getRootRect();
            };
            MDCChipFoundation.prototype.beginExit = function() {
                this.adapter.addClass(chip_constants_cssClasses.CHIP_EXIT);
            };
            MDCChipFoundation.prototype.handleClick = function() {
                this.adapter.notifyInteraction();
                this.setPrimaryActionFocusable_(this.getFocusBehavior_());
            };
            MDCChipFoundation.prototype.handleDoubleClick = function() {
                if (this.isEditable()) {
                    this.startEditing();
                }
            };
            MDCChipFoundation.prototype.handleTransitionEnd = function(evt) {
                var _this = this;
                var shouldHandle = this.adapter.eventTargetHasClass(evt.target, chip_constants_cssClasses.CHIP_EXIT);
                var widthIsAnimating = evt.propertyName === "width";
                var opacityIsAnimating = evt.propertyName === "opacity";
                if (shouldHandle && opacityIsAnimating) {
                    var chipWidth_1 = this.adapter.getComputedStyleValue("width");
                    requestAnimationFrame((function() {
                        _this.adapter.setStyleProperty("width", chipWidth_1);
                        _this.adapter.setStyleProperty("padding", "0");
                        _this.adapter.setStyleProperty("margin", "0");
                        requestAnimationFrame((function() {
                            _this.adapter.setStyleProperty("width", "0");
                        }));
                    }));
                    return;
                }
                if (shouldHandle && widthIsAnimating) {
                    this.removeFocus();
                    var removedAnnouncement = this.adapter.getAttribute(chip_constants_strings.REMOVED_ANNOUNCEMENT_ATTRIBUTE);
                    this.adapter.notifyRemoval(removedAnnouncement);
                }
                if (!opacityIsAnimating) {
                    return;
                }
                var shouldHideLeadingIcon = this.adapter.eventTargetHasClass(evt.target, chip_constants_cssClasses.LEADING_ICON) && this.adapter.hasClass(chip_constants_cssClasses.SELECTED);
                var shouldShowLeadingIcon = this.adapter.eventTargetHasClass(evt.target, chip_constants_cssClasses.CHECKMARK) && !this.adapter.hasClass(chip_constants_cssClasses.SELECTED);
                if (shouldHideLeadingIcon) {
                    this.adapter.addClassToLeadingIcon(chip_constants_cssClasses.HIDDEN_LEADING_ICON);
                    return;
                }
                if (shouldShowLeadingIcon) {
                    this.adapter.removeClassFromLeadingIcon(chip_constants_cssClasses.HIDDEN_LEADING_ICON);
                    return;
                }
            };
            MDCChipFoundation.prototype.handleFocusIn = function(evt) {
                if (!this.eventFromPrimaryAction_(evt)) {
                    return;
                }
                this.adapter.addClass(chip_constants_cssClasses.PRIMARY_ACTION_FOCUSED);
            };
            MDCChipFoundation.prototype.handleFocusOut = function(evt) {
                if (!this.eventFromPrimaryAction_(evt)) {
                    return;
                }
                if (this.isEditing()) {
                    this.finishEditing();
                }
                this.adapter.removeClass(chip_constants_cssClasses.PRIMARY_ACTION_FOCUSED);
            };
            MDCChipFoundation.prototype.handleTrailingActionInteraction = function() {
                this.adapter.notifyTrailingIconInteraction();
                this.removeChip_();
            };
            MDCChipFoundation.prototype.handleKeydown = function(evt) {
                if (this.isEditing()) {
                    if (this.shouldFinishEditing(evt)) {
                        evt.preventDefault();
                        this.finishEditing();
                    }
                    return;
                }
                if (this.isEditable()) {
                    if (this.shouldStartEditing(evt)) {
                        evt.preventDefault();
                        this.startEditing();
                    }
                }
                if (this.shouldNotifyInteraction_(evt)) {
                    this.adapter.notifyInteraction();
                    this.setPrimaryActionFocusable_(this.getFocusBehavior_());
                    return;
                }
                if (this.isDeleteAction_(evt)) {
                    evt.preventDefault();
                    this.removeChip_();
                    return;
                }
                if (!constants_navigationKeys.has(evt.key)) {
                    return;
                }
                evt.preventDefault();
                this.focusNextAction_(evt.key, EventSource.PRIMARY);
            };
            MDCChipFoundation.prototype.handleTrailingActionNavigation = function(evt) {
                return this.focusNextAction_(evt.detail.key, EventSource.TRAILING);
            };
            MDCChipFoundation.prototype.removeFocus = function() {
                this.adapter.setPrimaryActionAttr(chip_constants_strings.TAB_INDEX, "-1");
                this.adapter.removeTrailingActionFocus();
            };
            MDCChipFoundation.prototype.focusPrimaryAction = function() {
                this.setPrimaryActionFocusable_(FocusBehavior.SHOULD_FOCUS);
            };
            MDCChipFoundation.prototype.focusTrailingAction = function() {
                var trailingActionIsNavigable = this.adapter.isTrailingActionNavigable();
                if (trailingActionIsNavigable) {
                    this.adapter.setPrimaryActionAttr(chip_constants_strings.TAB_INDEX, "-1");
                    this.adapter.focusTrailingAction();
                    return;
                }
                this.focusPrimaryAction();
            };
            MDCChipFoundation.prototype.setPrimaryActionFocusable_ = function(focusBehavior) {
                this.adapter.setPrimaryActionAttr(chip_constants_strings.TAB_INDEX, "0");
                if (focusBehavior === FocusBehavior.SHOULD_FOCUS) {
                    this.adapter.focusPrimaryAction();
                }
                this.adapter.removeTrailingActionFocus();
            };
            MDCChipFoundation.prototype.getFocusBehavior_ = function() {
                if (this.shouldFocusPrimaryActionOnClick_) {
                    return FocusBehavior.SHOULD_FOCUS;
                }
                return FocusBehavior.SHOULD_NOT_FOCUS;
            };
            MDCChipFoundation.prototype.focusNextAction_ = function(key, source) {
                var isTrailingActionNavigable = this.adapter.isTrailingActionNavigable();
                var dir = this.getDirection_(key);
                if (jumpChipKeys.has(key) || !isTrailingActionNavigable) {
                    return this.adapter.notifyNavigation(key, source);
                }
                if (source === EventSource.PRIMARY && dir === Direction.RIGHT) {
                    return this.focusTrailingAction();
                }
                if (source === EventSource.TRAILING && dir === Direction.LEFT) {
                    return this.focusPrimaryAction();
                }
                this.adapter.notifyNavigation(key, EventSource.NONE);
            };
            MDCChipFoundation.prototype.getDirection_ = function(key) {
                var isRTL = this.adapter.isRTL();
                var isLeftKey = key === chip_constants_strings.ARROW_LEFT_KEY || key === chip_constants_strings.IE_ARROW_LEFT_KEY;
                var isRightKey = key === chip_constants_strings.ARROW_RIGHT_KEY || key === chip_constants_strings.IE_ARROW_RIGHT_KEY;
                if (!isRTL && isLeftKey || isRTL && isRightKey) {
                    return Direction.LEFT;
                }
                return Direction.RIGHT;
            };
            MDCChipFoundation.prototype.removeChip_ = function() {
                if (this.shouldRemoveOnTrailingIconClick_) {
                    this.beginExit();
                }
            };
            MDCChipFoundation.prototype.shouldStartEditing = function(evt) {
                return this.eventFromPrimaryAction_(evt) && evt.key === chip_constants_strings.ENTER_KEY;
            };
            MDCChipFoundation.prototype.shouldFinishEditing = function(evt) {
                return evt.key === chip_constants_strings.ENTER_KEY;
            };
            MDCChipFoundation.prototype.shouldNotifyInteraction_ = function(evt) {
                return evt.key === chip_constants_strings.ENTER_KEY || evt.key === chip_constants_strings.SPACEBAR_KEY;
            };
            MDCChipFoundation.prototype.isDeleteAction_ = function(evt) {
                var isDeletable = this.adapter.hasClass(chip_constants_cssClasses.DELETABLE);
                return isDeletable && (evt.key === chip_constants_strings.BACKSPACE_KEY || evt.key === chip_constants_strings.DELETE_KEY || evt.key === chip_constants_strings.IE_DELETE_KEY);
            };
            MDCChipFoundation.prototype.setSelected_ = function(selected) {
                if (selected) {
                    this.adapter.addClass(chip_constants_cssClasses.SELECTED);
                    this.adapter.setPrimaryActionAttr(chip_constants_strings.ARIA_CHECKED, "true");
                } else {
                    this.adapter.removeClass(chip_constants_cssClasses.SELECTED);
                    this.adapter.setPrimaryActionAttr(chip_constants_strings.ARIA_CHECKED, "false");
                }
            };
            MDCChipFoundation.prototype.notifySelection_ = function(selected) {
                this.adapter.notifySelection(selected, false);
            };
            MDCChipFoundation.prototype.notifyIgnoredSelection_ = function(selected) {
                this.adapter.notifySelection(selected, true);
            };
            MDCChipFoundation.prototype.eventFromPrimaryAction_ = function(evt) {
                return this.adapter.eventTargetHasClass(evt.target, chip_constants_cssClasses.PRIMARY_ACTION);
            };
            MDCChipFoundation.prototype.startEditing = function() {
                this.adapter.addClass(chip_constants_cssClasses.EDITING);
                this.adapter.notifyEditStart();
            };
            MDCChipFoundation.prototype.finishEditing = function() {
                this.adapter.removeClass(chip_constants_cssClasses.EDITING);
                this.adapter.notifyEditFinish();
            };
            return MDCChipFoundation;
        }(MDCFoundation);
        const chip_foundation = null && MDCChipFoundation;
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCChip = function(_super) {
            __extends(MDCChip, _super);
            function MDCChip() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Object.defineProperty(MDCChip.prototype, "selected", {
                get: function() {
                    return this.foundation.isSelected();
                },
                set: function(selected) {
                    this.foundation.setSelected(selected);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCChip.prototype, "shouldRemoveOnTrailingIconClick", {
                get: function() {
                    return this.foundation.getShouldRemoveOnTrailingIconClick();
                },
                set: function(shouldRemove) {
                    this.foundation.setShouldRemoveOnTrailingIconClick(shouldRemove);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCChip.prototype, "setShouldFocusPrimaryActionOnClick", {
                set: function(shouldFocus) {
                    this.foundation.setShouldFocusPrimaryActionOnClick(shouldFocus);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCChip.prototype, "ripple", {
                get: function() {
                    return this.ripple_;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCChip.prototype, "id", {
                get: function() {
                    return this.root.id;
                },
                enumerable: true,
                configurable: true
            });
            MDCChip.attachTo = function(root) {
                return new MDCChip(root);
            };
            MDCChip.prototype.initialize = function(rippleFactory, trailingActionFactory) {
                var _this = this;
                if (rippleFactory === void 0) {
                    rippleFactory = function(el, foundation) {
                        return new MDCRipple(el, foundation);
                    };
                }
                if (trailingActionFactory === void 0) {
                    trailingActionFactory = function(el) {
                        return new MDCChipTrailingAction(el);
                    };
                }
                this.leadingIcon_ = this.root.querySelector(chip_constants_strings.LEADING_ICON_SELECTOR);
                this.checkmark_ = this.root.querySelector(chip_constants_strings.CHECKMARK_SELECTOR);
                this.primaryAction_ = this.root.querySelector(chip_constants_strings.PRIMARY_ACTION_SELECTOR);
                var trailingActionEl = this.root.querySelector(chip_constants_strings.TRAILING_ACTION_SELECTOR);
                if (trailingActionEl) {
                    this.trailingAction_ = trailingActionFactory(trailingActionEl);
                }
                var rippleAdapter = __assign(__assign({}, MDCRipple.createAdapter(this)), {
                    computeBoundingRect: function() {
                        return _this.foundation.getDimensions();
                    }
                });
                this.ripple_ = rippleFactory(this.root, new MDCRippleFoundation(rippleAdapter));
            };
            MDCChip.prototype.initialSyncWithDOM = function() {
                var _this = this;
                this.handleTrailingActionInteraction_ = function() {
                    _this.foundation.handleTrailingActionInteraction();
                };
                this.handleTrailingActionNavigation_ = function(evt) {
                    _this.foundation.handleTrailingActionNavigation(evt);
                };
                this.handleClick_ = function() {
                    _this.foundation.handleClick();
                };
                this.handleKeydown_ = function(evt) {
                    _this.foundation.handleKeydown(evt);
                };
                this.handleTransitionEnd_ = function(evt) {
                    _this.foundation.handleTransitionEnd(evt);
                };
                this.handleFocusIn_ = function(evt) {
                    _this.foundation.handleFocusIn(evt);
                };
                this.handleFocusOut_ = function(evt) {
                    _this.foundation.handleFocusOut(evt);
                };
                this.listen("transitionend", this.handleTransitionEnd_);
                this.listen("click", this.handleClick_);
                this.listen("keydown", this.handleKeydown_);
                this.listen("focusin", this.handleFocusIn_);
                this.listen("focusout", this.handleFocusOut_);
                if (this.trailingAction_) {
                    this.listen(trailingaction_constants_strings.INTERACTION_EVENT, this.handleTrailingActionInteraction_);
                    this.listen(trailingaction_constants_strings.NAVIGATION_EVENT, this.handleTrailingActionNavigation_);
                }
            };
            MDCChip.prototype.destroy = function() {
                this.ripple_.destroy();
                this.unlisten("transitionend", this.handleTransitionEnd_);
                this.unlisten("keydown", this.handleKeydown_);
                this.unlisten("click", this.handleClick_);
                this.unlisten("focusin", this.handleFocusIn_);
                this.unlisten("focusout", this.handleFocusOut_);
                if (this.trailingAction_) {
                    this.unlisten(trailingaction_constants_strings.INTERACTION_EVENT, this.handleTrailingActionInteraction_);
                    this.unlisten(trailingaction_constants_strings.NAVIGATION_EVENT, this.handleTrailingActionNavigation_);
                }
                _super.prototype.destroy.call(this);
            };
            MDCChip.prototype.beginExit = function() {
                this.foundation.beginExit();
            };
            MDCChip.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    addClass: function(className) {
                        return _this.root.classList.add(className);
                    },
                    addClassToLeadingIcon: function(className) {
                        if (_this.leadingIcon_) {
                            _this.leadingIcon_.classList.add(className);
                        }
                    },
                    eventTargetHasClass: function(target, className) {
                        return target ? target.classList.contains(className) : false;
                    },
                    focusPrimaryAction: function() {
                        if (_this.primaryAction_) {
                            _this.primaryAction_.focus();
                        }
                    },
                    focusTrailingAction: function() {
                        if (_this.trailingAction_) {
                            _this.trailingAction_.focus();
                        }
                    },
                    getAttribute: function(attr) {
                        return _this.root.getAttribute(attr);
                    },
                    getCheckmarkBoundingClientRect: function() {
                        return _this.checkmark_ ? _this.checkmark_.getBoundingClientRect() : null;
                    },
                    getComputedStyleValue: function(propertyName) {
                        return window.getComputedStyle(_this.root).getPropertyValue(propertyName);
                    },
                    getRootBoundingClientRect: function() {
                        return _this.root.getBoundingClientRect();
                    },
                    hasClass: function(className) {
                        return _this.root.classList.contains(className);
                    },
                    hasLeadingIcon: function() {
                        return !!_this.leadingIcon_;
                    },
                    isRTL: function() {
                        return window.getComputedStyle(_this.root).getPropertyValue("direction") === "rtl";
                    },
                    isTrailingActionNavigable: function() {
                        if (_this.trailingAction_) {
                            return _this.trailingAction_.isNavigable();
                        }
                        return false;
                    },
                    notifyInteraction: function() {
                        return _this.emit(chip_constants_strings.INTERACTION_EVENT, {
                            chipId: _this.id
                        }, true);
                    },
                    notifyNavigation: function(key, source) {
                        return _this.emit(chip_constants_strings.NAVIGATION_EVENT, {
                            chipId: _this.id,
                            key: key,
                            source: source
                        }, true);
                    },
                    notifyRemoval: function(removedAnnouncement) {
                        _this.emit(chip_constants_strings.REMOVAL_EVENT, {
                            chipId: _this.id,
                            removedAnnouncement: removedAnnouncement
                        }, true);
                    },
                    notifySelection: function(selected, shouldIgnore) {
                        return _this.emit(chip_constants_strings.SELECTION_EVENT, {
                            chipId: _this.id,
                            selected: selected,
                            shouldIgnore: shouldIgnore
                        }, true);
                    },
                    notifyTrailingIconInteraction: function() {
                        return _this.emit(chip_constants_strings.TRAILING_ICON_INTERACTION_EVENT, {
                            chipId: _this.id
                        }, true);
                    },
                    notifyEditStart: function() {},
                    notifyEditFinish: function() {},
                    removeClass: function(className) {
                        return _this.root.classList.remove(className);
                    },
                    removeClassFromLeadingIcon: function(className) {
                        if (_this.leadingIcon_) {
                            _this.leadingIcon_.classList.remove(className);
                        }
                    },
                    removeTrailingActionFocus: function() {
                        if (_this.trailingAction_) {
                            _this.trailingAction_.removeFocus();
                        }
                    },
                    setPrimaryActionAttr: function(attr, value) {
                        if (_this.primaryAction_) {
                            _this.primaryAction_.setAttribute(attr, value);
                        }
                    },
                    setStyleProperty: function(propertyName, value) {
                        return _this.root.style.setProperty(propertyName, value);
                    }
                };
                return new MDCChipFoundation(adapter);
            };
            MDCChip.prototype.setSelectedFromChipSet = function(selected, shouldNotifyClients) {
                this.foundation.setSelectedFromChipSet(selected, shouldNotifyClients);
            };
            MDCChip.prototype.focusPrimaryAction = function() {
                this.foundation.focusPrimaryAction();
            };
            MDCChip.prototype.focusTrailingAction = function() {
                this.foundation.focusTrailingAction();
            };
            MDCChip.prototype.removeFocus = function() {
                this.foundation.removeFocus();
            };
            MDCChip.prototype.remove = function() {
                var parent = this.root.parentNode;
                if (parent !== null) {
                    parent.removeChild(this.root);
                }
            };
            return MDCChip;
        }(MDCComponent);
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var chip_set_constants_strings = {
            CHIP_SELECTOR: ".mdc-chip"
        };
        var chip_set_constants_cssClasses = {
            CHOICE: "mdc-chip-set--choice",
            FILTER: "mdc-chip-set--filter"
        };
        /**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCChipSetFoundation = function(_super) {
            __extends(MDCChipSetFoundation, _super);
            function MDCChipSetFoundation(adapter) {
                var _this = _super.call(this, __assign(__assign({}, MDCChipSetFoundation.defaultAdapter), adapter)) || this;
                _this.selectedChipIds_ = [];
                return _this;
            }
            Object.defineProperty(MDCChipSetFoundation, "strings", {
                get: function() {
                    return chip_set_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCChipSetFoundation, "cssClasses", {
                get: function() {
                    return chip_set_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCChipSetFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        announceMessage: function() {
                            return undefined;
                        },
                        focusChipPrimaryActionAtIndex: function() {
                            return undefined;
                        },
                        focusChipTrailingActionAtIndex: function() {
                            return undefined;
                        },
                        getChipListCount: function() {
                            return -1;
                        },
                        getIndexOfChipById: function() {
                            return -1;
                        },
                        hasClass: function() {
                            return false;
                        },
                        isRTL: function() {
                            return false;
                        },
                        removeChipAtIndex: function() {
                            return undefined;
                        },
                        removeFocusFromChipAtIndex: function() {
                            return undefined;
                        },
                        selectChipAtIndex: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCChipSetFoundation.prototype.getSelectedChipIds = function() {
                return this.selectedChipIds_.slice();
            };
            MDCChipSetFoundation.prototype.select = function(chipId) {
                this.select_(chipId, false);
            };
            MDCChipSetFoundation.prototype.handleChipInteraction = function(_a) {
                var chipId = _a.chipId;
                var index = this.adapter.getIndexOfChipById(chipId);
                this.removeFocusFromChipsExcept_(index);
                if (this.adapter.hasClass(chip_set_constants_cssClasses.CHOICE) || this.adapter.hasClass(chip_set_constants_cssClasses.FILTER)) {
                    this.toggleSelect_(chipId);
                }
            };
            MDCChipSetFoundation.prototype.handleChipSelection = function(_a) {
                var chipId = _a.chipId, selected = _a.selected, shouldIgnore = _a.shouldIgnore;
                if (shouldIgnore) {
                    return;
                }
                var chipIsSelected = this.selectedChipIds_.indexOf(chipId) >= 0;
                if (selected && !chipIsSelected) {
                    this.select(chipId);
                } else if (!selected && chipIsSelected) {
                    this.deselect_(chipId);
                }
            };
            MDCChipSetFoundation.prototype.handleChipRemoval = function(_a) {
                var chipId = _a.chipId, removedAnnouncement = _a.removedAnnouncement;
                if (removedAnnouncement) {
                    this.adapter.announceMessage(removedAnnouncement);
                }
                var index = this.adapter.getIndexOfChipById(chipId);
                this.deselectAndNotifyClients_(chipId);
                this.adapter.removeChipAtIndex(index);
                var maxIndex = this.adapter.getChipListCount() - 1;
                if (maxIndex < 0) {
                    return;
                }
                var nextIndex = Math.min(index, maxIndex);
                this.removeFocusFromChipsExcept_(nextIndex);
                this.adapter.focusChipTrailingActionAtIndex(nextIndex);
            };
            MDCChipSetFoundation.prototype.handleChipNavigation = function(_a) {
                var chipId = _a.chipId, key = _a.key, source = _a.source;
                var maxIndex = this.adapter.getChipListCount() - 1;
                var index = this.adapter.getIndexOfChipById(chipId);
                if (index === -1 || !constants_navigationKeys.has(key)) {
                    return;
                }
                var isRTL = this.adapter.isRTL();
                var isLeftKey = key === chip_constants_strings.ARROW_LEFT_KEY || key === chip_constants_strings.IE_ARROW_LEFT_KEY;
                var isRightKey = key === chip_constants_strings.ARROW_RIGHT_KEY || key === chip_constants_strings.IE_ARROW_RIGHT_KEY;
                var isDownKey = key === chip_constants_strings.ARROW_DOWN_KEY || key === chip_constants_strings.IE_ARROW_DOWN_KEY;
                var shouldIncrement = !isRTL && isRightKey || isRTL && isLeftKey || isDownKey;
                var isHome = key === chip_constants_strings.HOME_KEY;
                var isEnd = key === chip_constants_strings.END_KEY;
                if (shouldIncrement) {
                    index++;
                } else if (isHome) {
                    index = 0;
                } else if (isEnd) {
                    index = maxIndex;
                } else {
                    index--;
                }
                if (index < 0 || index > maxIndex) {
                    return;
                }
                this.removeFocusFromChipsExcept_(index);
                this.focusChipAction_(index, key, source);
            };
            MDCChipSetFoundation.prototype.focusChipAction_ = function(index, key, source) {
                var shouldJumpChips = jumpChipKeys.has(key);
                if (shouldJumpChips && source === EventSource.PRIMARY) {
                    return this.adapter.focusChipPrimaryActionAtIndex(index);
                }
                if (shouldJumpChips && source === EventSource.TRAILING) {
                    return this.adapter.focusChipTrailingActionAtIndex(index);
                }
                var dir = this.getDirection_(key);
                if (dir === Direction.LEFT) {
                    return this.adapter.focusChipTrailingActionAtIndex(index);
                }
                if (dir === Direction.RIGHT) {
                    return this.adapter.focusChipPrimaryActionAtIndex(index);
                }
            };
            MDCChipSetFoundation.prototype.getDirection_ = function(key) {
                var isRTL = this.adapter.isRTL();
                var isLeftKey = key === chip_constants_strings.ARROW_LEFT_KEY || key === chip_constants_strings.IE_ARROW_LEFT_KEY;
                var isRightKey = key === chip_constants_strings.ARROW_RIGHT_KEY || key === chip_constants_strings.IE_ARROW_RIGHT_KEY;
                if (!isRTL && isLeftKey || isRTL && isRightKey) {
                    return Direction.LEFT;
                }
                return Direction.RIGHT;
            };
            MDCChipSetFoundation.prototype.deselect_ = function(chipId, shouldNotifyClients) {
                if (shouldNotifyClients === void 0) {
                    shouldNotifyClients = false;
                }
                var index = this.selectedChipIds_.indexOf(chipId);
                if (index >= 0) {
                    this.selectedChipIds_.splice(index, 1);
                    var chipIndex = this.adapter.getIndexOfChipById(chipId);
                    this.adapter.selectChipAtIndex(chipIndex, false, shouldNotifyClients);
                }
            };
            MDCChipSetFoundation.prototype.deselectAndNotifyClients_ = function(chipId) {
                this.deselect_(chipId, true);
            };
            MDCChipSetFoundation.prototype.toggleSelect_ = function(chipId) {
                if (this.selectedChipIds_.indexOf(chipId) >= 0) {
                    this.deselectAndNotifyClients_(chipId);
                } else {
                    this.selectAndNotifyClients_(chipId);
                }
            };
            MDCChipSetFoundation.prototype.removeFocusFromChipsExcept_ = function(index) {
                var chipCount = this.adapter.getChipListCount();
                for (var i = 0; i < chipCount; i++) {
                    if (i !== index) {
                        this.adapter.removeFocusFromChipAtIndex(i);
                    }
                }
            };
            MDCChipSetFoundation.prototype.selectAndNotifyClients_ = function(chipId) {
                this.select_(chipId, true);
            };
            MDCChipSetFoundation.prototype.select_ = function(chipId, shouldNotifyClients) {
                if (this.selectedChipIds_.indexOf(chipId) >= 0) {
                    return;
                }
                if (this.adapter.hasClass(chip_set_constants_cssClasses.CHOICE) && this.selectedChipIds_.length > 0) {
                    var previouslySelectedChip = this.selectedChipIds_[0];
                    var previouslySelectedIndex = this.adapter.getIndexOfChipById(previouslySelectedChip);
                    this.selectedChipIds_ = [];
                    this.adapter.selectChipAtIndex(previouslySelectedIndex, false, shouldNotifyClients);
                }
                this.selectedChipIds_.push(chipId);
                var index = this.adapter.getIndexOfChipById(chipId);
                this.adapter.selectChipAtIndex(index, true, shouldNotifyClients);
            };
            return MDCChipSetFoundation;
        }(MDCFoundation);
        const chip_set_foundation = null && MDCChipSetFoundation;
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var _a = MDCChipFoundation.strings, INTERACTION_EVENT = _a.INTERACTION_EVENT, SELECTION_EVENT = _a.SELECTION_EVENT, REMOVAL_EVENT = _a.REMOVAL_EVENT, NAVIGATION_EVENT = _a.NAVIGATION_EVENT;
        var CHIP_SELECTOR = MDCChipSetFoundation.strings.CHIP_SELECTOR;
        var idCounter = 0;
        var MDCChipSet = function(_super) {
            __extends(MDCChipSet, _super);
            function MDCChipSet() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCChipSet.attachTo = function(root) {
                return new MDCChipSet(root);
            };
            Object.defineProperty(MDCChipSet.prototype, "chips", {
                get: function() {
                    return this.chips_.slice();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCChipSet.prototype, "selectedChipIds", {
                get: function() {
                    return this.foundation.getSelectedChipIds();
                },
                enumerable: true,
                configurable: true
            });
            MDCChipSet.prototype.initialize = function(chipFactory) {
                if (chipFactory === void 0) {
                    chipFactory = function(el) {
                        return new MDCChip(el);
                    };
                }
                this.chipFactory_ = chipFactory;
                this.chips_ = this.instantiateChips_(this.chipFactory_);
            };
            MDCChipSet.prototype.initialSyncWithDOM = function() {
                var _this = this;
                this.chips_.forEach((function(chip) {
                    if (chip.id && chip.selected) {
                        _this.foundation.select(chip.id);
                    }
                }));
                this.handleChipInteraction_ = function(evt) {
                    return _this.foundation.handleChipInteraction(evt.detail);
                };
                this.handleChipSelection_ = function(evt) {
                    return _this.foundation.handleChipSelection(evt.detail);
                };
                this.handleChipRemoval_ = function(evt) {
                    return _this.foundation.handleChipRemoval(evt.detail);
                };
                this.handleChipNavigation_ = function(evt) {
                    return _this.foundation.handleChipNavigation(evt.detail);
                };
                this.listen(INTERACTION_EVENT, this.handleChipInteraction_);
                this.listen(SELECTION_EVENT, this.handleChipSelection_);
                this.listen(REMOVAL_EVENT, this.handleChipRemoval_);
                this.listen(NAVIGATION_EVENT, this.handleChipNavigation_);
            };
            MDCChipSet.prototype.destroy = function() {
                this.chips_.forEach((function(chip) {
                    chip.destroy();
                }));
                this.unlisten(INTERACTION_EVENT, this.handleChipInteraction_);
                this.unlisten(SELECTION_EVENT, this.handleChipSelection_);
                this.unlisten(REMOVAL_EVENT, this.handleChipRemoval_);
                this.unlisten(NAVIGATION_EVENT, this.handleChipNavigation_);
                _super.prototype.destroy.call(this);
            };
            MDCChipSet.prototype.addChip = function(chipEl) {
                chipEl.id = chipEl.id || "mdc-chip-" + ++idCounter;
                this.chips_.push(this.chipFactory_(chipEl));
            };
            MDCChipSet.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    announceMessage: function(message) {
                        announce(message);
                    },
                    focusChipPrimaryActionAtIndex: function(index) {
                        _this.chips_[index].focusPrimaryAction();
                    },
                    focusChipTrailingActionAtIndex: function(index) {
                        _this.chips_[index].focusTrailingAction();
                    },
                    getChipListCount: function() {
                        return _this.chips_.length;
                    },
                    getIndexOfChipById: function(chipId) {
                        return _this.findChipIndex_(chipId);
                    },
                    hasClass: function(className) {
                        return _this.root.classList.contains(className);
                    },
                    isRTL: function() {
                        return window.getComputedStyle(_this.root).getPropertyValue("direction") === "rtl";
                    },
                    removeChipAtIndex: function(index) {
                        if (index >= 0 && index < _this.chips_.length) {
                            _this.chips_[index].destroy();
                            _this.chips_[index].remove();
                            _this.chips_.splice(index, 1);
                        }
                    },
                    removeFocusFromChipAtIndex: function(index) {
                        _this.chips_[index].removeFocus();
                    },
                    selectChipAtIndex: function(index, selected, shouldNotifyClients) {
                        if (index >= 0 && index < _this.chips_.length) {
                            _this.chips_[index].setSelectedFromChipSet(selected, shouldNotifyClients);
                        }
                    }
                };
                return new MDCChipSetFoundation(adapter);
            };
            MDCChipSet.prototype.instantiateChips_ = function(chipFactory) {
                var chipElements = [].slice.call(this.root.querySelectorAll(CHIP_SELECTOR));
                return chipElements.map((function(el) {
                    el.id = el.id || "mdc-chip-" + ++idCounter;
                    return chipFactory(el);
                }));
            };
            MDCChipSet.prototype.findChipIndex_ = function(chipId) {
                for (var i = 0; i < this.chips_.length; i++) {
                    if (this.chips_[i].id === chipId) {
                        return i;
                    }
                }
                return -1;
            };
            return MDCChipSet;
        }(MDCComponent);
        function MBChipsSelectMulti_init(elem, isSingleSelect, dotNetObject) {
            elem._chipSet = MDCChipSet.attachTo(elem);
            elem._isSingleSelect = isSingleSelect;
            var clickedCallback = function clickedCallback() {
                if (elem._isSingleSelect) {
                    var selectedChips = elem._chipSet.chips.filter((function(x) {
                        return x.foundation.isSelected();
                    }));
                    if (selectedChips.length == 0) {
                        dotNetObject.invokeMethodAsync("NotifySingleSelected", -1);
                    } else {
                        dotNetObject.invokeMethodAsync("NotifySingleSelected", elem._chipSet.chips.findIndex((function(x) {
                            return x.id === selectedChips[0].id;
                        })));
                    }
                } else {
                    dotNetObject.invokeMethodAsync("NotifyMultiSelected", elem._chipSet.chips.map((function(x) {
                        return x.foundation.isSelected();
                    })));
                }
            };
            elem._chipSet.listen("MDCChip:selection", clickedCallback);
        }
        function MBChipsSelectMulti_setDisabled(elem, value) {
            elem._chipSet.disabled = value;
        }
        function setSelected(elem, selectedFlags) {
            for (var i = 0; i < selectedFlags.length; i++) {
                elem._chipSet.foundation.adapter.selectChipAtIndex(i, selectedFlags[i], false);
            }
        }
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var cssPropertyNameMap = {
            animation: {
                prefixed: "-webkit-animation",
                standard: "animation"
            },
            transform: {
                prefixed: "-webkit-transform",
                standard: "transform"
            },
            transition: {
                prefixed: "-webkit-transition",
                standard: "transition"
            }
        };
        var jsEventTypeMap = {
            animationend: {
                cssProperty: "animation",
                prefixed: "webkitAnimationEnd",
                standard: "animationend"
            },
            animationiteration: {
                cssProperty: "animation",
                prefixed: "webkitAnimationIteration",
                standard: "animationiteration"
            },
            animationstart: {
                cssProperty: "animation",
                prefixed: "webkitAnimationStart",
                standard: "animationstart"
            },
            transitionend: {
                cssProperty: "transition",
                prefixed: "webkitTransitionEnd",
                standard: "transitionend"
            }
        };
        function isWindow(windowObj) {
            return Boolean(windowObj.document) && typeof windowObj.document.createElement === "function";
        }
        function getCorrectPropertyName(windowObj, cssProperty) {
            if (isWindow(windowObj) && cssProperty in cssPropertyNameMap) {
                var el = windowObj.document.createElement("div");
                var _a = cssPropertyNameMap[cssProperty], standard = _a.standard, prefixed = _a.prefixed;
                var isStandard = standard in el.style;
                return isStandard ? standard : prefixed;
            }
            return cssProperty;
        }
        function getCorrectEventName(windowObj, eventType) {
            if (isWindow(windowObj) && eventType in jsEventTypeMap) {
                var el = windowObj.document.createElement("div");
                var _a = jsEventTypeMap[eventType], standard = _a.standard, prefixed = _a.prefixed, cssProperty = _a.cssProperty;
                var isStandard = cssProperty in el.style;
                return isStandard ? standard : prefixed;
            }
            return eventType;
        }
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var checkbox_constants_cssClasses = {
            ANIM_CHECKED_INDETERMINATE: "mdc-checkbox--anim-checked-indeterminate",
            ANIM_CHECKED_UNCHECKED: "mdc-checkbox--anim-checked-unchecked",
            ANIM_INDETERMINATE_CHECKED: "mdc-checkbox--anim-indeterminate-checked",
            ANIM_INDETERMINATE_UNCHECKED: "mdc-checkbox--anim-indeterminate-unchecked",
            ANIM_UNCHECKED_CHECKED: "mdc-checkbox--anim-unchecked-checked",
            ANIM_UNCHECKED_INDETERMINATE: "mdc-checkbox--anim-unchecked-indeterminate",
            BACKGROUND: "mdc-checkbox__background",
            CHECKED: "mdc-checkbox--checked",
            CHECKMARK: "mdc-checkbox__checkmark",
            CHECKMARK_PATH: "mdc-checkbox__checkmark-path",
            DISABLED: "mdc-checkbox--disabled",
            INDETERMINATE: "mdc-checkbox--indeterminate",
            MIXEDMARK: "mdc-checkbox__mixedmark",
            NATIVE_CONTROL: "mdc-checkbox__native-control",
            ROOT: "mdc-checkbox",
            SELECTED: "mdc-checkbox--selected",
            UPGRADED: "mdc-checkbox--upgraded"
        };
        var checkbox_constants_strings = {
            ARIA_CHECKED_ATTR: "aria-checked",
            ARIA_CHECKED_INDETERMINATE_VALUE: "mixed",
            DATA_INDETERMINATE_ATTR: "data-indeterminate",
            NATIVE_CONTROL_SELECTOR: ".mdc-checkbox__native-control",
            TRANSITION_STATE_CHECKED: "checked",
            TRANSITION_STATE_INDETERMINATE: "indeterminate",
            TRANSITION_STATE_INIT: "init",
            TRANSITION_STATE_UNCHECKED: "unchecked"
        };
        var checkbox_constants_numbers = {
            ANIM_END_LATCH_MS: 250
        };
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCCheckboxFoundation = function(_super) {
            __extends(MDCCheckboxFoundation, _super);
            function MDCCheckboxFoundation(adapter) {
                var _this = _super.call(this, __assign(__assign({}, MDCCheckboxFoundation.defaultAdapter), adapter)) || this;
                _this.currentCheckState_ = checkbox_constants_strings.TRANSITION_STATE_INIT;
                _this.currentAnimationClass_ = "";
                _this.animEndLatchTimer_ = 0;
                _this.enableAnimationEndHandler_ = false;
                return _this;
            }
            Object.defineProperty(MDCCheckboxFoundation, "cssClasses", {
                get: function() {
                    return checkbox_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCCheckboxFoundation, "strings", {
                get: function() {
                    return checkbox_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCCheckboxFoundation, "numbers", {
                get: function() {
                    return checkbox_constants_numbers;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCCheckboxFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClass: function() {
                            return undefined;
                        },
                        forceLayout: function() {
                            return undefined;
                        },
                        hasNativeControl: function() {
                            return false;
                        },
                        isAttachedToDOM: function() {
                            return false;
                        },
                        isChecked: function() {
                            return false;
                        },
                        isIndeterminate: function() {
                            return false;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        removeNativeControlAttr: function() {
                            return undefined;
                        },
                        setNativeControlAttr: function() {
                            return undefined;
                        },
                        setNativeControlDisabled: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCCheckboxFoundation.prototype.init = function() {
                this.currentCheckState_ = this.determineCheckState_();
                this.updateAriaChecked_();
                this.adapter.addClass(checkbox_constants_cssClasses.UPGRADED);
            };
            MDCCheckboxFoundation.prototype.destroy = function() {
                clearTimeout(this.animEndLatchTimer_);
            };
            MDCCheckboxFoundation.prototype.setDisabled = function(disabled) {
                this.adapter.setNativeControlDisabled(disabled);
                if (disabled) {
                    this.adapter.addClass(checkbox_constants_cssClasses.DISABLED);
                } else {
                    this.adapter.removeClass(checkbox_constants_cssClasses.DISABLED);
                }
            };
            MDCCheckboxFoundation.prototype.handleAnimationEnd = function() {
                var _this = this;
                if (!this.enableAnimationEndHandler_) {
                    return;
                }
                clearTimeout(this.animEndLatchTimer_);
                this.animEndLatchTimer_ = setTimeout((function() {
                    _this.adapter.removeClass(_this.currentAnimationClass_);
                    _this.enableAnimationEndHandler_ = false;
                }), checkbox_constants_numbers.ANIM_END_LATCH_MS);
            };
            MDCCheckboxFoundation.prototype.handleChange = function() {
                this.transitionCheckState_();
            };
            MDCCheckboxFoundation.prototype.transitionCheckState_ = function() {
                if (!this.adapter.hasNativeControl()) {
                    return;
                }
                var oldState = this.currentCheckState_;
                var newState = this.determineCheckState_();
                if (oldState === newState) {
                    return;
                }
                this.updateAriaChecked_();
                var TRANSITION_STATE_UNCHECKED = checkbox_constants_strings.TRANSITION_STATE_UNCHECKED;
                var SELECTED = checkbox_constants_cssClasses.SELECTED;
                if (newState === TRANSITION_STATE_UNCHECKED) {
                    this.adapter.removeClass(SELECTED);
                } else {
                    this.adapter.addClass(SELECTED);
                }
                if (this.currentAnimationClass_.length > 0) {
                    clearTimeout(this.animEndLatchTimer_);
                    this.adapter.forceLayout();
                    this.adapter.removeClass(this.currentAnimationClass_);
                }
                this.currentAnimationClass_ = this.getTransitionAnimationClass_(oldState, newState);
                this.currentCheckState_ = newState;
                if (this.adapter.isAttachedToDOM() && this.currentAnimationClass_.length > 0) {
                    this.adapter.addClass(this.currentAnimationClass_);
                    this.enableAnimationEndHandler_ = true;
                }
            };
            MDCCheckboxFoundation.prototype.determineCheckState_ = function() {
                var TRANSITION_STATE_INDETERMINATE = checkbox_constants_strings.TRANSITION_STATE_INDETERMINATE, TRANSITION_STATE_CHECKED = checkbox_constants_strings.TRANSITION_STATE_CHECKED, TRANSITION_STATE_UNCHECKED = checkbox_constants_strings.TRANSITION_STATE_UNCHECKED;
                if (this.adapter.isIndeterminate()) {
                    return TRANSITION_STATE_INDETERMINATE;
                }
                return this.adapter.isChecked() ? TRANSITION_STATE_CHECKED : TRANSITION_STATE_UNCHECKED;
            };
            MDCCheckboxFoundation.prototype.getTransitionAnimationClass_ = function(oldState, newState) {
                var TRANSITION_STATE_INIT = checkbox_constants_strings.TRANSITION_STATE_INIT, TRANSITION_STATE_CHECKED = checkbox_constants_strings.TRANSITION_STATE_CHECKED, TRANSITION_STATE_UNCHECKED = checkbox_constants_strings.TRANSITION_STATE_UNCHECKED;
                var _a = MDCCheckboxFoundation.cssClasses, ANIM_UNCHECKED_CHECKED = _a.ANIM_UNCHECKED_CHECKED, ANIM_UNCHECKED_INDETERMINATE = _a.ANIM_UNCHECKED_INDETERMINATE, ANIM_CHECKED_UNCHECKED = _a.ANIM_CHECKED_UNCHECKED, ANIM_CHECKED_INDETERMINATE = _a.ANIM_CHECKED_INDETERMINATE, ANIM_INDETERMINATE_CHECKED = _a.ANIM_INDETERMINATE_CHECKED, ANIM_INDETERMINATE_UNCHECKED = _a.ANIM_INDETERMINATE_UNCHECKED;
                switch (oldState) {
                  case TRANSITION_STATE_INIT:
                    if (newState === TRANSITION_STATE_UNCHECKED) {
                        return "";
                    }
                    return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;

                  case TRANSITION_STATE_UNCHECKED:
                    return newState === TRANSITION_STATE_CHECKED ? ANIM_UNCHECKED_CHECKED : ANIM_UNCHECKED_INDETERMINATE;

                  case TRANSITION_STATE_CHECKED:
                    return newState === TRANSITION_STATE_UNCHECKED ? ANIM_CHECKED_UNCHECKED : ANIM_CHECKED_INDETERMINATE;

                  default:
                    return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
                }
            };
            MDCCheckboxFoundation.prototype.updateAriaChecked_ = function() {
                if (this.adapter.isIndeterminate()) {
                    this.adapter.setNativeControlAttr(checkbox_constants_strings.ARIA_CHECKED_ATTR, checkbox_constants_strings.ARIA_CHECKED_INDETERMINATE_VALUE);
                } else {
                    this.adapter.removeNativeControlAttr(checkbox_constants_strings.ARIA_CHECKED_ATTR);
                }
            };
            return MDCCheckboxFoundation;
        }(MDCFoundation);
        const checkbox_foundation = null && MDCCheckboxFoundation;
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var CB_PROTO_PROPS = [ "checked", "indeterminate" ];
        var MDCCheckbox = function(_super) {
            __extends(MDCCheckbox, _super);
            function MDCCheckbox() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.ripple_ = _this.createRipple_();
                return _this;
            }
            MDCCheckbox.attachTo = function(root) {
                return new MDCCheckbox(root);
            };
            Object.defineProperty(MDCCheckbox.prototype, "ripple", {
                get: function() {
                    return this.ripple_;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCCheckbox.prototype, "checked", {
                get: function() {
                    return this.nativeControl_.checked;
                },
                set: function(checked) {
                    this.nativeControl_.checked = checked;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCCheckbox.prototype, "indeterminate", {
                get: function() {
                    return this.nativeControl_.indeterminate;
                },
                set: function(indeterminate) {
                    this.nativeControl_.indeterminate = indeterminate;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCCheckbox.prototype, "disabled", {
                get: function() {
                    return this.nativeControl_.disabled;
                },
                set: function(disabled) {
                    this.foundation.setDisabled(disabled);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCCheckbox.prototype, "value", {
                get: function() {
                    return this.nativeControl_.value;
                },
                set: function(value) {
                    this.nativeControl_.value = value;
                },
                enumerable: true,
                configurable: true
            });
            MDCCheckbox.prototype.initialize = function() {
                var DATA_INDETERMINATE_ATTR = checkbox_constants_strings.DATA_INDETERMINATE_ATTR;
                this.nativeControl_.indeterminate = this.nativeControl_.getAttribute(DATA_INDETERMINATE_ATTR) === "true";
                this.nativeControl_.removeAttribute(DATA_INDETERMINATE_ATTR);
            };
            MDCCheckbox.prototype.initialSyncWithDOM = function() {
                var _this = this;
                this.handleChange_ = function() {
                    return _this.foundation.handleChange();
                };
                this.handleAnimationEnd_ = function() {
                    return _this.foundation.handleAnimationEnd();
                };
                this.nativeControl_.addEventListener("change", this.handleChange_);
                this.listen(getCorrectEventName(window, "animationend"), this.handleAnimationEnd_);
                this.installPropertyChangeHooks_();
            };
            MDCCheckbox.prototype.destroy = function() {
                this.ripple_.destroy();
                this.nativeControl_.removeEventListener("change", this.handleChange_);
                this.unlisten(getCorrectEventName(window, "animationend"), this.handleAnimationEnd_);
                this.uninstallPropertyChangeHooks_();
                _super.prototype.destroy.call(this);
            };
            MDCCheckbox.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    addClass: function(className) {
                        return _this.root.classList.add(className);
                    },
                    forceLayout: function() {
                        return _this.root.offsetWidth;
                    },
                    hasNativeControl: function() {
                        return !!_this.nativeControl_;
                    },
                    isAttachedToDOM: function() {
                        return Boolean(_this.root.parentNode);
                    },
                    isChecked: function() {
                        return _this.checked;
                    },
                    isIndeterminate: function() {
                        return _this.indeterminate;
                    },
                    removeClass: function(className) {
                        _this.root.classList.remove(className);
                    },
                    removeNativeControlAttr: function(attr) {
                        _this.nativeControl_.removeAttribute(attr);
                    },
                    setNativeControlAttr: function(attr, value) {
                        _this.nativeControl_.setAttribute(attr, value);
                    },
                    setNativeControlDisabled: function(disabled) {
                        _this.nativeControl_.disabled = disabled;
                    }
                };
                return new MDCCheckboxFoundation(adapter);
            };
            MDCCheckbox.prototype.createRipple_ = function() {
                var _this = this;
                var adapter = __assign(__assign({}, MDCRipple.createAdapter(this)), {
                    deregisterInteractionHandler: function(evtType, handler) {
                        return _this.nativeControl_.removeEventListener(evtType, handler, applyPassive());
                    },
                    isSurfaceActive: function() {
                        return matches(_this.nativeControl_, ":active");
                    },
                    isUnbounded: function() {
                        return true;
                    },
                    registerInteractionHandler: function(evtType, handler) {
                        return _this.nativeControl_.addEventListener(evtType, handler, applyPassive());
                    }
                });
                return new MDCRipple(this.root, new MDCRippleFoundation(adapter));
            };
            MDCCheckbox.prototype.installPropertyChangeHooks_ = function() {
                var _this = this;
                var nativeCb = this.nativeControl_;
                var cbProto = Object.getPrototypeOf(nativeCb);
                CB_PROTO_PROPS.forEach((function(controlState) {
                    var desc = Object.getOwnPropertyDescriptor(cbProto, controlState);
                    if (!validDescriptor(desc)) {
                        return;
                    }
                    var nativeGetter = desc.get;
                    var nativeCbDesc = {
                        configurable: desc.configurable,
                        enumerable: desc.enumerable,
                        get: nativeGetter,
                        set: function(state) {
                            desc.set.call(nativeCb, state);
                            _this.foundation.handleChange();
                        }
                    };
                    Object.defineProperty(nativeCb, controlState, nativeCbDesc);
                }));
            };
            MDCCheckbox.prototype.uninstallPropertyChangeHooks_ = function() {
                var nativeCb = this.nativeControl_;
                var cbProto = Object.getPrototypeOf(nativeCb);
                CB_PROTO_PROPS.forEach((function(controlState) {
                    var desc = Object.getOwnPropertyDescriptor(cbProto, controlState);
                    if (!validDescriptor(desc)) {
                        return;
                    }
                    Object.defineProperty(nativeCb, controlState, desc);
                }));
            };
            Object.defineProperty(MDCCheckbox.prototype, "nativeControl_", {
                get: function() {
                    var NATIVE_CONTROL_SELECTOR = checkbox_constants_strings.NATIVE_CONTROL_SELECTOR;
                    var el = this.root.querySelector(NATIVE_CONTROL_SELECTOR);
                    if (!el) {
                        throw new Error("Checkbox component requires a " + NATIVE_CONTROL_SELECTOR + " element");
                    }
                    return el;
                },
                enumerable: true,
                configurable: true
            });
            return MDCCheckbox;
        }(MDCComponent);
        function validDescriptor(inputPropDesc) {
            return !!inputPropDesc && typeof inputPropDesc.set === "function";
        }
        /**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var form_field_constants_cssClasses = {
            ROOT: "mdc-form-field"
        };
        var form_field_constants_strings = {
            LABEL_SELECTOR: ".mdc-form-field > label"
        };
        /**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCFormFieldFoundation = function(_super) {
            __extends(MDCFormFieldFoundation, _super);
            function MDCFormFieldFoundation(adapter) {
                var _this = _super.call(this, __assign(__assign({}, MDCFormFieldFoundation.defaultAdapter), adapter)) || this;
                _this.click = function() {
                    _this.handleClick();
                };
                return _this;
            }
            Object.defineProperty(MDCFormFieldFoundation, "cssClasses", {
                get: function() {
                    return form_field_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCFormFieldFoundation, "strings", {
                get: function() {
                    return form_field_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCFormFieldFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        activateInputRipple: function() {
                            return undefined;
                        },
                        deactivateInputRipple: function() {
                            return undefined;
                        },
                        deregisterInteractionHandler: function() {
                            return undefined;
                        },
                        registerInteractionHandler: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCFormFieldFoundation.prototype.init = function() {
                this.adapter.registerInteractionHandler("click", this.click);
            };
            MDCFormFieldFoundation.prototype.destroy = function() {
                this.adapter.deregisterInteractionHandler("click", this.click);
            };
            MDCFormFieldFoundation.prototype.handleClick = function() {
                var _this = this;
                this.adapter.activateInputRipple();
                requestAnimationFrame((function() {
                    _this.adapter.deactivateInputRipple();
                }));
            };
            return MDCFormFieldFoundation;
        }(MDCFoundation);
        const form_field_foundation = null && MDCFormFieldFoundation;
        /**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCFormField = function(_super) {
            __extends(MDCFormField, _super);
            function MDCFormField() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCFormField.attachTo = function(root) {
                return new MDCFormField(root);
            };
            MDCFormField.prototype.labelEl = function() {
                var LABEL_SELECTOR = MDCFormFieldFoundation.strings.LABEL_SELECTOR;
                return this.root.querySelector(LABEL_SELECTOR);
            };
            MDCFormField.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    activateInputRipple: function() {
                        if (_this.input && _this.input.ripple) {
                            _this.input.ripple.activate();
                        }
                    },
                    deactivateInputRipple: function() {
                        if (_this.input && _this.input.ripple) {
                            _this.input.ripple.deactivate();
                        }
                    },
                    deregisterInteractionHandler: function(evtType, handler) {
                        var labelEl = _this.labelEl();
                        if (labelEl) {
                            labelEl.removeEventListener(evtType, handler);
                        }
                    },
                    registerInteractionHandler: function(evtType, handler) {
                        var labelEl = _this.labelEl();
                        if (labelEl) {
                            labelEl.addEventListener(evtType, handler);
                        }
                    }
                };
                return new MDCFormFieldFoundation(adapter);
            };
            return MDCFormField;
        }(MDCComponent);
        function MBCheckbox_init(elem, formFieldElem, checked, indeterminate) {
            elem._checkbox = MDCCheckbox.attachTo(elem);
            elem._checkbox.checked = checked;
            elem._checkbox.indeterminate = indeterminate;
            elem._formField = MDCFormField.attachTo(formFieldElem);
            elem._formField.input = elem._checkbox;
        }
        function setChecked(elem, checked) {
            elem._checkbox.checked = checked;
        }
        function setIndeterminate(elem, indeterminate) {
            if ((elem === null || elem === void 0 ? void 0 : elem._checkbox) == null) {
                return;
            }
            elem._checkbox.indeterminate = indeterminate;
        }
        function MBCheckbox_setDisabled(elem, disabled) {
            elem._checkbox.disabled = disabled;
        }
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var circular_progress_constants_cssClasses = {
            INDETERMINATE_CLASS: "mdc-circular-progress--indeterminate",
            CLOSED_CLASS: "mdc-circular-progress--closed"
        };
        var circular_progress_constants_strings = {
            DETERMINATE_CIRCLE_SELECTOR: ".mdc-circular-progress__determinate-circle",
            ARIA_VALUENOW: "aria-valuenow",
            RADIUS: "r",
            STROKE_DASHOFFSET: "stroke-dashoffset"
        };
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCCircularProgressFoundation = function(_super) {
            __extends(MDCCircularProgressFoundation, _super);
            function MDCCircularProgressFoundation(adapter) {
                return _super.call(this, __assign(__assign({}, MDCCircularProgressFoundation.defaultAdapter), adapter)) || this;
            }
            Object.defineProperty(MDCCircularProgressFoundation, "cssClasses", {
                get: function() {
                    return circular_progress_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCCircularProgressFoundation, "strings", {
                get: function() {
                    return circular_progress_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCCircularProgressFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClass: function() {
                            return undefined;
                        },
                        getDeterminateCircleAttribute: function() {
                            return null;
                        },
                        hasClass: function() {
                            return false;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        removeAttribute: function() {
                            return undefined;
                        },
                        setAttribute: function() {
                            return undefined;
                        },
                        setDeterminateCircleAttribute: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCCircularProgressFoundation.prototype.init = function() {
                this.isClosed_ = this.adapter.hasClass(circular_progress_constants_cssClasses.CLOSED_CLASS);
                this.isDeterminate_ = !this.adapter.hasClass(circular_progress_constants_cssClasses.INDETERMINATE_CLASS);
                this.progress_ = 0;
                if (this.isDeterminate_) {
                    this.adapter.setAttribute(circular_progress_constants_strings.ARIA_VALUENOW, this.progress_.toString());
                }
                this.radius_ = Number(this.adapter.getDeterminateCircleAttribute(circular_progress_constants_strings.RADIUS));
            };
            MDCCircularProgressFoundation.prototype.isDeterminate = function() {
                return this.isDeterminate_;
            };
            MDCCircularProgressFoundation.prototype.getProgress = function() {
                return this.progress_;
            };
            MDCCircularProgressFoundation.prototype.isClosed = function() {
                return this.isClosed_;
            };
            MDCCircularProgressFoundation.prototype.setDeterminate = function(isDeterminate) {
                this.isDeterminate_ = isDeterminate;
                if (this.isDeterminate_) {
                    this.adapter.removeClass(circular_progress_constants_cssClasses.INDETERMINATE_CLASS);
                    this.setProgress(this.progress_);
                } else {
                    this.adapter.addClass(circular_progress_constants_cssClasses.INDETERMINATE_CLASS);
                    this.adapter.removeAttribute(circular_progress_constants_strings.ARIA_VALUENOW);
                }
            };
            MDCCircularProgressFoundation.prototype.setProgress = function(value) {
                this.progress_ = value;
                if (this.isDeterminate_) {
                    var unfilledArcLength = (1 - this.progress_) * (2 * Math.PI * this.radius_);
                    this.adapter.setDeterminateCircleAttribute(circular_progress_constants_strings.STROKE_DASHOFFSET, "" + unfilledArcLength);
                    this.adapter.setAttribute(circular_progress_constants_strings.ARIA_VALUENOW, this.progress_.toString());
                }
            };
            MDCCircularProgressFoundation.prototype.open = function() {
                this.isClosed_ = false;
                this.adapter.removeClass(circular_progress_constants_cssClasses.CLOSED_CLASS);
            };
            MDCCircularProgressFoundation.prototype.close = function() {
                this.isClosed_ = true;
                this.adapter.addClass(circular_progress_constants_cssClasses.CLOSED_CLASS);
            };
            return MDCCircularProgressFoundation;
        }(MDCFoundation);
        const circular_progress_foundation = null && MDCCircularProgressFoundation;
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCCircularProgress = function(_super) {
            __extends(MDCCircularProgress, _super);
            function MDCCircularProgress() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCCircularProgress.prototype.initialize = function() {
                this.determinateCircle_ = this.root.querySelector(MDCCircularProgressFoundation.strings.DETERMINATE_CIRCLE_SELECTOR);
            };
            MDCCircularProgress.attachTo = function(root) {
                return new MDCCircularProgress(root);
            };
            Object.defineProperty(MDCCircularProgress.prototype, "determinate", {
                set: function(value) {
                    this.foundation.setDeterminate(value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCCircularProgress.prototype, "progress", {
                set: function(value) {
                    this.foundation.setProgress(value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCCircularProgress.prototype, "isClosed", {
                get: function() {
                    return this.foundation.isClosed();
                },
                enumerable: true,
                configurable: true
            });
            MDCCircularProgress.prototype.open = function() {
                this.foundation.open();
            };
            MDCCircularProgress.prototype.close = function() {
                this.foundation.close();
            };
            MDCCircularProgress.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    addClass: function(className) {
                        return _this.root.classList.add(className);
                    },
                    getDeterminateCircleAttribute: function(attributeName) {
                        return _this.determinateCircle_.getAttribute(attributeName);
                    },
                    hasClass: function(className) {
                        return _this.root.classList.contains(className);
                    },
                    removeClass: function(className) {
                        return _this.root.classList.remove(className);
                    },
                    removeAttribute: function(attributeName) {
                        return _this.root.removeAttribute(attributeName);
                    },
                    setAttribute: function(attributeName, value) {
                        return _this.root.setAttribute(attributeName, value);
                    },
                    setDeterminateCircleAttribute: function(attributeName, value) {
                        return _this.determinateCircle_.setAttribute(attributeName, value);
                    }
                };
                return new MDCCircularProgressFoundation(adapter);
            };
            return MDCCircularProgress;
        }(MDCComponent);
        function MBCircularProgress_init(elem, progress) {
            elem._circularProgress = MDCCircularProgress.attachTo(elem);
            setProgress(elem, progress);
        }
        function setProgress(elem, progress) {
            elem._circularProgress.progress = progress;
        }
        /**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var linear_progress_constants_cssClasses = {
            CLOSED_CLASS: "mdc-linear-progress--closed",
            CLOSED_ANIMATION_OFF_CLASS: "mdc-linear-progress--closed-animation-off",
            INDETERMINATE_CLASS: "mdc-linear-progress--indeterminate",
            REVERSED_CLASS: "mdc-linear-progress--reversed",
            ANIMATION_READY_CLASS: "mdc-linear-progress--animation-ready"
        };
        var linear_progress_constants_strings = {
            ARIA_VALUEMAX: "aria-valuemax",
            ARIA_VALUEMIN: "aria-valuemin",
            ARIA_VALUENOW: "aria-valuenow",
            BUFFER_BAR_SELECTOR: ".mdc-linear-progress__buffer-bar",
            FLEX_BASIS: "flex-basis",
            PRIMARY_BAR_SELECTOR: ".mdc-linear-progress__primary-bar"
        };
        var animationDimensionPercentages = {
            PRIMARY_HALF: .8367142,
            PRIMARY_FULL: 2.00611057,
            SECONDARY_QUARTER: .37651913,
            SECONDARY_HALF: .84386165,
            SECONDARY_FULL: 1.60277782
        };
        /**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCLinearProgressFoundation = function(_super) {
            __extends(MDCLinearProgressFoundation, _super);
            function MDCLinearProgressFoundation(adapter) {
                var _this = _super.call(this, __assign(__assign({}, MDCLinearProgressFoundation.defaultAdapter), adapter)) || this;
                _this.observer = null;
                return _this;
            }
            Object.defineProperty(MDCLinearProgressFoundation, "cssClasses", {
                get: function() {
                    return linear_progress_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCLinearProgressFoundation, "strings", {
                get: function() {
                    return linear_progress_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCLinearProgressFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClass: function() {
                            return undefined;
                        },
                        attachResizeObserver: function() {
                            return null;
                        },
                        forceLayout: function() {
                            return undefined;
                        },
                        getWidth: function() {
                            return 0;
                        },
                        hasClass: function() {
                            return false;
                        },
                        setBufferBarStyle: function() {
                            return null;
                        },
                        setPrimaryBarStyle: function() {
                            return null;
                        },
                        setStyle: function() {
                            return undefined;
                        },
                        removeAttribute: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        setAttribute: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCLinearProgressFoundation.prototype.init = function() {
                var _this = this;
                this.isDeterminate = !this.adapter.hasClass(linear_progress_constants_cssClasses.INDETERMINATE_CLASS);
                this.adapter.addClass(linear_progress_constants_cssClasses.ANIMATION_READY_CLASS);
                this.isReversed = this.adapter.hasClass(linear_progress_constants_cssClasses.REVERSED_CLASS);
                this.progress = 0;
                this.buffer = 1;
                this.observer = this.adapter.attachResizeObserver((function(entries) {
                    var e_1, _a;
                    if (_this.isDeterminate) {
                        return;
                    }
                    try {
                        for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
                            var entry = entries_1_1.value;
                            if (entry.contentRect) {
                                _this.calculateAndSetDimensions(entry.contentRect.width);
                            }
                        }
                    } catch (e_1_1) {
                        e_1 = {
                            error: e_1_1
                        };
                    } finally {
                        try {
                            if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return)) _a.call(entries_1);
                        } finally {
                            if (e_1) throw e_1.error;
                        }
                    }
                }));
                if (!this.isDeterminate && this.observer) {
                    this.calculateAndSetDimensions(this.adapter.getWidth());
                }
            };
            MDCLinearProgressFoundation.prototype.setDeterminate = function(isDeterminate) {
                this.isDeterminate = isDeterminate;
                if (this.isDeterminate) {
                    this.adapter.removeClass(linear_progress_constants_cssClasses.INDETERMINATE_CLASS);
                    this.adapter.setAttribute(linear_progress_constants_strings.ARIA_VALUENOW, this.progress.toString());
                    this.adapter.setAttribute(linear_progress_constants_strings.ARIA_VALUEMAX, "1");
                    this.adapter.setAttribute(linear_progress_constants_strings.ARIA_VALUEMIN, "0");
                    this.setPrimaryBarProgress(this.progress);
                    this.setBufferBarProgress(this.buffer);
                    return;
                }
                if (this.isReversed) {
                    this.adapter.removeClass(linear_progress_constants_cssClasses.REVERSED_CLASS);
                    this.adapter.forceLayout();
                    this.adapter.addClass(linear_progress_constants_cssClasses.REVERSED_CLASS);
                }
                if (this.observer) {
                    this.calculateAndSetDimensions(this.adapter.getWidth());
                }
                this.adapter.addClass(linear_progress_constants_cssClasses.INDETERMINATE_CLASS);
                this.adapter.removeAttribute(linear_progress_constants_strings.ARIA_VALUENOW);
                this.adapter.removeAttribute(linear_progress_constants_strings.ARIA_VALUEMAX);
                this.adapter.removeAttribute(linear_progress_constants_strings.ARIA_VALUEMIN);
                this.setPrimaryBarProgress(1);
                this.setBufferBarProgress(1);
            };
            MDCLinearProgressFoundation.prototype.getDeterminate = function() {
                return this.isDeterminate;
            };
            MDCLinearProgressFoundation.prototype.setProgress = function(value) {
                this.progress = value;
                if (this.isDeterminate) {
                    this.setPrimaryBarProgress(value);
                    this.adapter.setAttribute(linear_progress_constants_strings.ARIA_VALUENOW, value.toString());
                }
            };
            MDCLinearProgressFoundation.prototype.getProgress = function() {
                return this.progress;
            };
            MDCLinearProgressFoundation.prototype.setBuffer = function(value) {
                this.buffer = value;
                if (this.isDeterminate) {
                    this.setBufferBarProgress(value);
                }
            };
            MDCLinearProgressFoundation.prototype.setReverse = function(isReversed) {
                this.isReversed = isReversed;
                if (!this.isDeterminate) {
                    this.restartAnimation();
                }
                if (this.isReversed) {
                    this.adapter.addClass(linear_progress_constants_cssClasses.REVERSED_CLASS);
                    return;
                }
                this.adapter.removeClass(linear_progress_constants_cssClasses.REVERSED_CLASS);
            };
            MDCLinearProgressFoundation.prototype.open = function() {
                this.adapter.removeClass(linear_progress_constants_cssClasses.CLOSED_CLASS);
                this.adapter.removeClass(linear_progress_constants_cssClasses.CLOSED_ANIMATION_OFF_CLASS);
            };
            MDCLinearProgressFoundation.prototype.close = function() {
                this.adapter.addClass(linear_progress_constants_cssClasses.CLOSED_CLASS);
            };
            MDCLinearProgressFoundation.prototype.handleTransitionEnd = function() {
                if (this.adapter.hasClass(linear_progress_constants_cssClasses.CLOSED_CLASS)) {
                    this.adapter.addClass(linear_progress_constants_cssClasses.CLOSED_ANIMATION_OFF_CLASS);
                }
            };
            MDCLinearProgressFoundation.prototype.destroy = function() {
                _super.prototype.destroy.call(this);
                if (this.observer) {
                    this.observer.disconnect();
                }
            };
            MDCLinearProgressFoundation.prototype.setPrimaryBarProgress = function(progressValue) {
                var value = "scaleX(" + progressValue + ")";
                var transformProp = typeof window !== "undefined" ? getCorrectPropertyName(window, "transform") : "transform";
                this.adapter.setPrimaryBarStyle(transformProp, value);
            };
            MDCLinearProgressFoundation.prototype.setBufferBarProgress = function(progressValue) {
                var value = progressValue * 100 + "%";
                this.adapter.setBufferBarStyle(linear_progress_constants_strings.FLEX_BASIS, value);
            };
            MDCLinearProgressFoundation.prototype.restartAnimation = function() {
                this.adapter.removeClass(linear_progress_constants_cssClasses.ANIMATION_READY_CLASS);
                this.adapter.forceLayout();
                this.adapter.addClass(linear_progress_constants_cssClasses.ANIMATION_READY_CLASS);
            };
            MDCLinearProgressFoundation.prototype.calculateAndSetDimensions = function(width) {
                var primaryHalf = width * animationDimensionPercentages.PRIMARY_HALF;
                var primaryFull = width * animationDimensionPercentages.PRIMARY_FULL;
                var secondaryQuarter = width * animationDimensionPercentages.SECONDARY_QUARTER;
                var secondaryHalf = width * animationDimensionPercentages.SECONDARY_HALF;
                var secondaryFull = width * animationDimensionPercentages.SECONDARY_FULL;
                this.adapter.setStyle("--mdc-linear-progress-primary-half", primaryHalf + "px");
                this.adapter.setStyle("--mdc-linear-progress-primary-half-neg", -primaryHalf + "px");
                this.adapter.setStyle("--mdc-linear-progress-primary-full", primaryFull + "px");
                this.adapter.setStyle("--mdc-linear-progress-primary-full-neg", -primaryFull + "px");
                this.adapter.setStyle("--mdc-linear-progress-secondary-quarter", secondaryQuarter + "px");
                this.adapter.setStyle("--mdc-linear-progress-secondary-quarter-neg", -secondaryQuarter + "px");
                this.adapter.setStyle("--mdc-linear-progress-secondary-half", secondaryHalf + "px");
                this.adapter.setStyle("--mdc-linear-progress-secondary-half-neg", -secondaryHalf + "px");
                this.adapter.setStyle("--mdc-linear-progress-secondary-full", secondaryFull + "px");
                this.adapter.setStyle("--mdc-linear-progress-secondary-full-neg", -secondaryFull + "px");
                this.restartAnimation();
            };
            return MDCLinearProgressFoundation;
        }(MDCFoundation);
        const linear_progress_foundation = null && MDCLinearProgressFoundation;
        /**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCLinearProgress = function(_super) {
            __extends(MDCLinearProgress, _super);
            function MDCLinearProgress() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCLinearProgress.attachTo = function(root) {
                return new MDCLinearProgress(root);
            };
            Object.defineProperty(MDCLinearProgress.prototype, "determinate", {
                set: function(value) {
                    this.foundation.setDeterminate(value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCLinearProgress.prototype, "progress", {
                set: function(value) {
                    this.foundation.setProgress(value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCLinearProgress.prototype, "buffer", {
                set: function(value) {
                    this.foundation.setBuffer(value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCLinearProgress.prototype, "reverse", {
                set: function(value) {
                    this.foundation.setReverse(value);
                },
                enumerable: true,
                configurable: true
            });
            MDCLinearProgress.prototype.open = function() {
                this.foundation.open();
            };
            MDCLinearProgress.prototype.close = function() {
                this.foundation.close();
            };
            MDCLinearProgress.prototype.initialSyncWithDOM = function() {
                var _this = this;
                this.root.addEventListener("transitionend", (function() {
                    _this.foundation.handleTransitionEnd();
                }));
            };
            MDCLinearProgress.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    addClass: function(className) {
                        _this.root.classList.add(className);
                    },
                    forceLayout: function() {
                        _this.root.getBoundingClientRect();
                    },
                    setBufferBarStyle: function(styleProperty, value) {
                        var bufferBar = _this.root.querySelector(MDCLinearProgressFoundation.strings.BUFFER_BAR_SELECTOR);
                        if (bufferBar) {
                            bufferBar.style.setProperty(styleProperty, value);
                        }
                    },
                    setPrimaryBarStyle: function(styleProperty, value) {
                        var primaryBar = _this.root.querySelector(MDCLinearProgressFoundation.strings.PRIMARY_BAR_SELECTOR);
                        if (primaryBar) {
                            primaryBar.style.setProperty(styleProperty, value);
                        }
                    },
                    hasClass: function(className) {
                        return _this.root.classList.contains(className);
                    },
                    removeAttribute: function(attributeName) {
                        _this.root.removeAttribute(attributeName);
                    },
                    removeClass: function(className) {
                        _this.root.classList.remove(className);
                    },
                    setAttribute: function(attributeName, value) {
                        _this.root.setAttribute(attributeName, value);
                    },
                    setStyle: function(name, value) {
                        _this.root.style.setProperty(name, value);
                    },
                    attachResizeObserver: function(callback) {
                        if (window.ResizeObserver) {
                            var ro = new ResizeObserver(callback);
                            ro.observe(_this.root);
                            return ro;
                        }
                        return null;
                    },
                    getWidth: function() {
                        return _this.root.offsetWidth;
                    }
                };
                return new MDCLinearProgressFoundation(adapter);
            };
            return MDCLinearProgress;
        }(MDCComponent);
        /**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var data_table_constants_cssClasses = {
            CELL: "mdc-data-table__cell",
            CELL_NUMERIC: "mdc-data-table__cell--numeric",
            CONTENT: "mdc-data-table__content",
            HEADER_CELL: "mdc-data-table__header-cell",
            HEADER_CELL_LABEL: "mdc-data-table__header-cell-label",
            HEADER_CELL_SORTED: "mdc-data-table__header-cell--sorted",
            HEADER_CELL_SORTED_DESCENDING: "mdc-data-table__header-cell--sorted-descending",
            HEADER_CELL_WITH_SORT: "mdc-data-table__header-cell--with-sort",
            HEADER_CELL_WRAPPER: "mdc-data-table__header-cell-wrapper",
            HEADER_ROW: "mdc-data-table__header-row",
            HEADER_ROW_CHECKBOX: "mdc-data-table__header-row-checkbox",
            IN_PROGRESS: "mdc-data-table--in-progress",
            LINEAR_PROGRESS: "mdc-data-table__linear-progress",
            PAGINATION_ROWS_PER_PAGE_LABEL: "mdc-data-table__pagination-rows-per-page-label",
            PAGINATION_ROWS_PER_PAGE_SELECT: "mdc-data-table__pagination-rows-per-page-select",
            PROGRESS_INDICATOR: "mdc-data-table__progress-indicator",
            ROOT: "mdc-data-table",
            ROW: "mdc-data-table__row",
            ROW_CHECKBOX: "mdc-data-table__row-checkbox",
            ROW_SELECTED: "mdc-data-table__row--selected",
            SORT_ICON_BUTTON: "mdc-data-table__sort-icon-button",
            SORT_STATUS_LABEL: "mdc-data-table__sort-status-label",
            TABLE_CONTAINER: "mdc-data-table__table-container"
        };
        var attributes = {
            ARIA_SELECTED: "aria-selected",
            ARIA_SORT: "aria-sort"
        };
        var dataAttributes = {
            COLUMN_ID: "data-column-id",
            ROW_ID: "data-row-id"
        };
        var selectors = {
            CONTENT: "." + data_table_constants_cssClasses.CONTENT,
            HEADER_CELL: "." + data_table_constants_cssClasses.HEADER_CELL,
            HEADER_CELL_WITH_SORT: "." + data_table_constants_cssClasses.HEADER_CELL_WITH_SORT,
            HEADER_ROW: "." + data_table_constants_cssClasses.HEADER_ROW,
            HEADER_ROW_CHECKBOX: "." + data_table_constants_cssClasses.HEADER_ROW_CHECKBOX,
            PROGRESS_INDICATOR: "." + data_table_constants_cssClasses.PROGRESS_INDICATOR,
            ROW: "." + data_table_constants_cssClasses.ROW,
            ROW_CHECKBOX: "." + data_table_constants_cssClasses.ROW_CHECKBOX,
            ROW_SELECTED: "." + data_table_constants_cssClasses.ROW_SELECTED,
            SORT_ICON_BUTTON: "." + data_table_constants_cssClasses.SORT_ICON_BUTTON,
            SORT_STATUS_LABEL: "." + data_table_constants_cssClasses.SORT_STATUS_LABEL
        };
        var messages = {
            SORTED_IN_DESCENDING: "Sorted in descending order",
            SORTED_IN_ASCENDING: "Sorted in ascending order"
        };
        var data_table_constants_strings = {
            ARIA_SELECTED: attributes.ARIA_SELECTED,
            ARIA_SORT: attributes.ARIA_SORT,
            DATA_ROW_ID_ATTR: dataAttributes.ROW_ID,
            HEADER_ROW_CHECKBOX_SELECTOR: selectors.HEADER_ROW_CHECKBOX,
            ROW_CHECKBOX_SELECTOR: selectors.ROW_CHECKBOX,
            ROW_SELECTED_SELECTOR: selectors.ROW_SELECTED,
            ROW_SELECTOR: selectors.ROW
        };
        var SortValue;
        (function(SortValue) {
            SortValue["ASCENDING"] = "ascending";
            SortValue["DESCENDING"] = "descending";
            SortValue["NONE"] = "none";
            SortValue["OTHER"] = "other";
        })(SortValue || (SortValue = {}));
        var events = {
            ROW_SELECTION_CHANGED: "MDCDataTable:rowSelectionChanged",
            SELECTED_ALL: "MDCDataTable:selectedAll",
            UNSELECTED_ALL: "MDCDataTable:unselectedAll",
            SORTED: "MDCDataTable:sorted"
        };
        /**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCDataTableFoundation = function(_super) {
            __extends(MDCDataTableFoundation, _super);
            function MDCDataTableFoundation(adapter) {
                return _super.call(this, __assign(__assign({}, MDCDataTableFoundation.defaultAdapter), adapter)) || this;
            }
            Object.defineProperty(MDCDataTableFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClass: function() {
                            return undefined;
                        },
                        addClassAtRowIndex: function() {
                            return undefined;
                        },
                        getAttributeByHeaderCellIndex: function() {
                            return "";
                        },
                        getHeaderCellCount: function() {
                            return 0;
                        },
                        getHeaderCellElements: function() {
                            return [];
                        },
                        getRowCount: function() {
                            return 0;
                        },
                        getRowElements: function() {
                            return [];
                        },
                        getRowIdAtIndex: function() {
                            return "";
                        },
                        getRowIndexByChildElement: function() {
                            return 0;
                        },
                        getSelectedRowCount: function() {
                            return 0;
                        },
                        getTableContainerHeight: function() {
                            return 0;
                        },
                        getTableHeaderHeight: function() {
                            return 0;
                        },
                        isCheckboxAtRowIndexChecked: function() {
                            return false;
                        },
                        isHeaderRowCheckboxChecked: function() {
                            return false;
                        },
                        isRowsSelectable: function() {
                            return false;
                        },
                        notifyRowSelectionChanged: function() {
                            return undefined;
                        },
                        notifySelectedAll: function() {
                            return undefined;
                        },
                        notifySortAction: function() {
                            return undefined;
                        },
                        notifyUnselectedAll: function() {
                            return undefined;
                        },
                        registerHeaderRowCheckbox: function() {
                            return undefined;
                        },
                        registerRowCheckboxes: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        removeClassAtRowIndex: function() {
                            return undefined;
                        },
                        removeClassNameByHeaderCellIndex: function() {
                            return undefined;
                        },
                        setAttributeAtRowIndex: function() {
                            return undefined;
                        },
                        setAttributeByHeaderCellIndex: function() {
                            return undefined;
                        },
                        setClassNameByHeaderCellIndex: function() {
                            return undefined;
                        },
                        setHeaderRowCheckboxChecked: function() {
                            return undefined;
                        },
                        setHeaderRowCheckboxIndeterminate: function() {
                            return undefined;
                        },
                        setProgressIndicatorStyles: function() {
                            return undefined;
                        },
                        setRowCheckboxCheckedAtIndex: function() {
                            return undefined;
                        },
                        setSortStatusLabelByHeaderCellIndex: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCDataTableFoundation.prototype.layout = function() {
                if (this.adapter.isRowsSelectable()) {
                    this.adapter.registerHeaderRowCheckbox();
                    this.adapter.registerRowCheckboxes();
                    this.setHeaderRowCheckboxState();
                }
            };
            MDCDataTableFoundation.prototype.layoutAsync = function() {
                return __awaiter(this, void 0, void 0, (function() {
                    return __generator(this, (function(_a) {
                        switch (_a.label) {
                          case 0:
                            if (!this.adapter.isRowsSelectable()) return [ 3, 3 ];
                            return [ 4, this.adapter.registerHeaderRowCheckbox() ];

                          case 1:
                            _a.sent();
                            return [ 4, this.adapter.registerRowCheckboxes() ];

                          case 2:
                            _a.sent();
                            this.setHeaderRowCheckboxState();
                            _a.label = 3;

                          case 3:
                            return [ 2 ];
                        }
                    }));
                }));
            };
            MDCDataTableFoundation.prototype.getRows = function() {
                return this.adapter.getRowElements();
            };
            MDCDataTableFoundation.prototype.getHeaderCells = function() {
                return this.adapter.getHeaderCellElements();
            };
            MDCDataTableFoundation.prototype.setSelectedRowIds = function(rowIds) {
                for (var rowIndex = 0; rowIndex < this.adapter.getRowCount(); rowIndex++) {
                    var rowId = this.adapter.getRowIdAtIndex(rowIndex);
                    var isSelected = false;
                    if (rowId && rowIds.indexOf(rowId) >= 0) {
                        isSelected = true;
                    }
                    this.adapter.setRowCheckboxCheckedAtIndex(rowIndex, isSelected);
                    this.selectRowAtIndex(rowIndex, isSelected);
                }
                this.setHeaderRowCheckboxState();
            };
            MDCDataTableFoundation.prototype.getRowIds = function() {
                var rowIds = [];
                for (var rowIndex = 0; rowIndex < this.adapter.getRowCount(); rowIndex++) {
                    rowIds.push(this.adapter.getRowIdAtIndex(rowIndex));
                }
                return rowIds;
            };
            MDCDataTableFoundation.prototype.getSelectedRowIds = function() {
                var selectedRowIds = [];
                for (var rowIndex = 0; rowIndex < this.adapter.getRowCount(); rowIndex++) {
                    if (this.adapter.isCheckboxAtRowIndexChecked(rowIndex)) {
                        selectedRowIds.push(this.adapter.getRowIdAtIndex(rowIndex));
                    }
                }
                return selectedRowIds;
            };
            MDCDataTableFoundation.prototype.handleHeaderRowCheckboxChange = function() {
                var isHeaderChecked = this.adapter.isHeaderRowCheckboxChecked();
                for (var rowIndex = 0; rowIndex < this.adapter.getRowCount(); rowIndex++) {
                    this.adapter.setRowCheckboxCheckedAtIndex(rowIndex, isHeaderChecked);
                    this.selectRowAtIndex(rowIndex, isHeaderChecked);
                }
                if (isHeaderChecked) {
                    this.adapter.notifySelectedAll();
                } else {
                    this.adapter.notifyUnselectedAll();
                }
            };
            MDCDataTableFoundation.prototype.handleRowCheckboxChange = function(event) {
                var rowIndex = this.adapter.getRowIndexByChildElement(event.target);
                if (rowIndex === -1) {
                    return;
                }
                var selected = this.adapter.isCheckboxAtRowIndexChecked(rowIndex);
                this.selectRowAtIndex(rowIndex, selected);
                this.setHeaderRowCheckboxState();
                var rowId = this.adapter.getRowIdAtIndex(rowIndex);
                this.adapter.notifyRowSelectionChanged({
                    rowId: rowId,
                    rowIndex: rowIndex,
                    selected: selected
                });
            };
            MDCDataTableFoundation.prototype.handleSortAction = function(eventData) {
                var columnId = eventData.columnId, columnIndex = eventData.columnIndex, headerCell = eventData.headerCell;
                for (var index = 0; index < this.adapter.getHeaderCellCount(); index++) {
                    if (index === columnIndex) {
                        continue;
                    }
                    this.adapter.removeClassNameByHeaderCellIndex(index, data_table_constants_cssClasses.HEADER_CELL_SORTED);
                    this.adapter.removeClassNameByHeaderCellIndex(index, data_table_constants_cssClasses.HEADER_CELL_SORTED_DESCENDING);
                    this.adapter.setAttributeByHeaderCellIndex(index, data_table_constants_strings.ARIA_SORT, SortValue.NONE);
                    this.adapter.setSortStatusLabelByHeaderCellIndex(index, SortValue.NONE);
                }
                this.adapter.setClassNameByHeaderCellIndex(columnIndex, data_table_constants_cssClasses.HEADER_CELL_SORTED);
                var currentSortValue = this.adapter.getAttributeByHeaderCellIndex(columnIndex, data_table_constants_strings.ARIA_SORT);
                var sortValue = SortValue.NONE;
                if (currentSortValue === SortValue.ASCENDING) {
                    this.adapter.setClassNameByHeaderCellIndex(columnIndex, data_table_constants_cssClasses.HEADER_CELL_SORTED_DESCENDING);
                    this.adapter.setAttributeByHeaderCellIndex(columnIndex, data_table_constants_strings.ARIA_SORT, SortValue.DESCENDING);
                    sortValue = SortValue.DESCENDING;
                } else if (currentSortValue === SortValue.DESCENDING) {
                    this.adapter.removeClassNameByHeaderCellIndex(columnIndex, data_table_constants_cssClasses.HEADER_CELL_SORTED_DESCENDING);
                    this.adapter.setAttributeByHeaderCellIndex(columnIndex, data_table_constants_strings.ARIA_SORT, SortValue.ASCENDING);
                    sortValue = SortValue.ASCENDING;
                } else {
                    this.adapter.setAttributeByHeaderCellIndex(columnIndex, data_table_constants_strings.ARIA_SORT, SortValue.ASCENDING);
                    sortValue = SortValue.ASCENDING;
                }
                this.adapter.setSortStatusLabelByHeaderCellIndex(columnIndex, sortValue);
                this.adapter.notifySortAction({
                    columnId: columnId,
                    columnIndex: columnIndex,
                    headerCell: headerCell,
                    sortValue: sortValue
                });
            };
            MDCDataTableFoundation.prototype.showProgress = function() {
                var tableHeaderHeight = this.adapter.getTableHeaderHeight();
                var height = this.adapter.getTableContainerHeight() - tableHeaderHeight;
                var top = tableHeaderHeight;
                this.adapter.setProgressIndicatorStyles({
                    height: height + "px",
                    top: top + "px"
                });
                this.adapter.addClass(data_table_constants_cssClasses.IN_PROGRESS);
            };
            MDCDataTableFoundation.prototype.hideProgress = function() {
                this.adapter.removeClass(data_table_constants_cssClasses.IN_PROGRESS);
            };
            MDCDataTableFoundation.prototype.setHeaderRowCheckboxState = function() {
                if (this.adapter.getSelectedRowCount() === 0) {
                    this.adapter.setHeaderRowCheckboxChecked(false);
                    this.adapter.setHeaderRowCheckboxIndeterminate(false);
                } else if (this.adapter.getSelectedRowCount() === this.adapter.getRowCount()) {
                    this.adapter.setHeaderRowCheckboxChecked(true);
                    this.adapter.setHeaderRowCheckboxIndeterminate(false);
                } else {
                    this.adapter.setHeaderRowCheckboxIndeterminate(true);
                    this.adapter.setHeaderRowCheckboxChecked(false);
                }
            };
            MDCDataTableFoundation.prototype.selectRowAtIndex = function(rowIndex, selected) {
                if (selected) {
                    this.adapter.addClassAtRowIndex(rowIndex, data_table_constants_cssClasses.ROW_SELECTED);
                    this.adapter.setAttributeAtRowIndex(rowIndex, data_table_constants_strings.ARIA_SELECTED, "true");
                } else {
                    this.adapter.removeClassAtRowIndex(rowIndex, data_table_constants_cssClasses.ROW_SELECTED);
                    this.adapter.setAttributeAtRowIndex(rowIndex, data_table_constants_strings.ARIA_SELECTED, "false");
                }
            };
            return MDCDataTableFoundation;
        }(MDCFoundation);
        /**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCDataTable = function(_super) {
            __extends(MDCDataTable, _super);
            function MDCDataTable() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCDataTable.attachTo = function(root) {
                return new MDCDataTable(root);
            };
            MDCDataTable.prototype.initialize = function(checkboxFactory) {
                if (checkboxFactory === void 0) {
                    checkboxFactory = function(el) {
                        return new MDCCheckbox(el);
                    };
                }
                this.checkboxFactory = checkboxFactory;
            };
            MDCDataTable.prototype.initialSyncWithDOM = function() {
                var _this = this;
                this.headerRow = this.root.querySelector("." + data_table_constants_cssClasses.HEADER_ROW);
                this.handleHeaderRowCheckboxChange = function() {
                    _this.foundation.handleHeaderRowCheckboxChange();
                };
                this.headerRow.addEventListener("change", this.handleHeaderRowCheckboxChange);
                this.headerRowClickListener = function(event) {
                    _this.handleHeaderRowClick(event);
                };
                this.headerRow.addEventListener("click", this.headerRowClickListener);
                this.content = this.root.querySelector("." + data_table_constants_cssClasses.CONTENT);
                this.handleRowCheckboxChange = function(event) {
                    _this.foundation.handleRowCheckboxChange(event);
                };
                this.content.addEventListener("change", this.handleRowCheckboxChange);
                this.layout();
            };
            MDCDataTable.prototype.layout = function() {
                this.foundation.layout();
            };
            MDCDataTable.prototype.getHeaderCells = function() {
                return [].slice.call(this.root.querySelectorAll(selectors.HEADER_CELL));
            };
            MDCDataTable.prototype.getRows = function() {
                return this.foundation.getRows();
            };
            MDCDataTable.prototype.getSelectedRowIds = function() {
                return this.foundation.getSelectedRowIds();
            };
            MDCDataTable.prototype.setSelectedRowIds = function(rowIds) {
                this.foundation.setSelectedRowIds(rowIds);
            };
            MDCDataTable.prototype.showProgress = function() {
                this.getLinearProgress().open();
                this.foundation.showProgress();
            };
            MDCDataTable.prototype.hideProgress = function() {
                this.foundation.hideProgress();
                this.getLinearProgress().close();
            };
            MDCDataTable.prototype.destroy = function() {
                var e_1, _a;
                if (this.handleHeaderRowCheckboxChange) {
                    this.headerRow.removeEventListener("change", this.handleHeaderRowCheckboxChange);
                }
                if (this.headerRowClickListener) {
                    this.headerRow.removeEventListener("click", this.headerRowClickListener);
                }
                if (this.handleRowCheckboxChange) {
                    this.content.removeEventListener("change", this.handleRowCheckboxChange);
                }
                if (this.headerRowCheckbox) {
                    this.headerRowCheckbox.destroy();
                }
                if (this.rowCheckboxList) {
                    try {
                        for (var _b = __values(this.rowCheckboxList), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var checkbox = _c.value;
                            checkbox.destroy();
                        }
                    } catch (e_1_1) {
                        e_1 = {
                            error: e_1_1
                        };
                    } finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        } finally {
                            if (e_1) throw e_1.error;
                        }
                    }
                }
            };
            MDCDataTable.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    addClass: function(className) {
                        _this.root.classList.add(className);
                    },
                    removeClass: function(className) {
                        _this.root.classList.remove(className);
                    },
                    getHeaderCellElements: function() {
                        return _this.getHeaderCells();
                    },
                    getHeaderCellCount: function() {
                        return _this.getHeaderCells().length;
                    },
                    getAttributeByHeaderCellIndex: function(index, attribute) {
                        return _this.getHeaderCells()[index].getAttribute(attribute);
                    },
                    setAttributeByHeaderCellIndex: function(index, attribute, value) {
                        _this.getHeaderCells()[index].setAttribute(attribute, value);
                    },
                    setClassNameByHeaderCellIndex: function(index, className) {
                        _this.getHeaderCells()[index].classList.add(className);
                    },
                    removeClassNameByHeaderCellIndex: function(index, className) {
                        _this.getHeaderCells()[index].classList.remove(className);
                    },
                    notifySortAction: function(data) {
                        _this.emit(events.SORTED, data, true);
                    },
                    getTableContainerHeight: function() {
                        var tableContainer = _this.root.querySelector("." + data_table_constants_cssClasses.TABLE_CONTAINER);
                        if (!tableContainer) {
                            throw new Error("MDCDataTable: Table container element not found.");
                        }
                        return tableContainer.getBoundingClientRect().height;
                    },
                    getTableHeaderHeight: function() {
                        var tableHeader = _this.root.querySelector(selectors.HEADER_ROW);
                        if (!tableHeader) {
                            throw new Error("MDCDataTable: Table header element not found.");
                        }
                        return tableHeader.getBoundingClientRect().height;
                    },
                    setProgressIndicatorStyles: function(styles) {
                        var progressIndicator = _this.root.querySelector(selectors.PROGRESS_INDICATOR);
                        if (!progressIndicator) {
                            throw new Error("MDCDataTable: Progress indicator element not found.");
                        }
                        progressIndicator.style.setProperty("height", styles.height);
                        progressIndicator.style.setProperty("top", styles.top);
                    },
                    addClassAtRowIndex: function(rowIndex, className) {
                        _this.getRows()[rowIndex].classList.add(className);
                    },
                    getRowCount: function() {
                        return _this.getRows().length;
                    },
                    getRowElements: function() {
                        return [].slice.call(_this.root.querySelectorAll(selectors.ROW));
                    },
                    getRowIdAtIndex: function(rowIndex) {
                        return _this.getRows()[rowIndex].getAttribute(dataAttributes.ROW_ID);
                    },
                    getRowIndexByChildElement: function(el) {
                        return _this.getRows().indexOf(closest(el, selectors.ROW));
                    },
                    getSelectedRowCount: function() {
                        return _this.root.querySelectorAll(selectors.ROW_SELECTED).length;
                    },
                    isCheckboxAtRowIndexChecked: function(rowIndex) {
                        return _this.rowCheckboxList[rowIndex].checked;
                    },
                    isHeaderRowCheckboxChecked: function() {
                        return _this.headerRowCheckbox.checked;
                    },
                    isRowsSelectable: function() {
                        return !!_this.root.querySelector(selectors.ROW_CHECKBOX) || !!_this.root.querySelector(selectors.HEADER_ROW_CHECKBOX);
                    },
                    notifyRowSelectionChanged: function(data) {
                        _this.emit(events.ROW_SELECTION_CHANGED, {
                            row: _this.getRowByIndex(data.rowIndex),
                            rowId: _this.getRowIdByIndex(data.rowIndex),
                            rowIndex: data.rowIndex,
                            selected: data.selected
                        }, true);
                    },
                    notifySelectedAll: function() {
                        _this.emit(events.SELECTED_ALL, {}, true);
                    },
                    notifyUnselectedAll: function() {
                        _this.emit(events.UNSELECTED_ALL, {}, true);
                    },
                    registerHeaderRowCheckbox: function() {
                        if (_this.headerRowCheckbox) {
                            _this.headerRowCheckbox.destroy();
                        }
                        var checkboxEl = _this.root.querySelector(selectors.HEADER_ROW_CHECKBOX);
                        _this.headerRowCheckbox = _this.checkboxFactory(checkboxEl);
                    },
                    registerRowCheckboxes: function() {
                        if (_this.rowCheckboxList) {
                            _this.rowCheckboxList.forEach((function(checkbox) {
                                checkbox.destroy();
                            }));
                        }
                        _this.rowCheckboxList = [];
                        _this.getRows().forEach((function(rowEl) {
                            var checkbox = _this.checkboxFactory(rowEl.querySelector(selectors.ROW_CHECKBOX));
                            _this.rowCheckboxList.push(checkbox);
                        }));
                    },
                    removeClassAtRowIndex: function(rowIndex, className) {
                        _this.getRows()[rowIndex].classList.remove(className);
                    },
                    setAttributeAtRowIndex: function(rowIndex, attr, value) {
                        _this.getRows()[rowIndex].setAttribute(attr, value);
                    },
                    setHeaderRowCheckboxChecked: function(checked) {
                        _this.headerRowCheckbox.checked = checked;
                    },
                    setHeaderRowCheckboxIndeterminate: function(indeterminate) {
                        _this.headerRowCheckbox.indeterminate = indeterminate;
                    },
                    setRowCheckboxCheckedAtIndex: function(rowIndex, checked) {
                        _this.rowCheckboxList[rowIndex].checked = checked;
                    },
                    setSortStatusLabelByHeaderCellIndex: function(columnIndex, sortValue) {
                        var headerCell = _this.getHeaderCells()[columnIndex];
                        var sortStatusLabel = headerCell.querySelector(selectors.SORT_STATUS_LABEL);
                        if (!sortStatusLabel) return;
                        sortStatusLabel.textContent = _this.getSortStatusMessageBySortValue(sortValue);
                    }
                };
                return new MDCDataTableFoundation(adapter);
            };
            MDCDataTable.prototype.getRowByIndex = function(index) {
                return this.getRows()[index];
            };
            MDCDataTable.prototype.getRowIdByIndex = function(index) {
                return this.getRowByIndex(index).getAttribute(dataAttributes.ROW_ID);
            };
            MDCDataTable.prototype.handleHeaderRowClick = function(event) {
                var headerCell = closest(event.target, selectors.HEADER_CELL_WITH_SORT);
                if (!headerCell) {
                    return;
                }
                var columnId = headerCell.getAttribute(dataAttributes.COLUMN_ID);
                var columnIndex = this.getHeaderCells().indexOf(headerCell);
                if (columnIndex === -1) {
                    return;
                }
                this.foundation.handleSortAction({
                    columnId: columnId,
                    columnIndex: columnIndex,
                    headerCell: headerCell
                });
            };
            MDCDataTable.prototype.getSortStatusMessageBySortValue = function(sortValue) {
                switch (sortValue) {
                  case SortValue.ASCENDING:
                    return messages.SORTED_IN_ASCENDING;

                  case SortValue.DESCENDING:
                    return messages.SORTED_IN_DESCENDING;

                  default:
                    return "";
                }
            };
            MDCDataTable.prototype.getLinearProgressElement = function() {
                var el = this.root.querySelector("." + data_table_constants_cssClasses.LINEAR_PROGRESS);
                if (!el) {
                    throw new Error("MDCDataTable: linear progress element is not found.");
                }
                return el;
            };
            MDCDataTable.prototype.getLinearProgress = function() {
                if (!this.linearProgress) {
                    var el = this.getLinearProgressElement();
                    this.linearProgress = new MDCLinearProgress(el);
                }
                return this.linearProgress;
            };
            return MDCDataTable;
        }(MDCComponent);
        function MBDataTable_init(elem, hasProgress, showProgress) {
            elem._dataTable = MDCDataTable.attachTo(elem);
            if (hasProgress) {
                MBDataTable_setProgress(elem, showProgress);
            }
        }
        function MBDataTable_setProgress(elem, showProgress) {
            if (showProgress) {
                elem._dataTable.showProgress();
            } else {
                elem._dataTable.hideProgress();
            }
        }
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var select_constants_cssClasses = {
            ACTIVATED: "mdc-select--activated",
            DISABLED: "mdc-select--disabled",
            FOCUSED: "mdc-select--focused",
            INVALID: "mdc-select--invalid",
            MENU_INVALID: "mdc-select__menu--invalid",
            OUTLINED: "mdc-select--outlined",
            REQUIRED: "mdc-select--required",
            ROOT: "mdc-select",
            WITH_LEADING_ICON: "mdc-select--with-leading-icon"
        };
        var select_constants_strings = {
            ARIA_CONTROLS: "aria-controls",
            ARIA_DESCRIBEDBY: "aria-describedby",
            ARIA_SELECTED_ATTR: "aria-selected",
            CHANGE_EVENT: "MDCSelect:change",
            HIDDEN_INPUT_SELECTOR: 'input[type="hidden"]',
            LABEL_SELECTOR: ".mdc-floating-label",
            LEADING_ICON_SELECTOR: ".mdc-select__icon",
            LINE_RIPPLE_SELECTOR: ".mdc-line-ripple",
            MENU_SELECTOR: ".mdc-select__menu",
            OUTLINE_SELECTOR: ".mdc-notched-outline",
            SELECTED_TEXT_SELECTOR: ".mdc-select__selected-text",
            SELECT_ANCHOR_SELECTOR: ".mdc-select__anchor",
            VALUE_ATTR: "data-value"
        };
        var select_constants_numbers = {
            LABEL_SCALE: .75,
            UNSET_INDEX: -1,
            CLICK_DEBOUNCE_TIMEOUT_MS: 330
        };
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCSelectFoundation = function(_super) {
            __extends(MDCSelectFoundation, _super);
            function MDCSelectFoundation(adapter, foundationMap) {
                if (foundationMap === void 0) {
                    foundationMap = {};
                }
                var _this = _super.call(this, __assign(__assign({}, MDCSelectFoundation.defaultAdapter), adapter)) || this;
                _this.disabled = false;
                _this.isMenuOpen = false;
                _this.useDefaultValidation = true;
                _this.customValidity = true;
                _this.lastSelectedIndex = select_constants_numbers.UNSET_INDEX;
                _this.clickDebounceTimeout = 0;
                _this.recentlyClicked = false;
                _this.leadingIcon = foundationMap.leadingIcon;
                _this.helperText = foundationMap.helperText;
                return _this;
            }
            Object.defineProperty(MDCSelectFoundation, "cssClasses", {
                get: function() {
                    return select_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSelectFoundation, "numbers", {
                get: function() {
                    return select_constants_numbers;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSelectFoundation, "strings", {
                get: function() {
                    return select_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSelectFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClass: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        hasClass: function() {
                            return false;
                        },
                        activateBottomLine: function() {
                            return undefined;
                        },
                        deactivateBottomLine: function() {
                            return undefined;
                        },
                        getSelectedIndex: function() {
                            return -1;
                        },
                        setSelectedIndex: function() {
                            return undefined;
                        },
                        hasLabel: function() {
                            return false;
                        },
                        floatLabel: function() {
                            return undefined;
                        },
                        getLabelWidth: function() {
                            return 0;
                        },
                        setLabelRequired: function() {
                            return undefined;
                        },
                        hasOutline: function() {
                            return false;
                        },
                        notchOutline: function() {
                            return undefined;
                        },
                        closeOutline: function() {
                            return undefined;
                        },
                        setRippleCenter: function() {
                            return undefined;
                        },
                        notifyChange: function() {
                            return undefined;
                        },
                        setSelectedText: function() {
                            return undefined;
                        },
                        isSelectAnchorFocused: function() {
                            return false;
                        },
                        getSelectAnchorAttr: function() {
                            return "";
                        },
                        setSelectAnchorAttr: function() {
                            return undefined;
                        },
                        removeSelectAnchorAttr: function() {
                            return undefined;
                        },
                        addMenuClass: function() {
                            return undefined;
                        },
                        removeMenuClass: function() {
                            return undefined;
                        },
                        openMenu: function() {
                            return undefined;
                        },
                        closeMenu: function() {
                            return undefined;
                        },
                        getAnchorElement: function() {
                            return null;
                        },
                        setMenuAnchorElement: function() {
                            return undefined;
                        },
                        setMenuAnchorCorner: function() {
                            return undefined;
                        },
                        setMenuWrapFocus: function() {
                            return undefined;
                        },
                        focusMenuItemAtIndex: function() {
                            return undefined;
                        },
                        getMenuItemCount: function() {
                            return 0;
                        },
                        getMenuItemValues: function() {
                            return [];
                        },
                        getMenuItemTextAtIndex: function() {
                            return "";
                        },
                        isTypeaheadInProgress: function() {
                            return false;
                        },
                        typeaheadMatchItem: function() {
                            return -1;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCSelectFoundation.prototype.getSelectedIndex = function() {
                return this.adapter.getSelectedIndex();
            };
            MDCSelectFoundation.prototype.setSelectedIndex = function(index, closeMenu, skipNotify) {
                if (closeMenu === void 0) {
                    closeMenu = false;
                }
                if (skipNotify === void 0) {
                    skipNotify = false;
                }
                if (index >= this.adapter.getMenuItemCount()) {
                    return;
                }
                if (index === select_constants_numbers.UNSET_INDEX) {
                    this.adapter.setSelectedText("");
                } else {
                    this.adapter.setSelectedText(this.adapter.getMenuItemTextAtIndex(index).trim());
                }
                this.adapter.setSelectedIndex(index);
                if (closeMenu) {
                    this.adapter.closeMenu();
                }
                if (!skipNotify && this.lastSelectedIndex !== index) {
                    this.handleChange();
                }
                this.lastSelectedIndex = index;
            };
            MDCSelectFoundation.prototype.setValue = function(value, skipNotify) {
                if (skipNotify === void 0) {
                    skipNotify = false;
                }
                var index = this.adapter.getMenuItemValues().indexOf(value);
                this.setSelectedIndex(index, false, skipNotify);
            };
            MDCSelectFoundation.prototype.getValue = function() {
                var index = this.adapter.getSelectedIndex();
                var menuItemValues = this.adapter.getMenuItemValues();
                return index !== select_constants_numbers.UNSET_INDEX ? menuItemValues[index] : "";
            };
            MDCSelectFoundation.prototype.getDisabled = function() {
                return this.disabled;
            };
            MDCSelectFoundation.prototype.setDisabled = function(isDisabled) {
                this.disabled = isDisabled;
                if (this.disabled) {
                    this.adapter.addClass(select_constants_cssClasses.DISABLED);
                    this.adapter.closeMenu();
                } else {
                    this.adapter.removeClass(select_constants_cssClasses.DISABLED);
                }
                if (this.leadingIcon) {
                    this.leadingIcon.setDisabled(this.disabled);
                }
                if (this.disabled) {
                    this.adapter.removeSelectAnchorAttr("tabindex");
                } else {
                    this.adapter.setSelectAnchorAttr("tabindex", "0");
                }
                this.adapter.setSelectAnchorAttr("aria-disabled", this.disabled.toString());
            };
            MDCSelectFoundation.prototype.openMenu = function() {
                this.adapter.addClass(select_constants_cssClasses.ACTIVATED);
                this.adapter.openMenu();
                this.isMenuOpen = true;
                this.adapter.setSelectAnchorAttr("aria-expanded", "true");
            };
            MDCSelectFoundation.prototype.setHelperTextContent = function(content) {
                if (this.helperText) {
                    this.helperText.setContent(content);
                }
            };
            MDCSelectFoundation.prototype.layout = function() {
                if (this.adapter.hasLabel()) {
                    var optionHasValue = this.getValue().length > 0;
                    var isFocused = this.adapter.hasClass(select_constants_cssClasses.FOCUSED);
                    var shouldFloatAndNotch = optionHasValue || isFocused;
                    var isRequired = this.adapter.hasClass(select_constants_cssClasses.REQUIRED);
                    this.notchOutline(shouldFloatAndNotch);
                    this.adapter.floatLabel(shouldFloatAndNotch);
                    this.adapter.setLabelRequired(isRequired);
                }
            };
            MDCSelectFoundation.prototype.layoutOptions = function() {
                var menuItemValues = this.adapter.getMenuItemValues();
                var selectedIndex = menuItemValues.indexOf(this.getValue());
                this.setSelectedIndex(selectedIndex, false, true);
            };
            MDCSelectFoundation.prototype.handleMenuOpened = function() {
                if (this.adapter.getMenuItemValues().length === 0) {
                    return;
                }
                var selectedIndex = this.getSelectedIndex();
                var focusItemIndex = selectedIndex >= 0 ? selectedIndex : 0;
                this.adapter.focusMenuItemAtIndex(focusItemIndex);
            };
            MDCSelectFoundation.prototype.handleMenuClosed = function() {
                this.adapter.removeClass(select_constants_cssClasses.ACTIVATED);
                this.isMenuOpen = false;
                this.adapter.setSelectAnchorAttr("aria-expanded", "false");
                if (!this.adapter.isSelectAnchorFocused()) {
                    this.blur();
                }
            };
            MDCSelectFoundation.prototype.handleChange = function() {
                this.layout();
                this.adapter.notifyChange(this.getValue());
                var isRequired = this.adapter.hasClass(select_constants_cssClasses.REQUIRED);
                if (isRequired && this.useDefaultValidation) {
                    this.setValid(this.isValid());
                }
            };
            MDCSelectFoundation.prototype.handleMenuItemAction = function(index) {
                this.setSelectedIndex(index, true);
            };
            MDCSelectFoundation.prototype.handleFocus = function() {
                this.adapter.addClass(select_constants_cssClasses.FOCUSED);
                this.layout();
                this.adapter.activateBottomLine();
            };
            MDCSelectFoundation.prototype.handleBlur = function() {
                if (this.isMenuOpen) {
                    return;
                }
                this.blur();
            };
            MDCSelectFoundation.prototype.handleClick = function(normalizedX) {
                if (this.disabled || this.recentlyClicked) {
                    return;
                }
                this.setClickDebounceTimeout();
                if (this.isMenuOpen) {
                    this.adapter.closeMenu();
                    return;
                }
                this.adapter.setRippleCenter(normalizedX);
                this.openMenu();
            };
            MDCSelectFoundation.prototype.handleKeydown = function(event) {
                if (this.isMenuOpen || !this.adapter.hasClass(select_constants_cssClasses.FOCUSED)) {
                    return;
                }
                var isEnter = normalizeKey(event) === KEY.ENTER;
                var isSpace = normalizeKey(event) === KEY.SPACEBAR;
                var arrowUp = normalizeKey(event) === KEY.ARROW_UP;
                var arrowDown = normalizeKey(event) === KEY.ARROW_DOWN;
                if (!isSpace && event.key && event.key.length === 1 || isSpace && this.adapter.isTypeaheadInProgress()) {
                    var key = isSpace ? " " : event.key;
                    var typeaheadNextIndex = this.adapter.typeaheadMatchItem(key, this.getSelectedIndex());
                    if (typeaheadNextIndex >= 0) {
                        this.setSelectedIndex(typeaheadNextIndex);
                    }
                    event.preventDefault();
                    return;
                }
                if (!isEnter && !isSpace && !arrowUp && !arrowDown) {
                    return;
                }
                if (arrowUp && this.getSelectedIndex() > 0) {
                    this.setSelectedIndex(this.getSelectedIndex() - 1);
                } else if (arrowDown && this.getSelectedIndex() < this.adapter.getMenuItemCount() - 1) {
                    this.setSelectedIndex(this.getSelectedIndex() + 1);
                }
                this.openMenu();
                event.preventDefault();
            };
            MDCSelectFoundation.prototype.notchOutline = function(openNotch) {
                if (!this.adapter.hasOutline()) {
                    return;
                }
                var isFocused = this.adapter.hasClass(select_constants_cssClasses.FOCUSED);
                if (openNotch) {
                    var labelScale = select_constants_numbers.LABEL_SCALE;
                    var labelWidth = this.adapter.getLabelWidth() * labelScale;
                    this.adapter.notchOutline(labelWidth);
                } else if (!isFocused) {
                    this.adapter.closeOutline();
                }
            };
            MDCSelectFoundation.prototype.setLeadingIconAriaLabel = function(label) {
                if (this.leadingIcon) {
                    this.leadingIcon.setAriaLabel(label);
                }
            };
            MDCSelectFoundation.prototype.setLeadingIconContent = function(content) {
                if (this.leadingIcon) {
                    this.leadingIcon.setContent(content);
                }
            };
            MDCSelectFoundation.prototype.setUseDefaultValidation = function(useDefaultValidation) {
                this.useDefaultValidation = useDefaultValidation;
            };
            MDCSelectFoundation.prototype.setValid = function(isValid) {
                if (!this.useDefaultValidation) {
                    this.customValidity = isValid;
                }
                this.adapter.setSelectAnchorAttr("aria-invalid", (!isValid).toString());
                if (isValid) {
                    this.adapter.removeClass(select_constants_cssClasses.INVALID);
                    this.adapter.removeMenuClass(select_constants_cssClasses.MENU_INVALID);
                } else {
                    this.adapter.addClass(select_constants_cssClasses.INVALID);
                    this.adapter.addMenuClass(select_constants_cssClasses.MENU_INVALID);
                }
                this.syncHelperTextValidity(isValid);
            };
            MDCSelectFoundation.prototype.isValid = function() {
                if (this.useDefaultValidation && this.adapter.hasClass(select_constants_cssClasses.REQUIRED) && !this.adapter.hasClass(select_constants_cssClasses.DISABLED)) {
                    return this.getSelectedIndex() !== select_constants_numbers.UNSET_INDEX && (this.getSelectedIndex() !== 0 || Boolean(this.getValue()));
                }
                return this.customValidity;
            };
            MDCSelectFoundation.prototype.setRequired = function(isRequired) {
                if (isRequired) {
                    this.adapter.addClass(select_constants_cssClasses.REQUIRED);
                } else {
                    this.adapter.removeClass(select_constants_cssClasses.REQUIRED);
                }
                this.adapter.setSelectAnchorAttr("aria-required", isRequired.toString());
                this.adapter.setLabelRequired(isRequired);
            };
            MDCSelectFoundation.prototype.getRequired = function() {
                return this.adapter.getSelectAnchorAttr("aria-required") === "true";
            };
            MDCSelectFoundation.prototype.init = function() {
                var anchorEl = this.adapter.getAnchorElement();
                if (anchorEl) {
                    this.adapter.setMenuAnchorElement(anchorEl);
                    this.adapter.setMenuAnchorCorner(Corner.BOTTOM_START);
                }
                this.adapter.setMenuWrapFocus(false);
                this.setDisabled(this.adapter.hasClass(select_constants_cssClasses.DISABLED));
                this.syncHelperTextValidity(!this.adapter.hasClass(select_constants_cssClasses.INVALID));
                this.layout();
                this.layoutOptions();
            };
            MDCSelectFoundation.prototype.blur = function() {
                this.adapter.removeClass(select_constants_cssClasses.FOCUSED);
                this.layout();
                this.adapter.deactivateBottomLine();
                var isRequired = this.adapter.hasClass(select_constants_cssClasses.REQUIRED);
                if (isRequired && this.useDefaultValidation) {
                    this.setValid(this.isValid());
                }
            };
            MDCSelectFoundation.prototype.syncHelperTextValidity = function(isValid) {
                if (!this.helperText) {
                    return;
                }
                this.helperText.setValidity(isValid);
                var helperTextVisible = this.helperText.isVisible();
                var helperTextId = this.helperText.getId();
                if (helperTextVisible && helperTextId) {
                    this.adapter.setSelectAnchorAttr(select_constants_strings.ARIA_DESCRIBEDBY, helperTextId);
                } else {
                    this.adapter.removeSelectAnchorAttr(select_constants_strings.ARIA_DESCRIBEDBY);
                }
            };
            MDCSelectFoundation.prototype.setClickDebounceTimeout = function() {
                var _this = this;
                clearTimeout(this.clickDebounceTimeout);
                this.clickDebounceTimeout = setTimeout((function() {
                    _this.recentlyClicked = false;
                }), select_constants_numbers.CLICK_DEBOUNCE_TIMEOUT_MS);
                this.recentlyClicked = true;
            };
            return MDCSelectFoundation;
        }(MDCFoundation);
        const select_foundation = null && MDCSelectFoundation;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var select_helper_text_constants_strings = {
            ARIA_HIDDEN: "aria-hidden",
            ROLE: "role"
        };
        var select_helper_text_constants_cssClasses = {
            HELPER_TEXT_VALIDATION_MSG: "mdc-select-helper-text--validation-msg",
            HELPER_TEXT_VALIDATION_MSG_PERSISTENT: "mdc-select-helper-text--validation-msg-persistent"
        };
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCSelectHelperTextFoundation = function(_super) {
            __extends(MDCSelectHelperTextFoundation, _super);
            function MDCSelectHelperTextFoundation(adapter) {
                return _super.call(this, __assign(__assign({}, MDCSelectHelperTextFoundation.defaultAdapter), adapter)) || this;
            }
            Object.defineProperty(MDCSelectHelperTextFoundation, "cssClasses", {
                get: function() {
                    return select_helper_text_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSelectHelperTextFoundation, "strings", {
                get: function() {
                    return select_helper_text_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSelectHelperTextFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClass: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        hasClass: function() {
                            return false;
                        },
                        setAttr: function() {
                            return undefined;
                        },
                        getAttr: function() {
                            return null;
                        },
                        removeAttr: function() {
                            return undefined;
                        },
                        setContent: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCSelectHelperTextFoundation.prototype.getId = function() {
                return this.adapter.getAttr("id");
            };
            MDCSelectHelperTextFoundation.prototype.isVisible = function() {
                return this.adapter.getAttr(select_helper_text_constants_strings.ARIA_HIDDEN) !== "true";
            };
            MDCSelectHelperTextFoundation.prototype.setContent = function(content) {
                this.adapter.setContent(content);
            };
            MDCSelectHelperTextFoundation.prototype.setValidation = function(isValidation) {
                if (isValidation) {
                    this.adapter.addClass(select_helper_text_constants_cssClasses.HELPER_TEXT_VALIDATION_MSG);
                } else {
                    this.adapter.removeClass(select_helper_text_constants_cssClasses.HELPER_TEXT_VALIDATION_MSG);
                }
            };
            MDCSelectHelperTextFoundation.prototype.setValidationMsgPersistent = function(isPersistent) {
                if (isPersistent) {
                    this.adapter.addClass(select_helper_text_constants_cssClasses.HELPER_TEXT_VALIDATION_MSG_PERSISTENT);
                } else {
                    this.adapter.removeClass(select_helper_text_constants_cssClasses.HELPER_TEXT_VALIDATION_MSG_PERSISTENT);
                }
            };
            MDCSelectHelperTextFoundation.prototype.setValidity = function(selectIsValid) {
                var isValidationMsg = this.adapter.hasClass(select_helper_text_constants_cssClasses.HELPER_TEXT_VALIDATION_MSG);
                if (!isValidationMsg) {
                    return;
                }
                var isPersistentValidationMsg = this.adapter.hasClass(select_helper_text_constants_cssClasses.HELPER_TEXT_VALIDATION_MSG_PERSISTENT);
                var msgShouldDisplay = !selectIsValid || isPersistentValidationMsg;
                if (msgShouldDisplay) {
                    this.showToScreenReader();
                    if (!selectIsValid) {
                        this.adapter.setAttr(select_helper_text_constants_strings.ROLE, "alert");
                    } else {
                        this.adapter.removeAttr(select_helper_text_constants_strings.ROLE);
                    }
                    return;
                }
                this.adapter.removeAttr(select_helper_text_constants_strings.ROLE);
                this.hide();
            };
            MDCSelectHelperTextFoundation.prototype.showToScreenReader = function() {
                this.adapter.removeAttr(select_helper_text_constants_strings.ARIA_HIDDEN);
            };
            MDCSelectHelperTextFoundation.prototype.hide = function() {
                this.adapter.setAttr(select_helper_text_constants_strings.ARIA_HIDDEN, "true");
            };
            return MDCSelectHelperTextFoundation;
        }(MDCFoundation);
        const select_helper_text_foundation = null && MDCSelectHelperTextFoundation;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCSelectHelperText = function(_super) {
            __extends(MDCSelectHelperText, _super);
            function MDCSelectHelperText() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCSelectHelperText.attachTo = function(root) {
                return new MDCSelectHelperText(root);
            };
            Object.defineProperty(MDCSelectHelperText.prototype, "foundationForSelect", {
                get: function() {
                    return this.foundation;
                },
                enumerable: true,
                configurable: true
            });
            MDCSelectHelperText.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    addClass: function(className) {
                        return _this.root.classList.add(className);
                    },
                    removeClass: function(className) {
                        return _this.root.classList.remove(className);
                    },
                    hasClass: function(className) {
                        return _this.root.classList.contains(className);
                    },
                    getAttr: function(attr) {
                        return _this.root.getAttribute(attr);
                    },
                    setAttr: function(attr, value) {
                        return _this.root.setAttribute(attr, value);
                    },
                    removeAttr: function(attr) {
                        return _this.root.removeAttribute(attr);
                    },
                    setContent: function(content) {
                        _this.root.textContent = content;
                    }
                };
                return new MDCSelectHelperTextFoundation(adapter);
            };
            return MDCSelectHelperText;
        }(MDCComponent);
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var select_icon_constants_strings = {
            ICON_EVENT: "MDCSelect:icon",
            ICON_ROLE: "button"
        };
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var icon_foundation_INTERACTION_EVENTS = [ "click", "keydown" ];
        var MDCSelectIconFoundation = function(_super) {
            __extends(MDCSelectIconFoundation, _super);
            function MDCSelectIconFoundation(adapter) {
                var _this = _super.call(this, __assign(__assign({}, MDCSelectIconFoundation.defaultAdapter), adapter)) || this;
                _this.savedTabIndex_ = null;
                _this.interactionHandler_ = function(evt) {
                    return _this.handleInteraction(evt);
                };
                return _this;
            }
            Object.defineProperty(MDCSelectIconFoundation, "strings", {
                get: function() {
                    return select_icon_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSelectIconFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        getAttr: function() {
                            return null;
                        },
                        setAttr: function() {
                            return undefined;
                        },
                        removeAttr: function() {
                            return undefined;
                        },
                        setContent: function() {
                            return undefined;
                        },
                        registerInteractionHandler: function() {
                            return undefined;
                        },
                        deregisterInteractionHandler: function() {
                            return undefined;
                        },
                        notifyIconAction: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCSelectIconFoundation.prototype.init = function() {
                var _this = this;
                this.savedTabIndex_ = this.adapter.getAttr("tabindex");
                icon_foundation_INTERACTION_EVENTS.forEach((function(evtType) {
                    _this.adapter.registerInteractionHandler(evtType, _this.interactionHandler_);
                }));
            };
            MDCSelectIconFoundation.prototype.destroy = function() {
                var _this = this;
                icon_foundation_INTERACTION_EVENTS.forEach((function(evtType) {
                    _this.adapter.deregisterInteractionHandler(evtType, _this.interactionHandler_);
                }));
            };
            MDCSelectIconFoundation.prototype.setDisabled = function(disabled) {
                if (!this.savedTabIndex_) {
                    return;
                }
                if (disabled) {
                    this.adapter.setAttr("tabindex", "-1");
                    this.adapter.removeAttr("role");
                } else {
                    this.adapter.setAttr("tabindex", this.savedTabIndex_);
                    this.adapter.setAttr("role", select_icon_constants_strings.ICON_ROLE);
                }
            };
            MDCSelectIconFoundation.prototype.setAriaLabel = function(label) {
                this.adapter.setAttr("aria-label", label);
            };
            MDCSelectIconFoundation.prototype.setContent = function(content) {
                this.adapter.setContent(content);
            };
            MDCSelectIconFoundation.prototype.handleInteraction = function(evt) {
                var isEnterKey = evt.key === "Enter" || evt.keyCode === 13;
                if (evt.type === "click" || isEnterKey) {
                    this.adapter.notifyIconAction();
                }
            };
            return MDCSelectIconFoundation;
        }(MDCFoundation);
        const select_icon_foundation = null && MDCSelectIconFoundation;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCSelectIcon = function(_super) {
            __extends(MDCSelectIcon, _super);
            function MDCSelectIcon() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCSelectIcon.attachTo = function(root) {
                return new MDCSelectIcon(root);
            };
            Object.defineProperty(MDCSelectIcon.prototype, "foundationForSelect", {
                get: function() {
                    return this.foundation;
                },
                enumerable: true,
                configurable: true
            });
            MDCSelectIcon.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    getAttr: function(attr) {
                        return _this.root.getAttribute(attr);
                    },
                    setAttr: function(attr, value) {
                        return _this.root.setAttribute(attr, value);
                    },
                    removeAttr: function(attr) {
                        return _this.root.removeAttribute(attr);
                    },
                    setContent: function(content) {
                        _this.root.textContent = content;
                    },
                    registerInteractionHandler: function(evtType, handler) {
                        return _this.listen(evtType, handler);
                    },
                    deregisterInteractionHandler: function(evtType, handler) {
                        return _this.unlisten(evtType, handler);
                    },
                    notifyIconAction: function() {
                        return _this.emit(MDCSelectIconFoundation.strings.ICON_EVENT, {}, true);
                    }
                };
                return new MDCSelectIconFoundation(adapter);
            };
            return MDCSelectIcon;
        }(MDCComponent);
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCSelect = function(_super) {
            __extends(MDCSelect, _super);
            function MDCSelect() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCSelect.attachTo = function(root) {
                return new MDCSelect(root);
            };
            MDCSelect.prototype.initialize = function(labelFactory, lineRippleFactory, outlineFactory, menuFactory, iconFactory, helperTextFactory) {
                if (labelFactory === void 0) {
                    labelFactory = function(el) {
                        return new MDCFloatingLabel(el);
                    };
                }
                if (lineRippleFactory === void 0) {
                    lineRippleFactory = function(el) {
                        return new MDCLineRipple(el);
                    };
                }
                if (outlineFactory === void 0) {
                    outlineFactory = function(el) {
                        return new MDCNotchedOutline(el);
                    };
                }
                if (menuFactory === void 0) {
                    menuFactory = function(el) {
                        return new MDCMenu(el);
                    };
                }
                if (iconFactory === void 0) {
                    iconFactory = function(el) {
                        return new MDCSelectIcon(el);
                    };
                }
                if (helperTextFactory === void 0) {
                    helperTextFactory = function(el) {
                        return new MDCSelectHelperText(el);
                    };
                }
                this.selectAnchor = this.root.querySelector(select_constants_strings.SELECT_ANCHOR_SELECTOR);
                this.selectedText = this.root.querySelector(select_constants_strings.SELECTED_TEXT_SELECTOR);
                this.hiddenInput = this.root.querySelector(select_constants_strings.HIDDEN_INPUT_SELECTOR);
                if (!this.selectedText) {
                    throw new Error("MDCSelect: Missing required element: The following selector must be present: " + ("'" + select_constants_strings.SELECTED_TEXT_SELECTOR + "'"));
                }
                if (this.selectAnchor.hasAttribute(select_constants_strings.ARIA_CONTROLS)) {
                    var helperTextElement = document.getElementById(this.selectAnchor.getAttribute(select_constants_strings.ARIA_CONTROLS));
                    if (helperTextElement) {
                        this.helperText = helperTextFactory(helperTextElement);
                    }
                }
                this.menuSetup(menuFactory);
                var labelElement = this.root.querySelector(select_constants_strings.LABEL_SELECTOR);
                this.label = labelElement ? labelFactory(labelElement) : null;
                var lineRippleElement = this.root.querySelector(select_constants_strings.LINE_RIPPLE_SELECTOR);
                this.lineRipple = lineRippleElement ? lineRippleFactory(lineRippleElement) : null;
                var outlineElement = this.root.querySelector(select_constants_strings.OUTLINE_SELECTOR);
                this.outline = outlineElement ? outlineFactory(outlineElement) : null;
                var leadingIcon = this.root.querySelector(select_constants_strings.LEADING_ICON_SELECTOR);
                if (leadingIcon) {
                    this.leadingIcon = iconFactory(leadingIcon);
                }
                if (!this.root.classList.contains(select_constants_cssClasses.OUTLINED)) {
                    this.ripple = this.createRipple();
                }
            };
            MDCSelect.prototype.initialSyncWithDOM = function() {
                var _this = this;
                this.handleFocus = function() {
                    _this.foundation.handleFocus();
                };
                this.handleBlur = function() {
                    _this.foundation.handleBlur();
                };
                this.handleClick = function(evt) {
                    _this.selectAnchor.focus();
                    _this.foundation.handleClick(_this.getNormalizedXCoordinate(evt));
                };
                this.handleKeydown = function(evt) {
                    _this.foundation.handleKeydown(evt);
                };
                this.handleMenuItemAction = function(evt) {
                    _this.foundation.handleMenuItemAction(evt.detail.index);
                };
                this.handleMenuOpened = function() {
                    _this.foundation.handleMenuOpened();
                };
                this.handleMenuClosed = function() {
                    _this.foundation.handleMenuClosed();
                };
                this.selectAnchor.addEventListener("focus", this.handleFocus);
                this.selectAnchor.addEventListener("blur", this.handleBlur);
                this.selectAnchor.addEventListener("click", this.handleClick);
                this.selectAnchor.addEventListener("keydown", this.handleKeydown);
                this.menu.listen(menu_surface_constants_strings.CLOSED_EVENT, this.handleMenuClosed);
                this.menu.listen(menu_surface_constants_strings.OPENED_EVENT, this.handleMenuOpened);
                this.menu.listen(menu_constants_strings.SELECTED_EVENT, this.handleMenuItemAction);
                if (this.hiddenInput) {
                    if (this.hiddenInput.value) {
                        this.foundation.setValue(this.hiddenInput.value, true);
                        this.foundation.layout();
                        return;
                    }
                    this.hiddenInput.value = this.value;
                }
            };
            MDCSelect.prototype.destroy = function() {
                this.selectAnchor.removeEventListener("focus", this.handleFocus);
                this.selectAnchor.removeEventListener("blur", this.handleBlur);
                this.selectAnchor.removeEventListener("keydown", this.handleKeydown);
                this.selectAnchor.removeEventListener("click", this.handleClick);
                this.menu.unlisten(menu_surface_constants_strings.CLOSED_EVENT, this.handleMenuClosed);
                this.menu.unlisten(menu_surface_constants_strings.OPENED_EVENT, this.handleMenuOpened);
                this.menu.unlisten(menu_constants_strings.SELECTED_EVENT, this.handleMenuItemAction);
                this.menu.destroy();
                if (this.ripple) {
                    this.ripple.destroy();
                }
                if (this.outline) {
                    this.outline.destroy();
                }
                if (this.leadingIcon) {
                    this.leadingIcon.destroy();
                }
                if (this.helperText) {
                    this.helperText.destroy();
                }
                _super.prototype.destroy.call(this);
            };
            Object.defineProperty(MDCSelect.prototype, "value", {
                get: function() {
                    return this.foundation.getValue();
                },
                set: function(value) {
                    this.foundation.setValue(value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSelect.prototype, "selectedIndex", {
                get: function() {
                    return this.foundation.getSelectedIndex();
                },
                set: function(selectedIndex) {
                    this.foundation.setSelectedIndex(selectedIndex, true);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSelect.prototype, "disabled", {
                get: function() {
                    return this.foundation.getDisabled();
                },
                set: function(disabled) {
                    this.foundation.setDisabled(disabled);
                    if (this.hiddenInput) {
                        this.hiddenInput.disabled = disabled;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSelect.prototype, "leadingIconAriaLabel", {
                set: function(label) {
                    this.foundation.setLeadingIconAriaLabel(label);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSelect.prototype, "leadingIconContent", {
                set: function(content) {
                    this.foundation.setLeadingIconContent(content);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSelect.prototype, "helperTextContent", {
                set: function(content) {
                    this.foundation.setHelperTextContent(content);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSelect.prototype, "useDefaultValidation", {
                set: function(useDefaultValidation) {
                    this.foundation.setUseDefaultValidation(useDefaultValidation);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSelect.prototype, "valid", {
                get: function() {
                    return this.foundation.isValid();
                },
                set: function(isValid) {
                    this.foundation.setValid(isValid);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSelect.prototype, "required", {
                get: function() {
                    return this.foundation.getRequired();
                },
                set: function(isRequired) {
                    this.foundation.setRequired(isRequired);
                },
                enumerable: true,
                configurable: true
            });
            MDCSelect.prototype.layout = function() {
                this.foundation.layout();
            };
            MDCSelect.prototype.layoutOptions = function() {
                this.foundation.layoutOptions();
                this.menu.layout();
                this.menuItemValues = this.menu.items.map((function(el) {
                    return el.getAttribute(select_constants_strings.VALUE_ATTR) || "";
                }));
                if (this.hiddenInput) {
                    this.hiddenInput.value = this.value;
                }
            };
            MDCSelect.prototype.getDefaultFoundation = function() {
                var adapter = __assign(__assign(__assign(__assign({}, this.getSelectAdapterMethods()), this.getCommonAdapterMethods()), this.getOutlineAdapterMethods()), this.getLabelAdapterMethods());
                return new MDCSelectFoundation(adapter, this.getFoundationMap());
            };
            MDCSelect.prototype.menuSetup = function(menuFactory) {
                this.menuElement = this.root.querySelector(select_constants_strings.MENU_SELECTOR);
                this.menu = menuFactory(this.menuElement);
                this.menu.hasTypeahead = true;
                this.menu.singleSelection = true;
                this.menuItemValues = this.menu.items.map((function(el) {
                    return el.getAttribute(select_constants_strings.VALUE_ATTR) || "";
                }));
            };
            MDCSelect.prototype.createRipple = function() {
                var _this = this;
                var adapter = __assign(__assign({}, MDCRipple.createAdapter({
                    root: this.selectAnchor
                })), {
                    registerInteractionHandler: function(evtType, handler) {
                        _this.selectAnchor.addEventListener(evtType, handler);
                    },
                    deregisterInteractionHandler: function(evtType, handler) {
                        _this.selectAnchor.removeEventListener(evtType, handler);
                    }
                });
                return new MDCRipple(this.selectAnchor, new MDCRippleFoundation(adapter));
            };
            MDCSelect.prototype.getSelectAdapterMethods = function() {
                var _this = this;
                return {
                    getMenuItemAttr: function(menuItem, attr) {
                        return menuItem.getAttribute(attr);
                    },
                    setSelectedText: function(text) {
                        _this.selectedText.textContent = text;
                    },
                    isSelectAnchorFocused: function() {
                        return document.activeElement === _this.selectAnchor;
                    },
                    getSelectAnchorAttr: function(attr) {
                        return _this.selectAnchor.getAttribute(attr);
                    },
                    setSelectAnchorAttr: function(attr, value) {
                        _this.selectAnchor.setAttribute(attr, value);
                    },
                    removeSelectAnchorAttr: function(attr) {
                        _this.selectAnchor.removeAttribute(attr);
                    },
                    addMenuClass: function(className) {
                        _this.menuElement.classList.add(className);
                    },
                    removeMenuClass: function(className) {
                        _this.menuElement.classList.remove(className);
                    },
                    openMenu: function() {
                        _this.menu.open = true;
                    },
                    closeMenu: function() {
                        _this.menu.open = false;
                    },
                    getAnchorElement: function() {
                        return _this.root.querySelector(select_constants_strings.SELECT_ANCHOR_SELECTOR);
                    },
                    setMenuAnchorElement: function(anchorEl) {
                        _this.menu.setAnchorElement(anchorEl);
                    },
                    setMenuAnchorCorner: function(anchorCorner) {
                        _this.menu.setAnchorCorner(anchorCorner);
                    },
                    setMenuWrapFocus: function(wrapFocus) {
                        _this.menu.wrapFocus = wrapFocus;
                    },
                    getSelectedIndex: function() {
                        var index = _this.menu.selectedIndex;
                        return index instanceof Array ? index[0] : index;
                    },
                    setSelectedIndex: function(index) {
                        _this.menu.selectedIndex = index;
                    },
                    focusMenuItemAtIndex: function(index) {
                        _this.menu.items[index].focus();
                    },
                    getMenuItemCount: function() {
                        return _this.menu.items.length;
                    },
                    getMenuItemValues: function() {
                        return _this.menuItemValues;
                    },
                    getMenuItemTextAtIndex: function(index) {
                        return _this.menu.getPrimaryTextAtIndex(index);
                    },
                    isTypeaheadInProgress: function() {
                        return _this.menu.typeaheadInProgress;
                    },
                    typeaheadMatchItem: function(nextChar, startingIndex) {
                        return _this.menu.typeaheadMatchItem(nextChar, startingIndex);
                    }
                };
            };
            MDCSelect.prototype.getCommonAdapterMethods = function() {
                var _this = this;
                return {
                    addClass: function(className) {
                        _this.root.classList.add(className);
                    },
                    removeClass: function(className) {
                        _this.root.classList.remove(className);
                    },
                    hasClass: function(className) {
                        return _this.root.classList.contains(className);
                    },
                    setRippleCenter: function(normalizedX) {
                        _this.lineRipple && _this.lineRipple.setRippleCenter(normalizedX);
                    },
                    activateBottomLine: function() {
                        _this.lineRipple && _this.lineRipple.activate();
                    },
                    deactivateBottomLine: function() {
                        _this.lineRipple && _this.lineRipple.deactivate();
                    },
                    notifyChange: function(value) {
                        var index = _this.selectedIndex;
                        _this.emit(select_constants_strings.CHANGE_EVENT, {
                            value: value,
                            index: index
                        }, true);
                        if (_this.hiddenInput) {
                            _this.hiddenInput.value = value;
                        }
                    }
                };
            };
            MDCSelect.prototype.getOutlineAdapterMethods = function() {
                var _this = this;
                return {
                    hasOutline: function() {
                        return Boolean(_this.outline);
                    },
                    notchOutline: function(labelWidth) {
                        _this.outline && _this.outline.notch(labelWidth);
                    },
                    closeOutline: function() {
                        _this.outline && _this.outline.closeNotch();
                    }
                };
            };
            MDCSelect.prototype.getLabelAdapterMethods = function() {
                var _this = this;
                return {
                    hasLabel: function() {
                        return !!_this.label;
                    },
                    floatLabel: function(shouldFloat) {
                        _this.label && _this.label.float(shouldFloat);
                    },
                    getLabelWidth: function() {
                        return _this.label ? _this.label.getWidth() : 0;
                    },
                    setLabelRequired: function(isRequired) {
                        _this.label && _this.label.setRequired(isRequired);
                    }
                };
            };
            MDCSelect.prototype.getNormalizedXCoordinate = function(evt) {
                var targetClientRect = evt.target.getBoundingClientRect();
                var xCoordinate = this.isTouchEvent(evt) ? evt.touches[0].clientX : evt.clientX;
                return xCoordinate - targetClientRect.left;
            };
            MDCSelect.prototype.isTouchEvent = function(evt) {
                return Boolean(evt.touches);
            };
            MDCSelect.prototype.getFoundationMap = function() {
                return {
                    helperText: this.helperText ? this.helperText.foundationForSelect : undefined,
                    leadingIcon: this.leadingIcon ? this.leadingIcon.foundationForSelect : undefined
                };
            };
            return MDCSelect;
        }(MDCComponent);
        function MBDatePicker_init(elem) {
            elem._select = MDCSelect.attachTo(elem);
        }
        function MBDatePicker_setDisabled(elem, value) {
            elem._select.disabled = value;
        }
        function listItemClick(elem, elemText) {
            elem.innerText = elemText;
            elem.click();
        }
        function scrollToYear(id) {
            var element = document.getElementById(id);
            element === null || element === void 0 ? void 0 : element.scrollIntoView({
                behavior: "auto",
                block: "nearest",
                inline: "nearest"
            });
        }
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var FOCUS_SENTINEL_CLASS = "mdc-dom-focus-sentinel";
        var FocusTrap = function() {
            function FocusTrap(root, options) {
                if (options === void 0) {
                    options = {};
                }
                this.root = root;
                this.options = options;
                this.elFocusedBeforeTrapFocus = null;
            }
            FocusTrap.prototype.trapFocus = function() {
                var focusableEls = this.getFocusableElements(this.root);
                if (focusableEls.length === 0) {
                    throw new Error("FocusTrap: Element must have at least one focusable child.");
                }
                this.elFocusedBeforeTrapFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;
                this.wrapTabFocus(this.root, focusableEls);
                if (!this.options.skipInitialFocus) {
                    this.focusInitialElement(focusableEls, this.options.initialFocusEl);
                }
            };
            FocusTrap.prototype.releaseFocus = function() {
                [].slice.call(this.root.querySelectorAll("." + FOCUS_SENTINEL_CLASS)).forEach((function(sentinelEl) {
                    sentinelEl.parentElement.removeChild(sentinelEl);
                }));
                if (this.elFocusedBeforeTrapFocus) {
                    this.elFocusedBeforeTrapFocus.focus();
                }
            };
            FocusTrap.prototype.wrapTabFocus = function(el, focusableEls) {
                var sentinelStart = this.createSentinel();
                var sentinelEnd = this.createSentinel();
                sentinelStart.addEventListener("focus", (function() {
                    if (focusableEls.length > 0) {
                        focusableEls[focusableEls.length - 1].focus();
                    }
                }));
                sentinelEnd.addEventListener("focus", (function() {
                    if (focusableEls.length > 0) {
                        focusableEls[0].focus();
                    }
                }));
                el.insertBefore(sentinelStart, el.children[0]);
                el.appendChild(sentinelEnd);
            };
            FocusTrap.prototype.focusInitialElement = function(focusableEls, initialFocusEl) {
                var focusIndex = 0;
                if (initialFocusEl) {
                    focusIndex = Math.max(focusableEls.indexOf(initialFocusEl), 0);
                }
                focusableEls[focusIndex].focus();
            };
            FocusTrap.prototype.getFocusableElements = function(root) {
                var focusableEls = [].slice.call(root.querySelectorAll("[autofocus], [tabindex], a, input, textarea, select, button"));
                return focusableEls.filter((function(el) {
                    var isDisabledOrHidden = el.getAttribute("aria-disabled") === "true" || el.getAttribute("disabled") != null || el.getAttribute("hidden") != null || el.getAttribute("aria-hidden") === "true";
                    var isTabbableAndVisible = el.tabIndex >= 0 && el.getBoundingClientRect().width > 0 && !el.classList.contains(FOCUS_SENTINEL_CLASS) && !isDisabledOrHidden;
                    var isProgrammaticallyHidden = false;
                    if (isTabbableAndVisible) {
                        var style = getComputedStyle(el);
                        isProgrammaticallyHidden = style.display === "none" || style.visibility === "hidden";
                    }
                    return isTabbableAndVisible && !isProgrammaticallyHidden;
                }));
            };
            FocusTrap.prototype.createSentinel = function() {
                var sentinel = document.createElement("div");
                sentinel.setAttribute("tabindex", "0");
                sentinel.setAttribute("aria-hidden", "true");
                sentinel.classList.add(FOCUS_SENTINEL_CLASS);
                return sentinel;
            };
            return FocusTrap;
        }();
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var dialog_constants_cssClasses = {
            CLOSING: "mdc-dialog--closing",
            OPEN: "mdc-dialog--open",
            OPENING: "mdc-dialog--opening",
            SCROLLABLE: "mdc-dialog--scrollable",
            SCROLL_LOCK: "mdc-dialog-scroll-lock",
            STACKED: "mdc-dialog--stacked"
        };
        var dialog_constants_strings = {
            ACTION_ATTRIBUTE: "data-mdc-dialog-action",
            BUTTON_DEFAULT_ATTRIBUTE: "data-mdc-dialog-button-default",
            BUTTON_SELECTOR: ".mdc-dialog__button",
            CLOSED_EVENT: "MDCDialog:closed",
            CLOSE_ACTION: "close",
            CLOSING_EVENT: "MDCDialog:closing",
            CONTAINER_SELECTOR: ".mdc-dialog__container",
            CONTENT_SELECTOR: ".mdc-dialog__content",
            DESTROY_ACTION: "destroy",
            INITIAL_FOCUS_ATTRIBUTE: "data-mdc-dialog-initial-focus",
            OPENED_EVENT: "MDCDialog:opened",
            OPENING_EVENT: "MDCDialog:opening",
            SCRIM_SELECTOR: ".mdc-dialog__scrim",
            SUPPRESS_DEFAULT_PRESS_SELECTOR: [ "textarea", ".mdc-menu .mdc-list-item" ].join(", "),
            SURFACE_SELECTOR: ".mdc-dialog__surface"
        };
        var dialog_constants_numbers = {
            DIALOG_ANIMATION_CLOSE_TIME_MS: 75,
            DIALOG_ANIMATION_OPEN_TIME_MS: 150
        };
        /**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCDialogFoundation = function(_super) {
            __extends(MDCDialogFoundation, _super);
            function MDCDialogFoundation(adapter) {
                var _this = _super.call(this, __assign(__assign({}, MDCDialogFoundation.defaultAdapter), adapter)) || this;
                _this.isOpen_ = false;
                _this.animationFrame_ = 0;
                _this.animationTimer_ = 0;
                _this.layoutFrame_ = 0;
                _this.escapeKeyAction_ = dialog_constants_strings.CLOSE_ACTION;
                _this.scrimClickAction_ = dialog_constants_strings.CLOSE_ACTION;
                _this.autoStackButtons_ = true;
                _this.areButtonsStacked_ = false;
                _this.suppressDefaultPressSelector = dialog_constants_strings.SUPPRESS_DEFAULT_PRESS_SELECTOR;
                return _this;
            }
            Object.defineProperty(MDCDialogFoundation, "cssClasses", {
                get: function() {
                    return dialog_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCDialogFoundation, "strings", {
                get: function() {
                    return dialog_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCDialogFoundation, "numbers", {
                get: function() {
                    return dialog_constants_numbers;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCDialogFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addBodyClass: function() {
                            return undefined;
                        },
                        addClass: function() {
                            return undefined;
                        },
                        areButtonsStacked: function() {
                            return false;
                        },
                        clickDefaultButton: function() {
                            return undefined;
                        },
                        eventTargetMatches: function() {
                            return false;
                        },
                        getActionFromEvent: function() {
                            return "";
                        },
                        getInitialFocusEl: function() {
                            return null;
                        },
                        hasClass: function() {
                            return false;
                        },
                        isContentScrollable: function() {
                            return false;
                        },
                        notifyClosed: function() {
                            return undefined;
                        },
                        notifyClosing: function() {
                            return undefined;
                        },
                        notifyOpened: function() {
                            return undefined;
                        },
                        notifyOpening: function() {
                            return undefined;
                        },
                        releaseFocus: function() {
                            return undefined;
                        },
                        removeBodyClass: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        reverseButtons: function() {
                            return undefined;
                        },
                        trapFocus: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCDialogFoundation.prototype.init = function() {
                if (this.adapter.hasClass(dialog_constants_cssClasses.STACKED)) {
                    this.setAutoStackButtons(false);
                }
            };
            MDCDialogFoundation.prototype.destroy = function() {
                if (this.isOpen_) {
                    this.close(dialog_constants_strings.DESTROY_ACTION);
                }
                if (this.animationTimer_) {
                    clearTimeout(this.animationTimer_);
                    this.handleAnimationTimerEnd_();
                }
                if (this.layoutFrame_) {
                    cancelAnimationFrame(this.layoutFrame_);
                    this.layoutFrame_ = 0;
                }
            };
            MDCDialogFoundation.prototype.open = function() {
                var _this = this;
                this.isOpen_ = true;
                this.adapter.notifyOpening();
                this.adapter.addClass(dialog_constants_cssClasses.OPENING);
                this.runNextAnimationFrame_((function() {
                    _this.adapter.addClass(dialog_constants_cssClasses.OPEN);
                    _this.adapter.addBodyClass(dialog_constants_cssClasses.SCROLL_LOCK);
                    _this.layout();
                    _this.animationTimer_ = setTimeout((function() {
                        _this.handleAnimationTimerEnd_();
                        _this.adapter.trapFocus(_this.adapter.getInitialFocusEl());
                        _this.adapter.notifyOpened();
                    }), dialog_constants_numbers.DIALOG_ANIMATION_OPEN_TIME_MS);
                }));
            };
            MDCDialogFoundation.prototype.close = function(action) {
                var _this = this;
                if (action === void 0) {
                    action = "";
                }
                if (!this.isOpen_) {
                    return;
                }
                this.isOpen_ = false;
                this.adapter.notifyClosing(action);
                this.adapter.addClass(dialog_constants_cssClasses.CLOSING);
                this.adapter.removeClass(dialog_constants_cssClasses.OPEN);
                this.adapter.removeBodyClass(dialog_constants_cssClasses.SCROLL_LOCK);
                cancelAnimationFrame(this.animationFrame_);
                this.animationFrame_ = 0;
                clearTimeout(this.animationTimer_);
                this.animationTimer_ = setTimeout((function() {
                    _this.adapter.releaseFocus();
                    _this.handleAnimationTimerEnd_();
                    _this.adapter.notifyClosed(action);
                }), dialog_constants_numbers.DIALOG_ANIMATION_CLOSE_TIME_MS);
            };
            MDCDialogFoundation.prototype.isOpen = function() {
                return this.isOpen_;
            };
            MDCDialogFoundation.prototype.getEscapeKeyAction = function() {
                return this.escapeKeyAction_;
            };
            MDCDialogFoundation.prototype.setEscapeKeyAction = function(action) {
                this.escapeKeyAction_ = action;
            };
            MDCDialogFoundation.prototype.getScrimClickAction = function() {
                return this.scrimClickAction_;
            };
            MDCDialogFoundation.prototype.setScrimClickAction = function(action) {
                this.scrimClickAction_ = action;
            };
            MDCDialogFoundation.prototype.getAutoStackButtons = function() {
                return this.autoStackButtons_;
            };
            MDCDialogFoundation.prototype.setAutoStackButtons = function(autoStack) {
                this.autoStackButtons_ = autoStack;
            };
            MDCDialogFoundation.prototype.getSuppressDefaultPressSelector = function() {
                return this.suppressDefaultPressSelector;
            };
            MDCDialogFoundation.prototype.setSuppressDefaultPressSelector = function(selector) {
                this.suppressDefaultPressSelector = selector;
            };
            MDCDialogFoundation.prototype.layout = function() {
                var _this = this;
                if (this.layoutFrame_) {
                    cancelAnimationFrame(this.layoutFrame_);
                }
                this.layoutFrame_ = requestAnimationFrame((function() {
                    _this.layoutInternal_();
                    _this.layoutFrame_ = 0;
                }));
            };
            MDCDialogFoundation.prototype.handleClick = function(evt) {
                var isScrim = this.adapter.eventTargetMatches(evt.target, dialog_constants_strings.SCRIM_SELECTOR);
                if (isScrim && this.scrimClickAction_ !== "") {
                    this.close(this.scrimClickAction_);
                } else {
                    var action = this.adapter.getActionFromEvent(evt);
                    if (action) {
                        this.close(action);
                    }
                }
            };
            MDCDialogFoundation.prototype.handleKeydown = function(evt) {
                var isEnter = evt.key === "Enter" || evt.keyCode === 13;
                if (!isEnter) {
                    return;
                }
                var action = this.adapter.getActionFromEvent(evt);
                if (action) {
                    return;
                }
                var target = evt.composedPath ? evt.composedPath()[0] : evt.target;
                var isDefault = !this.adapter.eventTargetMatches(target, this.suppressDefaultPressSelector);
                if (isEnter && isDefault) {
                    this.adapter.clickDefaultButton();
                }
            };
            MDCDialogFoundation.prototype.handleDocumentKeydown = function(evt) {
                var isEscape = evt.key === "Escape" || evt.keyCode === 27;
                if (isEscape && this.escapeKeyAction_ !== "") {
                    this.close(this.escapeKeyAction_);
                }
            };
            MDCDialogFoundation.prototype.layoutInternal_ = function() {
                if (this.autoStackButtons_) {
                    this.detectStackedButtons_();
                }
                this.detectScrollableContent_();
            };
            MDCDialogFoundation.prototype.handleAnimationTimerEnd_ = function() {
                this.animationTimer_ = 0;
                this.adapter.removeClass(dialog_constants_cssClasses.OPENING);
                this.adapter.removeClass(dialog_constants_cssClasses.CLOSING);
            };
            MDCDialogFoundation.prototype.runNextAnimationFrame_ = function(callback) {
                var _this = this;
                cancelAnimationFrame(this.animationFrame_);
                this.animationFrame_ = requestAnimationFrame((function() {
                    _this.animationFrame_ = 0;
                    clearTimeout(_this.animationTimer_);
                    _this.animationTimer_ = setTimeout(callback, 0);
                }));
            };
            MDCDialogFoundation.prototype.detectStackedButtons_ = function() {
                this.adapter.removeClass(dialog_constants_cssClasses.STACKED);
                var areButtonsStacked = this.adapter.areButtonsStacked();
                if (areButtonsStacked) {
                    this.adapter.addClass(dialog_constants_cssClasses.STACKED);
                }
                if (areButtonsStacked !== this.areButtonsStacked_) {
                    this.adapter.reverseButtons();
                    this.areButtonsStacked_ = areButtonsStacked;
                }
            };
            MDCDialogFoundation.prototype.detectScrollableContent_ = function() {
                this.adapter.removeClass(dialog_constants_cssClasses.SCROLLABLE);
                if (this.adapter.isContentScrollable()) {
                    this.adapter.addClass(dialog_constants_cssClasses.SCROLLABLE);
                }
            };
            return MDCDialogFoundation;
        }(MDCFoundation);
        const dialog_foundation = null && MDCDialogFoundation;
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        function createFocusTrapInstance(surfaceEl, focusTrapFactory, initialFocusEl) {
            return focusTrapFactory(surfaceEl, {
                initialFocusEl: initialFocusEl
            });
        }
        function isScrollable(el) {
            return el ? el.scrollHeight > el.offsetHeight : false;
        }
        function areTopsMisaligned(els) {
            var tops = new Set;
            [].forEach.call(els, (function(el) {
                return tops.add(el.offsetTop);
            }));
            return tops.size > 1;
        }
        /**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var component_strings = MDCDialogFoundation.strings;
        var MDCDialog = function(_super) {
            __extends(MDCDialog, _super);
            function MDCDialog() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Object.defineProperty(MDCDialog.prototype, "isOpen", {
                get: function() {
                    return this.foundation.isOpen();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCDialog.prototype, "escapeKeyAction", {
                get: function() {
                    return this.foundation.getEscapeKeyAction();
                },
                set: function(action) {
                    this.foundation.setEscapeKeyAction(action);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCDialog.prototype, "scrimClickAction", {
                get: function() {
                    return this.foundation.getScrimClickAction();
                },
                set: function(action) {
                    this.foundation.setScrimClickAction(action);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCDialog.prototype, "autoStackButtons", {
                get: function() {
                    return this.foundation.getAutoStackButtons();
                },
                set: function(autoStack) {
                    this.foundation.setAutoStackButtons(autoStack);
                },
                enumerable: true,
                configurable: true
            });
            MDCDialog.attachTo = function(root) {
                return new MDCDialog(root);
            };
            MDCDialog.prototype.initialize = function(focusTrapFactory) {
                var e_1, _a;
                if (focusTrapFactory === void 0) {
                    focusTrapFactory = function(el, focusOptions) {
                        return new FocusTrap(el, focusOptions);
                    };
                }
                var container = this.root.querySelector(component_strings.CONTAINER_SELECTOR);
                if (!container) {
                    throw new Error("Dialog component requires a " + component_strings.CONTAINER_SELECTOR + " container element");
                }
                this.container_ = container;
                this.content_ = this.root.querySelector(component_strings.CONTENT_SELECTOR);
                this.buttons_ = [].slice.call(this.root.querySelectorAll(component_strings.BUTTON_SELECTOR));
                this.defaultButton_ = this.root.querySelector("[" + component_strings.BUTTON_DEFAULT_ATTRIBUTE + "]");
                this.focusTrapFactory_ = focusTrapFactory;
                this.buttonRipples_ = [];
                try {
                    for (var _b = __values(this.buttons_), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var buttonEl = _c.value;
                        this.buttonRipples_.push(new MDCRipple(buttonEl));
                    }
                } catch (e_1_1) {
                    e_1 = {
                        error: e_1_1
                    };
                } finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    } finally {
                        if (e_1) throw e_1.error;
                    }
                }
            };
            MDCDialog.prototype.initialSyncWithDOM = function() {
                var _this = this;
                this.focusTrap_ = createFocusTrapInstance(this.container_, this.focusTrapFactory_, this.getInitialFocusEl_() || undefined);
                this.handleClick_ = this.foundation.handleClick.bind(this.foundation);
                this.handleKeydown_ = this.foundation.handleKeydown.bind(this.foundation);
                this.handleDocumentKeydown_ = this.foundation.handleDocumentKeydown.bind(this.foundation);
                this.handleLayout_ = this.layout.bind(this);
                var LAYOUT_EVENTS = [ "resize", "orientationchange" ];
                this.handleOpening_ = function() {
                    LAYOUT_EVENTS.forEach((function(evtType) {
                        return window.addEventListener(evtType, _this.handleLayout_);
                    }));
                    document.addEventListener("keydown", _this.handleDocumentKeydown_);
                };
                this.handleClosing_ = function() {
                    LAYOUT_EVENTS.forEach((function(evtType) {
                        return window.removeEventListener(evtType, _this.handleLayout_);
                    }));
                    document.removeEventListener("keydown", _this.handleDocumentKeydown_);
                };
                this.listen("click", this.handleClick_);
                this.listen("keydown", this.handleKeydown_);
                this.listen(component_strings.OPENING_EVENT, this.handleOpening_);
                this.listen(component_strings.CLOSING_EVENT, this.handleClosing_);
            };
            MDCDialog.prototype.destroy = function() {
                this.unlisten("click", this.handleClick_);
                this.unlisten("keydown", this.handleKeydown_);
                this.unlisten(component_strings.OPENING_EVENT, this.handleOpening_);
                this.unlisten(component_strings.CLOSING_EVENT, this.handleClosing_);
                this.handleClosing_();
                this.buttonRipples_.forEach((function(ripple) {
                    return ripple.destroy();
                }));
                _super.prototype.destroy.call(this);
            };
            MDCDialog.prototype.layout = function() {
                this.foundation.layout();
            };
            MDCDialog.prototype.open = function() {
                this.foundation.open();
            };
            MDCDialog.prototype.close = function(action) {
                if (action === void 0) {
                    action = "";
                }
                this.foundation.close(action);
            };
            MDCDialog.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    addBodyClass: function(className) {
                        return document.body.classList.add(className);
                    },
                    addClass: function(className) {
                        return _this.root.classList.add(className);
                    },
                    areButtonsStacked: function() {
                        return areTopsMisaligned(_this.buttons_);
                    },
                    clickDefaultButton: function() {
                        return _this.defaultButton_ && _this.defaultButton_.click();
                    },
                    eventTargetMatches: function(target, selector) {
                        return target ? matches(target, selector) : false;
                    },
                    getActionFromEvent: function(evt) {
                        if (!evt.target) {
                            return "";
                        }
                        var element = closest(evt.target, "[" + component_strings.ACTION_ATTRIBUTE + "]");
                        return element && element.getAttribute(component_strings.ACTION_ATTRIBUTE);
                    },
                    getInitialFocusEl: function() {
                        return _this.getInitialFocusEl_();
                    },
                    hasClass: function(className) {
                        return _this.root.classList.contains(className);
                    },
                    isContentScrollable: function() {
                        return isScrollable(_this.content_);
                    },
                    notifyClosed: function(action) {
                        return _this.emit(component_strings.CLOSED_EVENT, action ? {
                            action: action
                        } : {});
                    },
                    notifyClosing: function(action) {
                        return _this.emit(component_strings.CLOSING_EVENT, action ? {
                            action: action
                        } : {});
                    },
                    notifyOpened: function() {
                        return _this.emit(component_strings.OPENED_EVENT, {});
                    },
                    notifyOpening: function() {
                        return _this.emit(component_strings.OPENING_EVENT, {});
                    },
                    releaseFocus: function() {
                        return _this.focusTrap_.releaseFocus();
                    },
                    removeBodyClass: function(className) {
                        return document.body.classList.remove(className);
                    },
                    removeClass: function(className) {
                        return _this.root.classList.remove(className);
                    },
                    reverseButtons: function() {
                        _this.buttons_.reverse();
                        _this.buttons_.forEach((function(button) {
                            button.parentElement.appendChild(button);
                        }));
                    },
                    trapFocus: function() {
                        return _this.focusTrap_.trapFocus();
                    }
                };
                return new MDCDialogFoundation(adapter);
            };
            MDCDialog.prototype.getInitialFocusEl_ = function() {
                return this.root.querySelector("[" + component_strings.INITIAL_FOCUS_ATTRIBUTE + "]");
            };
            return MDCDialog;
        }(MDCComponent);
        function show(elem, dotNetObject, escapeKeyAction, scrimClickAction) {
            elem._dialog = elem._dialog || MDCDialog.attachTo(elem);
            elem._dotNetObject = dotNetObject;
            var dialog = elem._dialog;
            var openedCallback = function openedCallback() {
                dialog.unlisten("MDCDialog:opened", openedCallback);
                dotNetObject.invokeMethodAsync("NotifyOpened");
            };
            dialog.listen("MDCDialog:opened", openedCallback);
            dialog.escapeKeyAction = escapeKeyAction;
            dialog.scrimClickAction = scrimClickAction;
            var closingCallback = function closingCallback(event) {
                dialog.unlisten("MDCDialog:closing", closingCallback);
                dotNetObject.invokeMethodAsync("NotifyClosed", event.detail.action);
            };
            dialog.listen("MDCDialog:closing", closingCallback);
            dialog.open();
        }
        function hide(elem, dialogAction) {
            if (elem && elem._dialog) {
                elem._dialog.close(dialogAction || "dismissed");
                elem._dialog.destroy();
            }
        }
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var drawer_constants_cssClasses = {
            ANIMATE: "mdc-drawer--animate",
            CLOSING: "mdc-drawer--closing",
            DISMISSIBLE: "mdc-drawer--dismissible",
            MODAL: "mdc-drawer--modal",
            OPEN: "mdc-drawer--open",
            OPENING: "mdc-drawer--opening",
            ROOT: "mdc-drawer"
        };
        var drawer_constants_strings = {
            APP_CONTENT_SELECTOR: ".mdc-drawer-app-content",
            CLOSE_EVENT: "MDCDrawer:closed",
            OPEN_EVENT: "MDCDrawer:opened",
            SCRIM_SELECTOR: ".mdc-drawer-scrim"
        };
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCDismissibleDrawerFoundation = function(_super) {
            __extends(MDCDismissibleDrawerFoundation, _super);
            function MDCDismissibleDrawerFoundation(adapter) {
                var _this = _super.call(this, __assign(__assign({}, MDCDismissibleDrawerFoundation.defaultAdapter), adapter)) || this;
                _this.animationFrame_ = 0;
                _this.animationTimer_ = 0;
                return _this;
            }
            Object.defineProperty(MDCDismissibleDrawerFoundation, "strings", {
                get: function() {
                    return drawer_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCDismissibleDrawerFoundation, "cssClasses", {
                get: function() {
                    return drawer_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCDismissibleDrawerFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClass: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        hasClass: function() {
                            return false;
                        },
                        elementHasClass: function() {
                            return false;
                        },
                        notifyClose: function() {
                            return undefined;
                        },
                        notifyOpen: function() {
                            return undefined;
                        },
                        saveFocus: function() {
                            return undefined;
                        },
                        restoreFocus: function() {
                            return undefined;
                        },
                        focusActiveNavigationItem: function() {
                            return undefined;
                        },
                        trapFocus: function() {
                            return undefined;
                        },
                        releaseFocus: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCDismissibleDrawerFoundation.prototype.destroy = function() {
                if (this.animationFrame_) {
                    cancelAnimationFrame(this.animationFrame_);
                }
                if (this.animationTimer_) {
                    clearTimeout(this.animationTimer_);
                }
            };
            MDCDismissibleDrawerFoundation.prototype.open = function() {
                var _this = this;
                if (this.isOpen() || this.isOpening() || this.isClosing()) {
                    return;
                }
                this.adapter.addClass(drawer_constants_cssClasses.OPEN);
                this.adapter.addClass(drawer_constants_cssClasses.ANIMATE);
                this.runNextAnimationFrame_((function() {
                    _this.adapter.addClass(drawer_constants_cssClasses.OPENING);
                }));
                this.adapter.saveFocus();
            };
            MDCDismissibleDrawerFoundation.prototype.close = function() {
                if (!this.isOpen() || this.isOpening() || this.isClosing()) {
                    return;
                }
                this.adapter.addClass(drawer_constants_cssClasses.CLOSING);
            };
            MDCDismissibleDrawerFoundation.prototype.isOpen = function() {
                return this.adapter.hasClass(drawer_constants_cssClasses.OPEN);
            };
            MDCDismissibleDrawerFoundation.prototype.isOpening = function() {
                return this.adapter.hasClass(drawer_constants_cssClasses.OPENING) || this.adapter.hasClass(drawer_constants_cssClasses.ANIMATE);
            };
            MDCDismissibleDrawerFoundation.prototype.isClosing = function() {
                return this.adapter.hasClass(drawer_constants_cssClasses.CLOSING);
            };
            MDCDismissibleDrawerFoundation.prototype.handleKeydown = function(evt) {
                var keyCode = evt.keyCode, key = evt.key;
                var isEscape = key === "Escape" || keyCode === 27;
                if (isEscape) {
                    this.close();
                }
            };
            MDCDismissibleDrawerFoundation.prototype.handleTransitionEnd = function(evt) {
                var OPENING = drawer_constants_cssClasses.OPENING, CLOSING = drawer_constants_cssClasses.CLOSING, OPEN = drawer_constants_cssClasses.OPEN, ANIMATE = drawer_constants_cssClasses.ANIMATE, ROOT = drawer_constants_cssClasses.ROOT;
                var isRootElement = this.isElement_(evt.target) && this.adapter.elementHasClass(evt.target, ROOT);
                if (!isRootElement) {
                    return;
                }
                if (this.isClosing()) {
                    this.adapter.removeClass(OPEN);
                    this.closed_();
                    this.adapter.restoreFocus();
                    this.adapter.notifyClose();
                } else {
                    this.adapter.focusActiveNavigationItem();
                    this.opened_();
                    this.adapter.notifyOpen();
                }
                this.adapter.removeClass(ANIMATE);
                this.adapter.removeClass(OPENING);
                this.adapter.removeClass(CLOSING);
            };
            MDCDismissibleDrawerFoundation.prototype.opened_ = function() {};
            MDCDismissibleDrawerFoundation.prototype.closed_ = function() {};
            MDCDismissibleDrawerFoundation.prototype.runNextAnimationFrame_ = function(callback) {
                var _this = this;
                cancelAnimationFrame(this.animationFrame_);
                this.animationFrame_ = requestAnimationFrame((function() {
                    _this.animationFrame_ = 0;
                    clearTimeout(_this.animationTimer_);
                    _this.animationTimer_ = setTimeout(callback, 0);
                }));
            };
            MDCDismissibleDrawerFoundation.prototype.isElement_ = function(element) {
                return Boolean(element.classList);
            };
            return MDCDismissibleDrawerFoundation;
        }(MDCFoundation);
        const dismissible_foundation = null && MDCDismissibleDrawerFoundation;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCModalDrawerFoundation = function(_super) {
            __extends(MDCModalDrawerFoundation, _super);
            function MDCModalDrawerFoundation() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCModalDrawerFoundation.prototype.handleScrimClick = function() {
                this.close();
            };
            MDCModalDrawerFoundation.prototype.opened_ = function() {
                this.adapter.trapFocus();
            };
            MDCModalDrawerFoundation.prototype.closed_ = function() {
                this.adapter.releaseFocus();
            };
            return MDCModalDrawerFoundation;
        }(MDCDismissibleDrawerFoundation);
        const modal_foundation = null && MDCModalDrawerFoundation;
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        function util_createFocusTrapInstance(surfaceEl, focusTrapFactory) {
            return focusTrapFactory(surfaceEl, {
                skipInitialFocus: true
            });
        }
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var component_cssClasses = MDCDismissibleDrawerFoundation.cssClasses, drawer_component_strings = MDCDismissibleDrawerFoundation.strings;
        var MDCDrawer = function(_super) {
            __extends(MDCDrawer, _super);
            function MDCDrawer() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCDrawer.attachTo = function(root) {
                return new MDCDrawer(root);
            };
            Object.defineProperty(MDCDrawer.prototype, "open", {
                get: function() {
                    return this.foundation.isOpen();
                },
                set: function(isOpen) {
                    if (isOpen) {
                        this.foundation.open();
                    } else {
                        this.foundation.close();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCDrawer.prototype, "list", {
                get: function() {
                    return this.list_;
                },
                enumerable: true,
                configurable: true
            });
            MDCDrawer.prototype.initialize = function(focusTrapFactory, listFactory) {
                if (focusTrapFactory === void 0) {
                    focusTrapFactory = function(el) {
                        return new FocusTrap(el);
                    };
                }
                if (listFactory === void 0) {
                    listFactory = function(el) {
                        return new MDCList(el);
                    };
                }
                var listEl = this.root.querySelector("." + MDCListFoundation.cssClasses.ROOT);
                if (listEl) {
                    this.list_ = listFactory(listEl);
                    this.list_.wrapFocus = true;
                }
                this.focusTrapFactory_ = focusTrapFactory;
            };
            MDCDrawer.prototype.initialSyncWithDOM = function() {
                var _this = this;
                var MODAL = component_cssClasses.MODAL;
                var SCRIM_SELECTOR = drawer_component_strings.SCRIM_SELECTOR;
                this.scrim_ = this.root.parentNode.querySelector(SCRIM_SELECTOR);
                if (this.scrim_ && this.root.classList.contains(MODAL)) {
                    this.handleScrimClick_ = function() {
                        return _this.foundation.handleScrimClick();
                    };
                    this.scrim_.addEventListener("click", this.handleScrimClick_);
                    this.focusTrap_ = util_createFocusTrapInstance(this.root, this.focusTrapFactory_);
                }
                this.handleKeydown_ = function(evt) {
                    return _this.foundation.handleKeydown(evt);
                };
                this.handleTransitionEnd_ = function(evt) {
                    return _this.foundation.handleTransitionEnd(evt);
                };
                this.listen("keydown", this.handleKeydown_);
                this.listen("transitionend", this.handleTransitionEnd_);
            };
            MDCDrawer.prototype.destroy = function() {
                this.unlisten("keydown", this.handleKeydown_);
                this.unlisten("transitionend", this.handleTransitionEnd_);
                if (this.list_) {
                    this.list_.destroy();
                }
                var MODAL = component_cssClasses.MODAL;
                if (this.scrim_ && this.handleScrimClick_ && this.root.classList.contains(MODAL)) {
                    this.scrim_.removeEventListener("click", this.handleScrimClick_);
                    this.open = false;
                }
            };
            MDCDrawer.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    addClass: function(className) {
                        return _this.root.classList.add(className);
                    },
                    removeClass: function(className) {
                        return _this.root.classList.remove(className);
                    },
                    hasClass: function(className) {
                        return _this.root.classList.contains(className);
                    },
                    elementHasClass: function(element, className) {
                        return element.classList.contains(className);
                    },
                    saveFocus: function() {
                        return _this.previousFocus_ = document.activeElement;
                    },
                    restoreFocus: function() {
                        var previousFocus = _this.previousFocus_;
                        if (previousFocus && previousFocus.focus && _this.root.contains(document.activeElement)) {
                            previousFocus.focus();
                        }
                    },
                    focusActiveNavigationItem: function() {
                        var activeNavItemEl = _this.root.querySelector("." + MDCListFoundation.cssClasses.LIST_ITEM_ACTIVATED_CLASS);
                        if (activeNavItemEl) {
                            activeNavItemEl.focus();
                        }
                    },
                    notifyClose: function() {
                        return _this.emit(drawer_component_strings.CLOSE_EVENT, {}, true);
                    },
                    notifyOpen: function() {
                        return _this.emit(drawer_component_strings.OPEN_EVENT, {}, true);
                    },
                    trapFocus: function() {
                        return _this.focusTrap_.trapFocus();
                    },
                    releaseFocus: function() {
                        return _this.focusTrap_.releaseFocus();
                    }
                };
                var DISMISSIBLE = component_cssClasses.DISMISSIBLE, MODAL = component_cssClasses.MODAL;
                if (this.root.classList.contains(DISMISSIBLE)) {
                    return new MDCDismissibleDrawerFoundation(adapter);
                } else if (this.root.classList.contains(MODAL)) {
                    return new MDCModalDrawerFoundation(adapter);
                } else {
                    throw new Error("MDCDrawer: Failed to instantiate component. Supported variants are " + DISMISSIBLE + " and " + MODAL + ".");
                }
            };
            return MDCDrawer;
        }(MDCComponent);
        function MBDrawer_init(elem, isOpen) {
            elem._drawer = MDCDrawer.attachTo(elem);
            toggle(elem, isOpen);
        }
        function toggle(elem, isOpen) {
            elem._drawer.open = isOpen;
        }
        function MBFloatingActionButton_init(elem, exited) {
            elem._fab = MDCRipple.attachTo(elem);
            elem._exited = false;
            setExited(elem, exited);
        }
        function setExited(elem, exited) {
            if (elem) {
                if (exited != elem._exited) {
                    elem.classList.add("mdc-fab--exited");
                } else {
                    elem.classList.remove("mdc-fab--exited");
                }
            }
        }
        function syncScrollByID(gridHeaderID, gridBodyID) {
            var headerDiv = document.getElementById(gridHeaderID);
            var bodyDiv = document.getElementById(gridBodyID);
            if (headerDiv != null && bodyDiv != null) {
                headerDiv.scrollLeft = bodyDiv.scrollLeft;
            }
        }
        function syncScrollByRef(gridHeaderRef, gridBodyRef) {
            gridHeaderRef.scrollLeft = gridBodyRef.scrollLeft;
        }
        function getScrollBarWidth(className) {
            var firstDiv = document.createElement("div");
            firstDiv.style.position = "absolute";
            firstDiv.style.visibility = "hidden";
            firstDiv.style.whiteSpace = "nowrap";
            firstDiv.style.left = "-9999px";
            firstDiv.className = className;
            document.body.appendChild(firstDiv);
            var secondDiv = document.createElement("div");
            firstDiv.appendChild(secondDiv);
            var width = firstDiv.offsetWidth - secondDiv.offsetWidth;
            document.body.removeChild(firstDiv);
            return width;
        }
        function getTextWidths(className, currentWidths, textToMeasure) {
            var ele = document.createElement("div");
            ele.style.position = "absolute";
            ele.style.visibility = "hidden";
            ele.style.whiteSpace = "nowrap";
            ele.style.left = "-9999px";
            ele.className = className;
            document.body.appendChild(ele);
            for (var i = 0; i < textToMeasure.length; i++) {
                ele.innerText = textToMeasure[i];
                var width = window.getComputedStyle(ele).width;
                var unadornedWidth = width.slice(0, width.indexOf("px"));
                var numericWidth = parseFloat(unadornedWidth);
                var indexMod = i % currentWidths.length;
                if (numericWidth > currentWidths[indexMod]) {
                    currentWidths[indexMod] = numericWidth;
                }
            }
            document.body.removeChild(ele);
            return currentWidths;
        }
        function MBIconButton_init(elem) {
            elem._ripple = MDCRipple.attachTo(elem);
            elem._ripple.unbounded = true;
        }
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var icon_button_constants_cssClasses = {
            ICON_BUTTON_ON: "mdc-icon-button--on",
            ROOT: "mdc-icon-button"
        };
        var icon_button_constants_strings = {
            ARIA_LABEL: "aria-label",
            ARIA_PRESSED: "aria-pressed",
            DATA_ARIA_LABEL_OFF: "data-aria-label-off",
            DATA_ARIA_LABEL_ON: "data-aria-label-on",
            CHANGE_EVENT: "MDCIconButtonToggle:change"
        };
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCIconButtonToggleFoundation = function(_super) {
            __extends(MDCIconButtonToggleFoundation, _super);
            function MDCIconButtonToggleFoundation(adapter) {
                var _this = _super.call(this, __assign(__assign({}, MDCIconButtonToggleFoundation.defaultAdapter), adapter)) || this;
                _this.hasToggledAriaLabel = false;
                return _this;
            }
            Object.defineProperty(MDCIconButtonToggleFoundation, "cssClasses", {
                get: function() {
                    return icon_button_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCIconButtonToggleFoundation, "strings", {
                get: function() {
                    return icon_button_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCIconButtonToggleFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClass: function() {
                            return undefined;
                        },
                        hasClass: function() {
                            return false;
                        },
                        notifyChange: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        getAttr: function() {
                            return null;
                        },
                        setAttr: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCIconButtonToggleFoundation.prototype.init = function() {
                var ariaLabelOn = this.adapter.getAttr(icon_button_constants_strings.DATA_ARIA_LABEL_ON);
                var ariaLabelOff = this.adapter.getAttr(icon_button_constants_strings.DATA_ARIA_LABEL_OFF);
                if (ariaLabelOn && ariaLabelOff) {
                    if (this.adapter.getAttr(icon_button_constants_strings.ARIA_PRESSED) !== null) {
                        throw new Error("MDCIconButtonToggleFoundation: Button should not set " + "`aria-pressed` if it has a toggled aria label.");
                    }
                    this.hasToggledAriaLabel = true;
                } else {
                    this.adapter.setAttr(icon_button_constants_strings.ARIA_PRESSED, String(this.isOn()));
                }
            };
            MDCIconButtonToggleFoundation.prototype.handleClick = function() {
                this.toggle();
                this.adapter.notifyChange({
                    isOn: this.isOn()
                });
            };
            MDCIconButtonToggleFoundation.prototype.isOn = function() {
                return this.adapter.hasClass(icon_button_constants_cssClasses.ICON_BUTTON_ON);
            };
            MDCIconButtonToggleFoundation.prototype.toggle = function(isOn) {
                if (isOn === void 0) {
                    isOn = !this.isOn();
                }
                if (isOn) {
                    this.adapter.addClass(icon_button_constants_cssClasses.ICON_BUTTON_ON);
                } else {
                    this.adapter.removeClass(icon_button_constants_cssClasses.ICON_BUTTON_ON);
                }
                if (this.hasToggledAriaLabel) {
                    var ariaLabel = isOn ? this.adapter.getAttr(icon_button_constants_strings.DATA_ARIA_LABEL_ON) : this.adapter.getAttr(icon_button_constants_strings.DATA_ARIA_LABEL_OFF);
                    this.adapter.setAttr(icon_button_constants_strings.ARIA_LABEL, ariaLabel || "");
                } else {
                    this.adapter.setAttr(icon_button_constants_strings.ARIA_PRESSED, "" + isOn);
                }
            };
            return MDCIconButtonToggleFoundation;
        }(MDCFoundation);
        const icon_button_foundation = null && MDCIconButtonToggleFoundation;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var icon_button_component_strings = MDCIconButtonToggleFoundation.strings;
        var MDCIconButtonToggle = function(_super) {
            __extends(MDCIconButtonToggle, _super);
            function MDCIconButtonToggle() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.rippleComponent = _this.createRipple();
                return _this;
            }
            MDCIconButtonToggle.attachTo = function(root) {
                return new MDCIconButtonToggle(root);
            };
            MDCIconButtonToggle.prototype.initialSyncWithDOM = function() {
                var _this = this;
                this.handleClick = function() {
                    _this.foundation.handleClick();
                };
                this.listen("click", this.handleClick);
            };
            MDCIconButtonToggle.prototype.destroy = function() {
                this.unlisten("click", this.handleClick);
                this.ripple.destroy();
                _super.prototype.destroy.call(this);
            };
            MDCIconButtonToggle.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    addClass: function(className) {
                        return _this.root.classList.add(className);
                    },
                    hasClass: function(className) {
                        return _this.root.classList.contains(className);
                    },
                    notifyChange: function(evtData) {
                        _this.emit(icon_button_component_strings.CHANGE_EVENT, evtData);
                    },
                    removeClass: function(className) {
                        return _this.root.classList.remove(className);
                    },
                    getAttr: function(attrName) {
                        return _this.root.getAttribute(attrName);
                    },
                    setAttr: function(attrName, attrValue) {
                        return _this.root.setAttribute(attrName, attrValue);
                    }
                };
                return new MDCIconButtonToggleFoundation(adapter);
            };
            Object.defineProperty(MDCIconButtonToggle.prototype, "ripple", {
                get: function() {
                    return this.rippleComponent;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCIconButtonToggle.prototype, "on", {
                get: function() {
                    return this.foundation.isOn();
                },
                set: function(isOn) {
                    this.foundation.toggle(isOn);
                },
                enumerable: true,
                configurable: true
            });
            MDCIconButtonToggle.prototype.createRipple = function() {
                var ripple = new MDCRipple(this.root);
                ripple.unbounded = true;
                return ripple;
            };
            return MDCIconButtonToggle;
        }(MDCComponent);
        function MBIconButtonToggle_init(elem) {
            elem._iconButtonToggle = MDCIconButtonToggle.attachTo(elem);
        }
        function setOn(elem, isOn) {
            elem._iconButtonToggle.on = isOn;
        }
        function click(elem) {
            elem._iconButtonToggle.root.click();
        }
        function MBLinearProgress_init(elem, progress, buffer) {
            elem._linearProgress = MDCLinearProgress.attachTo(elem);
            MBLinearProgress_setProgress(elem, progress, buffer);
        }
        function MBLinearProgress_setProgress(elem, progress, buffer) {
            elem._linearProgress.progress = progress;
            elem._linearProgress.buffer = buffer;
        }
        function MBList_init(elem, keyboardInteractions, ripple) {
            if (keyboardInteractions == true) {
                elem._list = MDCList.attachTo(elem);
                if (ripple == true) {
                    elem._list.listElements.map((function(elem) {
                        return MDCRipple.attachTo(elem);
                    }));
                }
            }
        }
        function MBMenu_init(elem, dotNetObject) {
            elem._menu = MDCMenu.attachTo(elem);
            var closedCallback = function closedCallback() {
                dotNetObject.invokeMethodAsync("NotifyClosed");
            };
            elem._menu.listen("MDCMenuSurface:closed", closedCallback);
        }
        function MBMenu_show(elem) {
            if (elem._menu) {
                elem._menu.open = true;
            }
        }
        function MBMenu_hide(elem) {
            if (elem._menu) {
                elem._menu.open = false;
            }
        }
        function MBMenuSurface_init(elem, dotNetObject) {
            elem._menu = MDCMenuSurface.attachTo(elem);
            var closedCallback = function closedCallback() {
                dotNetObject.invokeMethodAsync("NotifyClosed");
            };
            elem._menu.listen("MDCMenuSurface:closed", closedCallback);
        }
        function MBMenuSurface_show(elem) {
            if (elem._menu) {
                elem._menu.open();
            }
        }
        function MBMenuSurface_hide(elem) {
            if (elem._menu) {
                elem._menu.close();
            }
        }
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var radio_constants_strings = {
            NATIVE_CONTROL_SELECTOR: ".mdc-radio__native-control"
        };
        var radio_constants_cssClasses = {
            DISABLED: "mdc-radio--disabled",
            ROOT: "mdc-radio"
        };
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCRadioFoundation = function(_super) {
            __extends(MDCRadioFoundation, _super);
            function MDCRadioFoundation(adapter) {
                return _super.call(this, __assign(__assign({}, MDCRadioFoundation.defaultAdapter), adapter)) || this;
            }
            Object.defineProperty(MDCRadioFoundation, "cssClasses", {
                get: function() {
                    return radio_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCRadioFoundation, "strings", {
                get: function() {
                    return radio_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCRadioFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClass: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        setNativeControlDisabled: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCRadioFoundation.prototype.setDisabled = function(disabled) {
                var DISABLED = MDCRadioFoundation.cssClasses.DISABLED;
                this.adapter.setNativeControlDisabled(disabled);
                if (disabled) {
                    this.adapter.addClass(DISABLED);
                } else {
                    this.adapter.removeClass(DISABLED);
                }
            };
            return MDCRadioFoundation;
        }(MDCFoundation);
        const radio_foundation = null && MDCRadioFoundation;
        /**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCRadio = function(_super) {
            __extends(MDCRadio, _super);
            function MDCRadio() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.ripple_ = _this.createRipple_();
                return _this;
            }
            MDCRadio.attachTo = function(root) {
                return new MDCRadio(root);
            };
            Object.defineProperty(MDCRadio.prototype, "checked", {
                get: function() {
                    return this.nativeControl_.checked;
                },
                set: function(checked) {
                    this.nativeControl_.checked = checked;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCRadio.prototype, "disabled", {
                get: function() {
                    return this.nativeControl_.disabled;
                },
                set: function(disabled) {
                    this.foundation.setDisabled(disabled);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCRadio.prototype, "value", {
                get: function() {
                    return this.nativeControl_.value;
                },
                set: function(value) {
                    this.nativeControl_.value = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCRadio.prototype, "ripple", {
                get: function() {
                    return this.ripple_;
                },
                enumerable: true,
                configurable: true
            });
            MDCRadio.prototype.destroy = function() {
                this.ripple_.destroy();
                _super.prototype.destroy.call(this);
            };
            MDCRadio.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    addClass: function(className) {
                        return _this.root.classList.add(className);
                    },
                    removeClass: function(className) {
                        return _this.root.classList.remove(className);
                    },
                    setNativeControlDisabled: function(disabled) {
                        return _this.nativeControl_.disabled = disabled;
                    }
                };
                return new MDCRadioFoundation(adapter);
            };
            MDCRadio.prototype.createRipple_ = function() {
                var _this = this;
                var adapter = __assign(__assign({}, MDCRipple.createAdapter(this)), {
                    registerInteractionHandler: function(evtType, handler) {
                        return _this.nativeControl_.addEventListener(evtType, handler, applyPassive());
                    },
                    deregisterInteractionHandler: function(evtType, handler) {
                        return _this.nativeControl_.removeEventListener(evtType, handler, applyPassive());
                    },
                    isSurfaceActive: function() {
                        return false;
                    },
                    isUnbounded: function() {
                        return true;
                    }
                });
                return new MDCRipple(this.root, new MDCRippleFoundation(adapter));
            };
            Object.defineProperty(MDCRadio.prototype, "nativeControl_", {
                get: function() {
                    var NATIVE_CONTROL_SELECTOR = MDCRadioFoundation.strings.NATIVE_CONTROL_SELECTOR;
                    var el = this.root.querySelector(NATIVE_CONTROL_SELECTOR);
                    if (!el) {
                        throw new Error("Radio component requires a " + NATIVE_CONTROL_SELECTOR + " element");
                    }
                    return el;
                },
                enumerable: true,
                configurable: true
            });
            return MDCRadio;
        }(MDCComponent);
        function MBRadioButton_init(elem, formFieldElem, isChecked) {
            elem._radio = MDCRadio.attachTo(elem);
            elem._radio.checked = isChecked;
            elem._formField = MDCFormField.attachTo(formFieldElem);
            elem._formField.input = elem._radio;
        }
        function MBRadioButton_setDisabled(elem, value) {
            elem._radio.disabled = value;
        }
        function MBRadioButton_setChecked(elem, isChecked) {
            elem._radio.checked = isChecked;
        }
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var constants_selectors = {
            SEGMENT: ".mdc-segmented-button__segment"
        };
        var constants_events = {
            SELECTED: "selected",
            CHANGE: "change"
        };
        var segmented_button_constants_cssClasses = {
            SINGLE_SELECT: "mdc-segmented-button--single-select"
        };
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCSegmentedButtonFoundation = function(_super) {
            __extends(MDCSegmentedButtonFoundation, _super);
            function MDCSegmentedButtonFoundation(adapter) {
                return _super.call(this, __assign(__assign({}, MDCSegmentedButtonFoundation.defaultAdapter), adapter)) || this;
            }
            Object.defineProperty(MDCSegmentedButtonFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        hasClass: function() {
                            return false;
                        },
                        getSegments: function() {
                            return [];
                        },
                        selectSegment: function() {
                            return undefined;
                        },
                        unselectSegment: function() {
                            return undefined;
                        },
                        notifySelectedChange: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCSegmentedButtonFoundation.prototype.selectSegment = function(indexOrSegmentId) {
                this.adapter.selectSegment(indexOrSegmentId);
            };
            MDCSegmentedButtonFoundation.prototype.unselectSegment = function(indexOrSegmentId) {
                this.adapter.unselectSegment(indexOrSegmentId);
            };
            MDCSegmentedButtonFoundation.prototype.getSelectedSegments = function() {
                return this.adapter.getSegments().filter((function(segmentDetail) {
                    return segmentDetail.selected;
                }));
            };
            MDCSegmentedButtonFoundation.prototype.isSegmentSelected = function(indexOrSegmentId) {
                return this.adapter.getSegments().some((function(segmentDetail) {
                    return (segmentDetail.index === indexOrSegmentId || segmentDetail.segmentId === indexOrSegmentId) && segmentDetail.selected;
                }));
            };
            MDCSegmentedButtonFoundation.prototype.isSingleSelect = function() {
                return this.adapter.hasClass(segmented_button_constants_cssClasses.SINGLE_SELECT);
            };
            MDCSegmentedButtonFoundation.prototype.handleSelected = function(detail) {
                if (this.isSingleSelect()) {
                    this.unselectPrevSelected(detail.index);
                }
                this.adapter.notifySelectedChange(detail);
            };
            MDCSegmentedButtonFoundation.prototype.unselectPrevSelected = function(index) {
                var e_1, _a;
                try {
                    for (var _b = __values(this.getSelectedSegments()), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var selectedSegment = _c.value;
                        if (selectedSegment.index !== index) {
                            this.unselectSegment(selectedSegment.index);
                        }
                    }
                } catch (e_1_1) {
                    e_1 = {
                        error: e_1_1
                    };
                } finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    } finally {
                        if (e_1) throw e_1.error;
                    }
                }
            };
            return MDCSegmentedButtonFoundation;
        }(MDCFoundation);
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var booleans = {
            TRUE: "true",
            FALSE: "false"
        };
        var constants_attributes = {
            ARIA_CHECKED: "aria-checked",
            ARIA_PRESSED: "aria-pressed",
            DATA_SEGMENT_ID: "data-segment-id"
        };
        var segment_constants_events = {
            CLICK: "click",
            SELECTED: "selected"
        };
        var segment_constants_cssClasses = {
            SELECTED: "mdc-segmented-button__segment--selected"
        };
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var foundation_emptyClientRect = {
            bottom: 0,
            height: 0,
            left: 0,
            right: 0,
            top: 0,
            width: 0
        };
        var MDCSegmentedButtonSegmentFoundation = function(_super) {
            __extends(MDCSegmentedButtonSegmentFoundation, _super);
            function MDCSegmentedButtonSegmentFoundation(adapter) {
                return _super.call(this, __assign(__assign({}, MDCSegmentedButtonSegmentFoundation.defaultAdapter), adapter)) || this;
            }
            Object.defineProperty(MDCSegmentedButtonSegmentFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        isSingleSelect: function() {
                            return false;
                        },
                        getAttr: function() {
                            return "";
                        },
                        setAttr: function() {
                            return undefined;
                        },
                        addClass: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        hasClass: function() {
                            return false;
                        },
                        notifySelectedChange: function() {
                            return undefined;
                        },
                        getRootBoundingClientRect: function() {
                            return foundation_emptyClientRect;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCSegmentedButtonSegmentFoundation.prototype.isSelected = function() {
                return this.adapter.hasClass(segment_constants_cssClasses.SELECTED);
            };
            MDCSegmentedButtonSegmentFoundation.prototype.setSelected = function() {
                this.adapter.addClass(segment_constants_cssClasses.SELECTED);
                this.setAriaAttr(booleans.TRUE);
            };
            MDCSegmentedButtonSegmentFoundation.prototype.setUnselected = function() {
                this.adapter.removeClass(segment_constants_cssClasses.SELECTED);
                this.setAriaAttr(booleans.FALSE);
            };
            MDCSegmentedButtonSegmentFoundation.prototype.getSegmentId = function() {
                var _a;
                return (_a = this.adapter.getAttr(constants_attributes.DATA_SEGMENT_ID)) !== null && _a !== void 0 ? _a : undefined;
            };
            MDCSegmentedButtonSegmentFoundation.prototype.handleClick = function() {
                if (this.adapter.isSingleSelect()) {
                    this.setSelected();
                } else {
                    this.toggleSelection();
                }
                this.adapter.notifySelectedChange(this.isSelected());
            };
            MDCSegmentedButtonSegmentFoundation.prototype.getDimensions = function() {
                return this.adapter.getRootBoundingClientRect();
            };
            MDCSegmentedButtonSegmentFoundation.prototype.toggleSelection = function() {
                if (this.isSelected()) {
                    this.setUnselected();
                } else {
                    this.setSelected();
                }
            };
            MDCSegmentedButtonSegmentFoundation.prototype.setAriaAttr = function(value) {
                if (this.adapter.isSingleSelect()) {
                    this.adapter.setAttr(constants_attributes.ARIA_CHECKED, value);
                } else {
                    this.adapter.setAttr(constants_attributes.ARIA_PRESSED, value);
                }
            };
            return MDCSegmentedButtonSegmentFoundation;
        }(MDCFoundation);
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCSegmentedButtonSegment = function(_super) {
            __extends(MDCSegmentedButtonSegment, _super);
            function MDCSegmentedButtonSegment() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Object.defineProperty(MDCSegmentedButtonSegment.prototype, "ripple", {
                get: function() {
                    return this.rippleComponent;
                },
                enumerable: true,
                configurable: true
            });
            MDCSegmentedButtonSegment.attachTo = function(root) {
                return new MDCSegmentedButtonSegment(root);
            };
            MDCSegmentedButtonSegment.prototype.initialize = function(rippleFactory) {
                var _this = this;
                if (rippleFactory === void 0) {
                    rippleFactory = function(el, foundation) {
                        return new MDCRipple(el, foundation);
                    };
                }
                var rippleAdapter = __assign(__assign({}, MDCRipple.createAdapter(this)), {
                    computeBoundingRect: function() {
                        return _this.foundation.getDimensions();
                    }
                });
                this.rippleComponent = rippleFactory(this.root, new MDCRippleFoundation(rippleAdapter));
            };
            MDCSegmentedButtonSegment.prototype.initialSyncWithDOM = function() {
                var _this = this;
                this.handleClick = function() {
                    _this.foundation.handleClick();
                };
                this.listen(segment_constants_events.CLICK, this.handleClick);
            };
            MDCSegmentedButtonSegment.prototype.destroy = function() {
                this.ripple.destroy();
                this.unlisten(segment_constants_events.CLICK, this.handleClick);
                _super.prototype.destroy.call(this);
            };
            MDCSegmentedButtonSegment.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    isSingleSelect: function() {
                        return _this.isSingleSelect;
                    },
                    getAttr: function(attrName) {
                        return _this.root.getAttribute(attrName);
                    },
                    setAttr: function(attrName, value) {
                        _this.root.setAttribute(attrName, value);
                    },
                    addClass: function(className) {
                        _this.root.classList.add(className);
                    },
                    removeClass: function(className) {
                        _this.root.classList.remove(className);
                    },
                    hasClass: function(className) {
                        return _this.root.classList.contains(className);
                    },
                    notifySelectedChange: function(selected) {
                        _this.emit(segment_constants_events.SELECTED, {
                            index: _this.index,
                            selected: selected,
                            segmentId: _this.getSegmentId()
                        }, true);
                    },
                    getRootBoundingClientRect: function() {
                        return _this.root.getBoundingClientRect();
                    }
                };
                return new MDCSegmentedButtonSegmentFoundation(adapter);
            };
            MDCSegmentedButtonSegment.prototype.setIndex = function(index) {
                this.index = index;
            };
            MDCSegmentedButtonSegment.prototype.setIsSingleSelect = function(isSingleSelect) {
                this.isSingleSelect = isSingleSelect;
            };
            MDCSegmentedButtonSegment.prototype.isSelected = function() {
                return this.foundation.isSelected();
            };
            MDCSegmentedButtonSegment.prototype.setSelected = function() {
                this.foundation.setSelected();
            };
            MDCSegmentedButtonSegment.prototype.setUnselected = function() {
                this.foundation.setUnselected();
            };
            MDCSegmentedButtonSegment.prototype.getSegmentId = function() {
                return this.foundation.getSegmentId();
            };
            return MDCSegmentedButtonSegment;
        }(MDCComponent);
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCSegmentedButton = function(_super) {
            __extends(MDCSegmentedButton, _super);
            function MDCSegmentedButton() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCSegmentedButton.attachTo = function(root) {
                return new MDCSegmentedButton(root);
            };
            Object.defineProperty(MDCSegmentedButton.prototype, "segments", {
                get: function() {
                    return this.segments_.slice();
                },
                enumerable: true,
                configurable: true
            });
            MDCSegmentedButton.prototype.initialize = function(segmentFactory) {
                if (segmentFactory === void 0) {
                    segmentFactory = function(el) {
                        return new MDCSegmentedButtonSegment(el);
                    };
                }
                this.segmentFactory = segmentFactory;
                this.segments_ = this.instantiateSegments(this.segmentFactory);
            };
            MDCSegmentedButton.prototype.instantiateSegments = function(segmentFactory) {
                var segmentElements = [].slice.call(this.root.querySelectorAll(constants_selectors.SEGMENT));
                return segmentElements.map((function(el) {
                    return segmentFactory(el);
                }));
            };
            MDCSegmentedButton.prototype.initialSyncWithDOM = function() {
                var _this = this;
                this.handleSelected = function(event) {
                    _this.foundation.handleSelected(event.detail);
                };
                this.listen(constants_events.SELECTED, this.handleSelected);
                var isSingleSelect = this.foundation.isSingleSelect();
                this.segments_.forEach((function(segment, index) {
                    segment.setIndex(index);
                    segment.setIsSingleSelect(isSingleSelect);
                }));
                var selectedSegments = this.segments_.filter((function(segment) {
                    return segment.isSelected();
                }));
                if (isSingleSelect && selectedSegments.length == 0 && this.segments_.length > 0) {
                    throw new Error("No segment selected in singleSelect mdc-segmented-button");
                } else if (isSingleSelect && selectedSegments.length > 1) {
                    throw new Error("Multiple segments selected in singleSelect mdc-segmented-button");
                }
            };
            MDCSegmentedButton.prototype.destroy = function() {
                this.segments_.forEach((function(segment) {
                    segment.destroy();
                }));
                this.unlisten(constants_events.SELECTED, this.handleSelected);
                _super.prototype.destroy.call(this);
            };
            MDCSegmentedButton.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    hasClass: function(className) {
                        return _this.root.classList.contains(className);
                    },
                    getSegments: function() {
                        return _this.mappedSegments();
                    },
                    selectSegment: function(indexOrSegmentId) {
                        var segmentDetail = _this.mappedSegments().find((function(_segmentDetail) {
                            return _segmentDetail.index === indexOrSegmentId || _segmentDetail.segmentId === indexOrSegmentId;
                        }));
                        if (segmentDetail) {
                            _this.segments_[segmentDetail.index].setSelected();
                        }
                    },
                    unselectSegment: function(indexOrSegmentId) {
                        var segmentDetail = _this.mappedSegments().find((function(_segmentDetail) {
                            return _segmentDetail.index === indexOrSegmentId || _segmentDetail.segmentId === indexOrSegmentId;
                        }));
                        if (segmentDetail) {
                            _this.segments_[segmentDetail.index].setUnselected();
                        }
                    },
                    notifySelectedChange: function(detail) {
                        _this.emit(constants_events.CHANGE, detail, true);
                    }
                };
                return new MDCSegmentedButtonFoundation(adapter);
            };
            MDCSegmentedButton.prototype.getSelectedSegments = function() {
                return this.foundation.getSelectedSegments();
            };
            MDCSegmentedButton.prototype.selectSegment = function(indexOrSegmentId) {
                this.foundation.selectSegment(indexOrSegmentId);
            };
            MDCSegmentedButton.prototype.unselectSegment = function(indexOrSegmentId) {
                this.foundation.unselectSegment(indexOrSegmentId);
            };
            MDCSegmentedButton.prototype.isSegmentSelected = function(indexOrSegmentId) {
                return this.foundation.isSegmentSelected(indexOrSegmentId);
            };
            MDCSegmentedButton.prototype.mappedSegments = function() {
                return this.segments_.map((function(segment, index) {
                    return {
                        index: index,
                        selected: segment.isSelected(),
                        segmentId: segment.getSegmentId()
                    };
                }));
            };
            return MDCSegmentedButton;
        }(MDCComponent);
        function MBSegmentedButtonMulti_init(elem, isSingleSelect, dotNetObject) {
            elem._segmentedButton = MDCSegmentedButton.attachTo(elem);
            elem._isSingleSelect = isSingleSelect;
            elem._segmentedButton.foundation.adapter.notifySelectedChange = function(detail) {
                if (elem._isSingleSelect) {
                    dotNetObject.invokeMethodAsync("NotifySingleSelected", detail.index);
                } else {
                    dotNetObject.invokeMethodAsync("NotifyMultiSelected", elem._segmentedButton.segments.map((function(x) {
                        return x.isSelected();
                    })));
                }
            };
        }
        function MBSegmentedButtonMulti_setDisabled(elem, value) {
            elem._segmentedButton.disabled = value;
        }
        function MBSegmentedButtonMulti_setSelected(elem, selectedFlags) {
            for (var i = 0; i < selectedFlags.length; i++) {
                if (selectedFlags[i] == true) {
                    elem._segmentedButton.segments[i].setSelected();
                } else {
                    elem._segmentedButton.segments[i].setUnselected();
                }
            }
        }
        function MBSelect_init(elem, dotNetObject) {
            elem._select = MDCSelect.attachTo(elem);
            elem._select.listen("MDCSelect:change", (function() {
                dotNetObject.invokeMethodAsync("NotifySelected", elem._select.selectedIndex);
            }));
        }
        function MBSelect_setDisabled(elem, value) {
            elem._select.disabled = value;
        }
        function setIndex(elem, index) {
            elem._select.selectedIndex = index;
        }
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var slider_constants_cssClasses = {
            DISABLED: "mdc-slider--disabled",
            DISCRETE: "mdc-slider--discrete",
            INPUT: "mdc-slider__input",
            RANGE: "mdc-slider--range",
            THUMB: "mdc-slider__thumb",
            THUMB_KNOB: "mdc-slider__thumb-knob",
            THUMB_TOP: "mdc-slider__thumb--top",
            THUMB_WITH_INDICATOR: "mdc-slider__thumb--with-indicator",
            TICK_MARKS: "mdc-slider--tick-marks",
            TICK_MARKS_CONTAINER: "mdc-slider__tick-marks",
            TICK_MARK_ACTIVE: "mdc-slider__tick-mark--active",
            TICK_MARK_INACTIVE: "mdc-slider__tick-mark--inactive",
            TRACK: "mdc-slider__track",
            TRACK_ACTIVE: "mdc-slider__track--active_fill",
            VALUE_INDICATOR_TEXT: "mdc-slider__value-indicator-text"
        };
        var slider_constants_numbers = {
            STEP_SIZE: 1,
            THUMB_UPDATE_MIN_PX: 5
        };
        var slider_constants_attributes = {
            ARIA_DISABLED: "aria-disabled",
            ARIA_VALUEMAX: "aria-valuemax",
            ARIA_VALUEMIN: "aria-valuemin",
            ARIA_VALUENOW: "aria-valuenow",
            ARIA_VALUETEXT: "aria-valuetext",
            INPUT_DISABLED: "disabled",
            INPUT_MIN: "min",
            INPUT_MAX: "max",
            INPUT_VALUE: "value",
            INPUT_STEP: "step"
        };
        var slider_constants_events = {
            CHANGE: "MDCSlider:change",
            INPUT: "MDCSlider:input"
        };
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var TickMark;
        (function(TickMark) {
            TickMark[TickMark["ACTIVE"] = 0] = "ACTIVE";
            TickMark[TickMark["INACTIVE"] = 1] = "INACTIVE";
        })(TickMark || (TickMark = {}));
        var Thumb;
        (function(Thumb) {
            Thumb[Thumb["START"] = 1] = "START";
            Thumb[Thumb["END"] = 2] = "END";
        })(Thumb || (Thumb = {}));
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var HAS_WINDOW = typeof window !== "undefined";
        var MDCSliderFoundation = function(_super) {
            __extends(MDCSliderFoundation, _super);
            function MDCSliderFoundation(adapter) {
                var _this = _super.call(this, __assign(__assign({}, MDCSliderFoundation.defaultAdapter), adapter)) || this;
                _this.initialStylesRemoved = false;
                _this.isDisabled = false;
                _this.isDiscrete = false;
                _this.step = slider_constants_numbers.STEP_SIZE;
                _this.hasTickMarks = false;
                _this.isRange = false;
                _this.thumb = null;
                _this.downEventClientX = null;
                _this.startThumbKnobWidth = 0;
                _this.endThumbKnobWidth = 0;
                return _this;
            }
            Object.defineProperty(MDCSliderFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        hasClass: function() {
                            return false;
                        },
                        addClass: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        addThumbClass: function() {
                            return undefined;
                        },
                        removeThumbClass: function() {
                            return undefined;
                        },
                        getAttribute: function() {
                            return null;
                        },
                        getInputValue: function() {
                            return "";
                        },
                        setInputValue: function() {
                            return undefined;
                        },
                        getInputAttribute: function() {
                            return null;
                        },
                        setInputAttribute: function() {
                            return null;
                        },
                        removeInputAttribute: function() {
                            return null;
                        },
                        focusInput: function() {
                            return undefined;
                        },
                        isInputFocused: function() {
                            return false;
                        },
                        getThumbKnobWidth: function() {
                            return 0;
                        },
                        getThumbBoundingClientRect: function() {
                            return {
                                top: 0,
                                right: 0,
                                bottom: 0,
                                left: 0,
                                width: 0,
                                height: 0
                            };
                        },
                        getBoundingClientRect: function() {
                            return {
                                top: 0,
                                right: 0,
                                bottom: 0,
                                left: 0,
                                width: 0,
                                height: 0
                            };
                        },
                        isRTL: function() {
                            return false;
                        },
                        setThumbStyleProperty: function() {
                            return undefined;
                        },
                        removeThumbStyleProperty: function() {
                            return undefined;
                        },
                        setTrackActiveStyleProperty: function() {
                            return undefined;
                        },
                        removeTrackActiveStyleProperty: function() {
                            return undefined;
                        },
                        setValueIndicatorText: function() {
                            return undefined;
                        },
                        getValueToAriaValueTextFn: function() {
                            return null;
                        },
                        updateTickMarks: function() {
                            return undefined;
                        },
                        setPointerCapture: function() {
                            return undefined;
                        },
                        emitChangeEvent: function() {
                            return undefined;
                        },
                        emitInputEvent: function() {
                            return undefined;
                        },
                        emitDragStartEvent: function() {
                            return undefined;
                        },
                        emitDragEndEvent: function() {
                            return undefined;
                        },
                        registerEventHandler: function() {
                            return undefined;
                        },
                        deregisterEventHandler: function() {
                            return undefined;
                        },
                        registerThumbEventHandler: function() {
                            return undefined;
                        },
                        deregisterThumbEventHandler: function() {
                            return undefined;
                        },
                        registerInputEventHandler: function() {
                            return undefined;
                        },
                        deregisterInputEventHandler: function() {
                            return undefined;
                        },
                        registerBodyEventHandler: function() {
                            return undefined;
                        },
                        deregisterBodyEventHandler: function() {
                            return undefined;
                        },
                        registerWindowEventHandler: function() {
                            return undefined;
                        },
                        deregisterWindowEventHandler: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCSliderFoundation.prototype.init = function() {
                var _this = this;
                this.isDisabled = this.adapter.hasClass(slider_constants_cssClasses.DISABLED);
                this.isDiscrete = this.adapter.hasClass(slider_constants_cssClasses.DISCRETE);
                this.hasTickMarks = this.adapter.hasClass(slider_constants_cssClasses.TICK_MARKS);
                this.isRange = this.adapter.hasClass(slider_constants_cssClasses.RANGE);
                var min = this.convertAttributeValueToNumber(this.adapter.getInputAttribute(slider_constants_attributes.INPUT_MIN, this.isRange ? Thumb.START : Thumb.END), slider_constants_attributes.INPUT_MIN);
                var max = this.convertAttributeValueToNumber(this.adapter.getInputAttribute(slider_constants_attributes.INPUT_MAX, Thumb.END), slider_constants_attributes.INPUT_MAX);
                var value = this.convertAttributeValueToNumber(this.adapter.getInputAttribute(slider_constants_attributes.INPUT_VALUE, Thumb.END), slider_constants_attributes.INPUT_VALUE);
                var valueStart = this.isRange ? this.convertAttributeValueToNumber(this.adapter.getInputAttribute(slider_constants_attributes.INPUT_VALUE, Thumb.START), slider_constants_attributes.INPUT_VALUE) : min;
                this.validateProperties({
                    min: min,
                    max: max,
                    value: value,
                    valueStart: valueStart
                });
                this.min = min;
                this.max = max;
                this.value = value;
                this.valueStart = valueStart;
                this.valueBeforeDownEvent = value;
                this.valueStartBeforeDownEvent = valueStart;
                var stepAttr = this.adapter.getInputAttribute(slider_constants_attributes.INPUT_STEP, Thumb.END);
                if (stepAttr) {
                    this.step = this.convertAttributeValueToNumber(stepAttr, slider_constants_attributes.INPUT_STEP);
                }
                if (this.step <= 0) {
                    throw new Error("MDCSliderFoundation: step must be a positive number. " + ("Current step: " + this.step));
                }
                this.mousedownOrTouchstartListener = this.handleMousedownOrTouchstart.bind(this);
                this.moveListener = this.handleMove.bind(this);
                this.pointerdownListener = this.handlePointerdown.bind(this);
                this.pointerupListener = this.handlePointerup.bind(this);
                this.thumbMouseenterListener = this.handleThumbMouseenter.bind(this);
                this.thumbMouseleaveListener = this.handleThumbMouseleave.bind(this);
                this.inputStartChangeListener = function() {
                    _this.handleInputChange(Thumb.START);
                };
                this.inputEndChangeListener = function() {
                    _this.handleInputChange(Thumb.END);
                };
                this.inputStartFocusListener = function() {
                    _this.handleInputFocus(Thumb.START);
                };
                this.inputEndFocusListener = function() {
                    _this.handleInputFocus(Thumb.END);
                };
                this.inputStartBlurListener = function() {
                    _this.handleInputBlur(Thumb.START);
                };
                this.inputEndBlurListener = function() {
                    _this.handleInputBlur(Thumb.END);
                };
                this.resizeListener = this.handleResize.bind(this);
                this.registerEventHandlers();
            };
            MDCSliderFoundation.prototype.destroy = function() {
                this.deregisterEventHandlers();
            };
            MDCSliderFoundation.prototype.getMin = function() {
                return this.min;
            };
            MDCSliderFoundation.prototype.getMax = function() {
                return this.max;
            };
            MDCSliderFoundation.prototype.getValue = function() {
                return this.value;
            };
            MDCSliderFoundation.prototype.setValue = function(value) {
                if (this.isRange && value < this.valueStart) {
                    throw new Error("end thumb value (" + value + ") must be >= start thumb " + ("value (" + this.valueStart + ")"));
                }
                this.updateValue(value, Thumb.END);
            };
            MDCSliderFoundation.prototype.getValueStart = function() {
                if (!this.isRange) {
                    throw new Error("`valueStart` is only applicable for range sliders.");
                }
                return this.valueStart;
            };
            MDCSliderFoundation.prototype.setValueStart = function(valueStart) {
                if (!this.isRange) {
                    throw new Error("`valueStart` is only applicable for range sliders.");
                }
                if (this.isRange && valueStart > this.value) {
                    throw new Error("start thumb value (" + valueStart + ") must be <= end thumb " + ("value (" + this.value + ")"));
                }
                this.updateValue(valueStart, Thumb.START);
            };
            MDCSliderFoundation.prototype.getStep = function() {
                return this.step;
            };
            MDCSliderFoundation.prototype.getDisabled = function() {
                return this.isDisabled;
            };
            MDCSliderFoundation.prototype.setDisabled = function(disabled) {
                this.isDisabled = disabled;
                if (disabled) {
                    this.adapter.addClass(slider_constants_cssClasses.DISABLED);
                    if (this.isRange) {
                        this.adapter.setInputAttribute(slider_constants_attributes.INPUT_DISABLED, "", Thumb.START);
                    }
                    this.adapter.setInputAttribute(slider_constants_attributes.INPUT_DISABLED, "", Thumb.END);
                } else {
                    this.adapter.removeClass(slider_constants_cssClasses.DISABLED);
                    if (this.isRange) {
                        this.adapter.removeInputAttribute(slider_constants_attributes.INPUT_DISABLED, Thumb.START);
                    }
                    this.adapter.removeInputAttribute(slider_constants_attributes.INPUT_DISABLED, Thumb.END);
                }
            };
            MDCSliderFoundation.prototype.getIsRange = function() {
                return this.isRange;
            };
            MDCSliderFoundation.prototype.layout = function(_a) {
                var skipUpdateUI = (_a === void 0 ? {} : _a).skipUpdateUI;
                this.rect = this.adapter.getBoundingClientRect();
                if (this.isRange) {
                    this.startThumbKnobWidth = this.adapter.getThumbKnobWidth(Thumb.START);
                    this.endThumbKnobWidth = this.adapter.getThumbKnobWidth(Thumb.END);
                }
                if (!skipUpdateUI) {
                    this.updateUI();
                }
            };
            MDCSliderFoundation.prototype.handleResize = function() {
                this.layout();
            };
            MDCSliderFoundation.prototype.handleDown = function(event) {
                if (this.isDisabled) return;
                this.valueStartBeforeDownEvent = this.valueStart;
                this.valueBeforeDownEvent = this.value;
                var clientX = event.clientX != null ? event.clientX : event.targetTouches[0].clientX;
                this.downEventClientX = clientX;
                var value = this.mapClientXOnSliderScale(clientX);
                this.thumb = this.getThumbFromDownEvent(clientX, value);
                if (this.thumb === null) return;
                this.handleDragStart(event, value, this.thumb);
                var newValueInCurrentRange = this.isRange && value >= this.valueStart && value <= this.value;
                if (newValueInCurrentRange) return;
                this.updateValue(value, this.thumb, {
                    emitInputEvent: true
                });
            };
            MDCSliderFoundation.prototype.handleMove = function(event) {
                if (this.isDisabled) return;
                event.preventDefault();
                var clientX = event.clientX != null ? event.clientX : event.targetTouches[0].clientX;
                var dragAlreadyStarted = this.thumb != null;
                this.thumb = this.getThumbFromMoveEvent(clientX);
                if (this.thumb === null) return;
                var value = this.mapClientXOnSliderScale(clientX);
                if (!dragAlreadyStarted) {
                    this.handleDragStart(event, value, this.thumb);
                    this.adapter.emitDragStartEvent(value, this.thumb);
                }
                this.updateValue(value, this.thumb, {
                    emitInputEvent: true
                });
            };
            MDCSliderFoundation.prototype.handleUp = function() {
                if (this.isDisabled || this.thumb === null) return;
                var oldValue = this.thumb === Thumb.START ? this.valueStartBeforeDownEvent : this.valueBeforeDownEvent;
                var newValue = this.thumb === Thumb.START ? this.valueStart : this.value;
                if (oldValue !== newValue) {
                    this.adapter.emitChangeEvent(newValue, this.thumb);
                }
                this.adapter.emitDragEndEvent(newValue, this.thumb);
                this.thumb = null;
            };
            MDCSliderFoundation.prototype.handleThumbMouseenter = function() {
                if (!this.isDiscrete || !this.isRange) return;
                this.adapter.addThumbClass(slider_constants_cssClasses.THUMB_WITH_INDICATOR, Thumb.START);
                this.adapter.addThumbClass(slider_constants_cssClasses.THUMB_WITH_INDICATOR, Thumb.END);
            };
            MDCSliderFoundation.prototype.handleThumbMouseleave = function() {
                if (!this.isDiscrete || !this.isRange) return;
                if (this.adapter.isInputFocused(Thumb.START) || this.adapter.isInputFocused(Thumb.END)) {
                    return;
                }
                this.adapter.removeThumbClass(slider_constants_cssClasses.THUMB_WITH_INDICATOR, Thumb.START);
                this.adapter.removeThumbClass(slider_constants_cssClasses.THUMB_WITH_INDICATOR, Thumb.END);
            };
            MDCSliderFoundation.prototype.handleMousedownOrTouchstart = function(event) {
                var _this = this;
                var moveEventType = event.type === "mousedown" ? "mousemove" : "touchmove";
                this.adapter.registerBodyEventHandler(moveEventType, this.moveListener);
                var upHandler = function() {
                    _this.handleUp();
                    _this.adapter.deregisterBodyEventHandler(moveEventType, _this.moveListener);
                    _this.adapter.deregisterEventHandler("mouseup", upHandler);
                    _this.adapter.deregisterEventHandler("touchend", upHandler);
                };
                this.adapter.registerBodyEventHandler("mouseup", upHandler);
                this.adapter.registerBodyEventHandler("touchend", upHandler);
                this.handleDown(event);
            };
            MDCSliderFoundation.prototype.handlePointerdown = function(event) {
                this.adapter.setPointerCapture(event.pointerId);
                this.adapter.registerEventHandler("pointermove", this.moveListener);
                this.handleDown(event);
            };
            MDCSliderFoundation.prototype.handleInputChange = function(thumb) {
                var value = Number(this.adapter.getInputValue(thumb));
                if (thumb === Thumb.START) {
                    this.setValueStart(value);
                } else {
                    this.setValue(value);
                }
            };
            MDCSliderFoundation.prototype.handleInputFocus = function(thumb) {
                if (!this.isDiscrete) return;
                this.adapter.addThumbClass(slider_constants_cssClasses.THUMB_WITH_INDICATOR, thumb);
                if (this.isRange) {
                    var otherThumb = thumb === Thumb.START ? Thumb.END : Thumb.START;
                    this.adapter.addThumbClass(slider_constants_cssClasses.THUMB_WITH_INDICATOR, otherThumb);
                }
            };
            MDCSliderFoundation.prototype.handleInputBlur = function(thumb) {
                if (!this.isDiscrete) return;
                this.adapter.removeThumbClass(slider_constants_cssClasses.THUMB_WITH_INDICATOR, thumb);
                if (this.isRange) {
                    var otherThumb = thumb === Thumb.START ? Thumb.END : Thumb.START;
                    this.adapter.removeThumbClass(slider_constants_cssClasses.THUMB_WITH_INDICATOR, otherThumb);
                }
            };
            MDCSliderFoundation.prototype.handleDragStart = function(event, value, thumb) {
                this.adapter.focusInput(thumb);
                event.preventDefault();
                this.adapter.emitDragStartEvent(value, thumb);
            };
            MDCSliderFoundation.prototype.getThumbFromDownEvent = function(clientX, value) {
                if (!this.isRange) return Thumb.END;
                var thumbStartRect = this.adapter.getThumbBoundingClientRect(Thumb.START);
                var thumbEndRect = this.adapter.getThumbBoundingClientRect(Thumb.END);
                var inThumbStartBounds = clientX >= thumbStartRect.left && clientX <= thumbStartRect.right;
                var inThumbEndBounds = clientX >= thumbEndRect.left && clientX <= thumbEndRect.right;
                if (inThumbStartBounds && inThumbEndBounds) {
                    return null;
                }
                if (inThumbStartBounds) {
                    return Thumb.START;
                }
                if (inThumbEndBounds) {
                    return Thumb.END;
                }
                if (value < this.valueStart) {
                    return Thumb.START;
                }
                if (value > this.value) {
                    return Thumb.END;
                }
                return null;
            };
            MDCSliderFoundation.prototype.getThumbFromMoveEvent = function(clientX) {
                if (this.thumb !== null) return this.thumb;
                if (this.downEventClientX === null) {
                    throw new Error("`downEventClientX` is null after move event.");
                }
                var moveDistanceUnderThreshold = Math.abs(this.downEventClientX - clientX) < slider_constants_numbers.THUMB_UPDATE_MIN_PX;
                if (moveDistanceUnderThreshold) return this.thumb;
                var draggedThumbToLeft = clientX < this.downEventClientX;
                if (draggedThumbToLeft) {
                    return this.adapter.isRTL() ? Thumb.END : Thumb.START;
                } else {
                    return this.adapter.isRTL() ? Thumb.START : Thumb.END;
                }
            };
            MDCSliderFoundation.prototype.updateUI = function(thumb) {
                this.updateThumbAndInputAttributes(thumb);
                this.updateThumbAndTrackUI(thumb);
                this.updateValueIndicatorUI(thumb);
                this.updateTickMarksUI();
            };
            MDCSliderFoundation.prototype.updateThumbAndInputAttributes = function(thumb) {
                if (!thumb) return;
                var value = this.isRange && thumb === Thumb.START ? this.valueStart : this.value;
                var valueStr = String(value);
                this.adapter.setInputAttribute(slider_constants_attributes.INPUT_VALUE, valueStr, thumb);
                if (this.isRange && thumb === Thumb.START) {
                    this.adapter.setInputAttribute(slider_constants_attributes.INPUT_MIN, valueStr, Thumb.END);
                } else if (this.isRange && thumb === Thumb.END) {
                    this.adapter.setInputAttribute(slider_constants_attributes.INPUT_MAX, valueStr, Thumb.START);
                }
                if (this.adapter.getInputValue(thumb) !== valueStr) {
                    this.adapter.setInputValue(valueStr, thumb);
                }
                var valueToAriaValueTextFn = this.adapter.getValueToAriaValueTextFn();
                if (valueToAriaValueTextFn) {
                    this.adapter.setInputAttribute(slider_constants_attributes.ARIA_VALUETEXT, valueToAriaValueTextFn(value), thumb);
                }
            };
            MDCSliderFoundation.prototype.updateValueIndicatorUI = function(thumb) {
                if (!this.isDiscrete) return;
                var value = this.isRange && thumb === Thumb.START ? this.valueStart : this.value;
                this.adapter.setValueIndicatorText(value, thumb === Thumb.START ? Thumb.START : Thumb.END);
                if (!thumb && this.isRange) {
                    this.adapter.setValueIndicatorText(this.valueStart, Thumb.START);
                }
            };
            MDCSliderFoundation.prototype.updateTickMarksUI = function() {
                if (!this.isDiscrete || !this.hasTickMarks) return;
                var numTickMarksInactiveStart = (this.valueStart - this.min) / this.step;
                var numTickMarksActive = (this.value - this.valueStart) / this.step + 1;
                var numTickMarksInactiveEnd = (this.max - this.value) / this.step;
                var tickMarksInactiveStart = Array.from({
                    length: numTickMarksInactiveStart
                }).fill(TickMark.INACTIVE);
                var tickMarksActive = Array.from({
                    length: numTickMarksActive
                }).fill(TickMark.ACTIVE);
                var tickMarksInactiveEnd = Array.from({
                    length: numTickMarksInactiveEnd
                }).fill(TickMark.INACTIVE);
                this.adapter.updateTickMarks(tickMarksInactiveStart.concat(tickMarksActive).concat(tickMarksInactiveEnd));
            };
            MDCSliderFoundation.prototype.mapClientXOnSliderScale = function(clientX) {
                var xPos = clientX - this.rect.left;
                var pctComplete = xPos / this.rect.width;
                if (this.adapter.isRTL()) {
                    pctComplete = 1 - pctComplete;
                }
                var value = this.min + pctComplete * (this.max - this.min);
                if (value === this.max || value === this.min) {
                    return value;
                }
                return this.quantize(value);
            };
            MDCSliderFoundation.prototype.updateValue = function(value, thumb, _a) {
                var _b = _a === void 0 ? {} : _a, emitInputEvent = _b.emitInputEvent, emitChangeEvent = _b.emitChangeEvent;
                value = this.clampValue(value, thumb);
                if (this.isRange && thumb === Thumb.START) {
                    if (this.valueStart === value) return;
                    this.valueStart = value;
                } else {
                    if (this.value === value) return;
                    this.value = value;
                }
                this.updateUI(thumb);
                if (emitInputEvent) {
                    this.adapter.emitInputEvent(thumb === Thumb.START ? this.valueStart : this.value, thumb);
                }
                if (emitChangeEvent) {
                    this.adapter.emitChangeEvent(thumb === Thumb.START ? this.valueStart : this.value, thumb);
                }
            };
            MDCSliderFoundation.prototype.quantize = function(value) {
                var numSteps = Math.round(value / this.step);
                return numSteps * this.step;
            };
            MDCSliderFoundation.prototype.clampValue = function(value, thumb) {
                value = Math.min(Math.max(value, this.min), this.max);
                var thumbStartMovedPastThumbEnd = this.isRange && thumb === Thumb.START && value > this.value;
                if (thumbStartMovedPastThumbEnd) {
                    return this.value;
                }
                var thumbEndMovedPastThumbStart = this.isRange && thumb === Thumb.END && value < this.valueStart;
                if (thumbEndMovedPastThumbStart) {
                    return this.valueStart;
                }
                return value;
            };
            MDCSliderFoundation.prototype.updateThumbAndTrackUI = function(thumb) {
                var _this = this;
                var _a = this, max = _a.max, min = _a.min;
                var pctComplete = (this.value - this.valueStart) / (max - min);
                var rangePx = pctComplete * this.rect.width;
                var isRtl = this.adapter.isRTL();
                var transformProp = HAS_WINDOW ? getCorrectPropertyName(window, "transform") : "transform";
                if (this.isRange) {
                    var thumbLeftPos_1 = this.adapter.isRTL() ? (max - this.value) / (max - min) * this.rect.width : (this.valueStart - min) / (max - min) * this.rect.width;
                    var thumbRightPos_1 = thumbLeftPos_1 + rangePx;
                    requestAnimationFrame((function() {
                        var trackAnimatesFromRight = !isRtl && thumb === Thumb.START || isRtl && thumb !== Thumb.START;
                        if (trackAnimatesFromRight) {
                            _this.adapter.setTrackActiveStyleProperty("transform-origin", "right");
                            _this.adapter.setTrackActiveStyleProperty("left", "unset");
                            _this.adapter.setTrackActiveStyleProperty("right", _this.rect.width - thumbRightPos_1 + "px");
                        } else {
                            _this.adapter.setTrackActiveStyleProperty("transform-origin", "left");
                            _this.adapter.setTrackActiveStyleProperty("right", "unset");
                            _this.adapter.setTrackActiveStyleProperty("left", thumbLeftPos_1 + "px");
                        }
                        _this.adapter.setTrackActiveStyleProperty(transformProp, "scaleX(" + pctComplete + ")");
                        var thumbStartPos = isRtl ? thumbRightPos_1 : thumbLeftPos_1;
                        var thumbEndPos = _this.adapter.isRTL() ? thumbLeftPos_1 : thumbRightPos_1;
                        if (thumb === Thumb.START || !thumb || !_this.initialStylesRemoved) {
                            _this.adapter.setThumbStyleProperty(transformProp, "translateX(" + thumbStartPos + "px)", Thumb.START);
                        }
                        if (thumb === Thumb.END || !thumb || !_this.initialStylesRemoved) {
                            _this.adapter.setThumbStyleProperty(transformProp, "translateX(" + thumbEndPos + "px)", Thumb.END);
                        }
                        _this.removeInitialStyles(isRtl);
                        _this.updateOverlappingThumbsUI(thumbStartPos, thumbEndPos, thumb);
                    }));
                } else {
                    requestAnimationFrame((function() {
                        var thumbStartPos = isRtl ? _this.rect.width - rangePx : rangePx;
                        _this.adapter.setThumbStyleProperty(transformProp, "translateX(" + thumbStartPos + "px)", Thumb.END);
                        _this.adapter.setTrackActiveStyleProperty(transformProp, "scaleX(" + pctComplete + ")");
                        _this.removeInitialStyles(isRtl);
                    }));
                }
            };
            MDCSliderFoundation.prototype.removeInitialStyles = function(isRtl) {
                if (this.initialStylesRemoved) return;
                var position = isRtl ? "right" : "left";
                this.adapter.removeThumbStyleProperty(position, Thumb.END);
                if (this.isRange) {
                    this.adapter.removeThumbStyleProperty(position, Thumb.START);
                }
                this.initialStylesRemoved = true;
                this.resetTrackAndThumbAnimation();
            };
            MDCSliderFoundation.prototype.resetTrackAndThumbAnimation = function() {
                var _this = this;
                if (!this.isDiscrete) return;
                var transitionProp = HAS_WINDOW ? getCorrectPropertyName(window, "transition") : "transition";
                var transitionDefault = "all 0s ease 0s";
                this.adapter.setThumbStyleProperty(transitionProp, transitionDefault, Thumb.END);
                if (this.isRange) {
                    this.adapter.setThumbStyleProperty(transitionProp, transitionDefault, Thumb.START);
                }
                this.adapter.setTrackActiveStyleProperty(transitionProp, transitionDefault);
                requestAnimationFrame((function() {
                    _this.adapter.removeThumbStyleProperty(transitionProp, Thumb.END);
                    _this.adapter.removeTrackActiveStyleProperty(transitionProp);
                    if (_this.isRange) {
                        _this.adapter.removeThumbStyleProperty(transitionProp, Thumb.START);
                    }
                }));
            };
            MDCSliderFoundation.prototype.updateOverlappingThumbsUI = function(thumbStartPos, thumbEndPos, thumb) {
                var thumbsOverlap = false;
                if (this.adapter.isRTL()) {
                    var startThumbLeftEdge = thumbStartPos - this.startThumbKnobWidth / 2;
                    var endThumbRightEdge = thumbEndPos + this.endThumbKnobWidth / 2;
                    thumbsOverlap = endThumbRightEdge >= startThumbLeftEdge;
                } else {
                    var startThumbRightEdge = thumbStartPos + this.startThumbKnobWidth / 2;
                    var endThumbLeftEdge = thumbEndPos - this.endThumbKnobWidth / 2;
                    thumbsOverlap = startThumbRightEdge >= endThumbLeftEdge;
                }
                if (thumbsOverlap) {
                    this.adapter.addThumbClass(slider_constants_cssClasses.THUMB_TOP, thumb || Thumb.END);
                    this.adapter.removeThumbClass(slider_constants_cssClasses.THUMB_TOP, thumb === Thumb.START ? Thumb.END : Thumb.START);
                } else {
                    this.adapter.removeThumbClass(slider_constants_cssClasses.THUMB_TOP, Thumb.START);
                    this.adapter.removeThumbClass(slider_constants_cssClasses.THUMB_TOP, Thumb.END);
                }
            };
            MDCSliderFoundation.prototype.convertAttributeValueToNumber = function(attributeValue, attributeName) {
                if (attributeValue === null) {
                    throw new Error("MDCSliderFoundation: `" + attributeName + "` must be non-null.");
                }
                var value = Number(attributeValue);
                if (isNaN(value)) {
                    throw new Error("MDCSliderFoundation: `" + attributeName + "` value is " + ("`" + attributeValue + "`, but must be a number."));
                }
                return value;
            };
            MDCSliderFoundation.prototype.validateProperties = function(_a) {
                var min = _a.min, max = _a.max, value = _a.value, valueStart = _a.valueStart;
                if (min >= max) {
                    throw new Error("MDCSliderFoundation: min must be strictly less than max. " + ("Current: [min: " + min + ", max: " + max + "]"));
                }
                if (this.isRange) {
                    if (value < min || value > max || valueStart < min || valueStart > max) {
                        throw new Error("MDCSliderFoundation: values must be in [min, max] range. " + ("Current values: [start value: " + valueStart + ", end value: " + value + "]"));
                    }
                    if (valueStart > value) {
                        throw new Error("MDCSliderFoundation: start value must be <= end value. " + ("Current values: [start value: " + valueStart + ", end value: " + value + "]"));
                    }
                } else {
                    if (value < min || value > max) {
                        throw new Error("MDCSliderFoundation: value must be in [min, max] range. " + ("Current value: " + value));
                    }
                }
            };
            MDCSliderFoundation.prototype.registerEventHandlers = function() {
                this.adapter.registerWindowEventHandler("resize", this.resizeListener);
                if (MDCSliderFoundation.SUPPORTS_POINTER_EVENTS) {
                    this.adapter.registerEventHandler("pointerdown", this.pointerdownListener);
                    this.adapter.registerEventHandler("pointerup", this.pointerupListener);
                } else {
                    this.adapter.registerEventHandler("mousedown", this.mousedownOrTouchstartListener);
                    this.adapter.registerEventHandler("touchstart", this.mousedownOrTouchstartListener);
                }
                if (this.isRange) {
                    this.adapter.registerThumbEventHandler(Thumb.START, "mouseenter", this.thumbMouseenterListener);
                    this.adapter.registerThumbEventHandler(Thumb.START, "mouseleave", this.thumbMouseleaveListener);
                    this.adapter.registerInputEventHandler(Thumb.START, "change", this.inputStartChangeListener);
                    this.adapter.registerInputEventHandler(Thumb.START, "focus", this.inputStartFocusListener);
                    this.adapter.registerInputEventHandler(Thumb.START, "blur", this.inputStartBlurListener);
                }
                this.adapter.registerThumbEventHandler(Thumb.END, "mouseenter", this.thumbMouseenterListener);
                this.adapter.registerThumbEventHandler(Thumb.END, "mouseleave", this.thumbMouseleaveListener);
                this.adapter.registerInputEventHandler(Thumb.END, "change", this.inputEndChangeListener);
                this.adapter.registerInputEventHandler(Thumb.END, "focus", this.inputEndFocusListener);
                this.adapter.registerInputEventHandler(Thumb.END, "blur", this.inputEndBlurListener);
            };
            MDCSliderFoundation.prototype.deregisterEventHandlers = function() {
                this.adapter.deregisterWindowEventHandler("resize", this.resizeListener);
                if (MDCSliderFoundation.SUPPORTS_POINTER_EVENTS) {
                    this.adapter.deregisterEventHandler("pointerdown", this.pointerdownListener);
                    this.adapter.deregisterEventHandler("pointerup", this.pointerupListener);
                } else {
                    this.adapter.deregisterEventHandler("mousedown", this.mousedownOrTouchstartListener);
                    this.adapter.deregisterEventHandler("touchstart", this.mousedownOrTouchstartListener);
                }
                if (this.isRange) {
                    this.adapter.deregisterThumbEventHandler(Thumb.START, "mouseenter", this.thumbMouseenterListener);
                    this.adapter.deregisterThumbEventHandler(Thumb.START, "mouseleave", this.thumbMouseleaveListener);
                    this.adapter.deregisterInputEventHandler(Thumb.START, "change", this.inputStartChangeListener);
                    this.adapter.deregisterInputEventHandler(Thumb.START, "focus", this.inputStartFocusListener);
                    this.adapter.deregisterInputEventHandler(Thumb.START, "blur", this.inputStartBlurListener);
                }
                this.adapter.deregisterThumbEventHandler(Thumb.END, "mouseenter", this.thumbMouseenterListener);
                this.adapter.deregisterThumbEventHandler(Thumb.END, "mouseleave", this.thumbMouseleaveListener);
                this.adapter.deregisterInputEventHandler(Thumb.END, "change", this.inputEndChangeListener);
                this.adapter.deregisterInputEventHandler(Thumb.END, "focus", this.inputEndFocusListener);
                this.adapter.deregisterInputEventHandler(Thumb.END, "blur", this.inputEndBlurListener);
            };
            MDCSliderFoundation.prototype.handlePointerup = function() {
                this.handleUp();
                this.adapter.deregisterEventHandler("pointermove", this.moveListener);
            };
            MDCSliderFoundation.SUPPORTS_POINTER_EVENTS = HAS_WINDOW && Boolean(window.PointerEvent);
            return MDCSliderFoundation;
        }(MDCFoundation);
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCSlider = function(_super) {
            __extends(MDCSlider, _super);
            function MDCSlider() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.skipInitialUIUpdate = false;
                _this.valueToAriaValueTextFn = null;
                return _this;
            }
            MDCSlider.attachTo = function(root, options) {
                if (options === void 0) {
                    options = {};
                }
                return new MDCSlider(root, undefined, options);
            };
            MDCSlider.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    hasClass: function(className) {
                        return _this.root.classList.contains(className);
                    },
                    addClass: function(className) {
                        _this.root.classList.add(className);
                    },
                    removeClass: function(className) {
                        _this.root.classList.remove(className);
                    },
                    addThumbClass: function(className, thumb) {
                        _this.getThumbEl(thumb).classList.add(className);
                    },
                    removeThumbClass: function(className, thumb) {
                        _this.getThumbEl(thumb).classList.remove(className);
                    },
                    getAttribute: function(attribute) {
                        return _this.root.getAttribute(attribute);
                    },
                    getInputValue: function(thumb) {
                        return _this.getInput(thumb).value;
                    },
                    setInputValue: function(value, thumb) {
                        _this.getInput(thumb).value = value;
                    },
                    getInputAttribute: function(attribute, thumb) {
                        return _this.getInput(thumb).getAttribute(attribute);
                    },
                    setInputAttribute: function(attribute, value, thumb) {
                        _this.getInput(thumb).setAttribute(attribute, value);
                    },
                    removeInputAttribute: function(attribute, thumb) {
                        _this.getInput(thumb).removeAttribute(attribute);
                    },
                    focusInput: function(thumb) {
                        _this.getInput(thumb).focus();
                    },
                    isInputFocused: function(thumb) {
                        return _this.getInput(thumb) === document.activeElement;
                    },
                    getThumbKnobWidth: function(thumb) {
                        return _this.getThumbEl(thumb).querySelector("." + slider_constants_cssClasses.THUMB_KNOB).getBoundingClientRect().width;
                    },
                    getThumbBoundingClientRect: function(thumb) {
                        return _this.getThumbEl(thumb).getBoundingClientRect();
                    },
                    getBoundingClientRect: function() {
                        return _this.root.getBoundingClientRect();
                    },
                    isRTL: function() {
                        return getComputedStyle(_this.root).direction === "rtl";
                    },
                    setThumbStyleProperty: function(propertyName, value, thumb) {
                        _this.getThumbEl(thumb).style.setProperty(propertyName, value);
                    },
                    removeThumbStyleProperty: function(propertyName, thumb) {
                        _this.getThumbEl(thumb).style.removeProperty(propertyName);
                    },
                    setTrackActiveStyleProperty: function(propertyName, value) {
                        _this.trackActive.style.setProperty(propertyName, value);
                    },
                    removeTrackActiveStyleProperty: function(propertyName) {
                        _this.trackActive.style.removeProperty(propertyName);
                    },
                    setValueIndicatorText: function(value, thumb) {
                        var valueIndicatorEl = _this.getThumbEl(thumb).querySelector("." + slider_constants_cssClasses.VALUE_INDICATOR_TEXT);
                        valueIndicatorEl.textContent = String(value);
                    },
                    getValueToAriaValueTextFn: function() {
                        return _this.valueToAriaValueTextFn;
                    },
                    updateTickMarks: function(tickMarks) {
                        var tickMarksContainer = _this.root.querySelector("." + slider_constants_cssClasses.TICK_MARKS_CONTAINER);
                        if (!tickMarksContainer) {
                            tickMarksContainer = document.createElement("div");
                            tickMarksContainer.classList.add(slider_constants_cssClasses.TICK_MARKS_CONTAINER);
                            var track = _this.root.querySelector("." + slider_constants_cssClasses.TRACK);
                            track.appendChild(tickMarksContainer);
                        }
                        if (tickMarks.length !== tickMarksContainer.children.length) {
                            tickMarksContainer.innerHTML = "";
                            _this.addTickMarks(tickMarksContainer, tickMarks);
                        } else {
                            _this.updateTickMarks(tickMarksContainer, tickMarks);
                        }
                    },
                    setPointerCapture: function(pointerId) {
                        _this.root.setPointerCapture(pointerId);
                    },
                    emitChangeEvent: function(value, thumb) {
                        _this.emit(slider_constants_events.CHANGE, {
                            value: value,
                            thumb: thumb
                        });
                    },
                    emitInputEvent: function(value, thumb) {
                        _this.emit(slider_constants_events.INPUT, {
                            value: value,
                            thumb: thumb
                        });
                    },
                    emitDragStartEvent: function(_, thumb) {
                        _this.getRipple(thumb).activate();
                    },
                    emitDragEndEvent: function(_, thumb) {
                        _this.getRipple(thumb).deactivate();
                    },
                    registerEventHandler: function(evtType, handler) {
                        _this.listen(evtType, handler);
                    },
                    deregisterEventHandler: function(evtType, handler) {
                        _this.unlisten(evtType, handler);
                    },
                    registerThumbEventHandler: function(thumb, evtType, handler) {
                        _this.getThumbEl(thumb).addEventListener(evtType, handler);
                    },
                    deregisterThumbEventHandler: function(thumb, evtType, handler) {
                        _this.getThumbEl(thumb).removeEventListener(evtType, handler);
                    },
                    registerInputEventHandler: function(thumb, evtType, handler) {
                        _this.getInput(thumb).addEventListener(evtType, handler);
                    },
                    deregisterInputEventHandler: function(thumb, evtType, handler) {
                        _this.getInput(thumb).removeEventListener(evtType, handler);
                    },
                    registerBodyEventHandler: function(evtType, handler) {
                        document.body.addEventListener(evtType, handler);
                    },
                    deregisterBodyEventHandler: function(evtType, handler) {
                        document.body.removeEventListener(evtType, handler);
                    },
                    registerWindowEventHandler: function(evtType, handler) {
                        window.addEventListener(evtType, handler);
                    },
                    deregisterWindowEventHandler: function(evtType, handler) {
                        window.removeEventListener(evtType, handler);
                    }
                };
                return new MDCSliderFoundation(adapter);
            };
            MDCSlider.prototype.initialize = function(_a) {
                var skipInitialUIUpdate = (_a === void 0 ? {} : _a).skipInitialUIUpdate;
                this.inputs = [].slice.call(this.root.querySelectorAll("." + slider_constants_cssClasses.INPUT));
                this.thumbs = [].slice.call(this.root.querySelectorAll("." + slider_constants_cssClasses.THUMB));
                this.trackActive = this.root.querySelector("." + slider_constants_cssClasses.TRACK_ACTIVE);
                this.ripples = this.createRipples();
                if (skipInitialUIUpdate) {
                    this.skipInitialUIUpdate = true;
                }
            };
            MDCSlider.prototype.initialSyncWithDOM = function() {
                this.foundation.layout({
                    skipUpdateUI: this.skipInitialUIUpdate
                });
            };
            MDCSlider.prototype.layout = function() {
                this.foundation.layout();
            };
            MDCSlider.prototype.getValueStart = function() {
                return this.foundation.getValueStart();
            };
            MDCSlider.prototype.setValueStart = function(valueStart) {
                this.foundation.setValueStart(valueStart);
            };
            MDCSlider.prototype.getValue = function() {
                return this.foundation.getValue();
            };
            MDCSlider.prototype.setValue = function(value) {
                this.foundation.setValue(value);
            };
            MDCSlider.prototype.getDisabled = function() {
                return this.foundation.getDisabled();
            };
            MDCSlider.prototype.setDisabled = function(disabled) {
                this.foundation.setDisabled(disabled);
            };
            MDCSlider.prototype.setValueToAriaValueTextFn = function(mapFn) {
                this.valueToAriaValueTextFn = mapFn;
            };
            MDCSlider.prototype.getThumbEl = function(thumb) {
                return thumb === Thumb.END ? this.thumbs[this.thumbs.length - 1] : this.thumbs[0];
            };
            MDCSlider.prototype.getInput = function(thumb) {
                return thumb === Thumb.END ? this.inputs[this.inputs.length - 1] : this.inputs[0];
            };
            MDCSlider.prototype.getRipple = function(thumb) {
                return thumb === Thumb.END ? this.ripples[this.ripples.length - 1] : this.ripples[0];
            };
            MDCSlider.prototype.addTickMarks = function(tickMarkContainer, tickMarks) {
                var fragment = document.createDocumentFragment();
                for (var i = 0; i < tickMarks.length; i++) {
                    var div = document.createElement("div");
                    var tickMarkClass = tickMarks[i] === TickMark.ACTIVE ? slider_constants_cssClasses.TICK_MARK_ACTIVE : slider_constants_cssClasses.TICK_MARK_INACTIVE;
                    div.classList.add(tickMarkClass);
                    fragment.appendChild(div);
                }
                tickMarkContainer.appendChild(fragment);
            };
            MDCSlider.prototype.updateTickMarks = function(tickMarkContainer, tickMarks) {
                var tickMarkEls = Array.from(tickMarkContainer.children);
                for (var i = 0; i < tickMarkEls.length; i++) {
                    if (tickMarks[i] === TickMark.ACTIVE) {
                        tickMarkEls[i].classList.add(slider_constants_cssClasses.TICK_MARK_ACTIVE);
                        tickMarkEls[i].classList.remove(slider_constants_cssClasses.TICK_MARK_INACTIVE);
                    } else {
                        tickMarkEls[i].classList.add(slider_constants_cssClasses.TICK_MARK_INACTIVE);
                        tickMarkEls[i].classList.remove(slider_constants_cssClasses.TICK_MARK_ACTIVE);
                    }
                }
            };
            MDCSlider.prototype.createRipples = function() {
                var ripples = [];
                var rippleSurfaces = [].slice.call(this.root.querySelectorAll("." + slider_constants_cssClasses.THUMB));
                var _loop_1 = function(i) {
                    var rippleSurface = rippleSurfaces[i];
                    var input = this_1.inputs[i];
                    var adapter = __assign(__assign({}, MDCRipple.createAdapter(this_1)), {
                        addClass: function(className) {
                            rippleSurface.classList.add(className);
                        },
                        computeBoundingRect: function() {
                            return rippleSurface.getBoundingClientRect();
                        },
                        deregisterInteractionHandler: function(evtType, handler) {
                            input.removeEventListener(evtType, handler);
                        },
                        isSurfaceActive: function() {
                            return matches(input, ":active");
                        },
                        isUnbounded: function() {
                            return true;
                        },
                        registerInteractionHandler: function(evtType, handler) {
                            input.addEventListener(evtType, handler);
                        },
                        removeClass: function(className) {
                            rippleSurface.classList.remove(className);
                        },
                        updateCssVariable: function(varName, value) {
                            rippleSurface.style.setProperty(varName, value);
                        }
                    });
                    var ripple = new MDCRipple(rippleSurface, new MDCRippleFoundation(adapter));
                    ripple.unbounded = true;
                    ripples.push(ripple);
                };
                var this_1 = this;
                for (var i = 0; i < rippleSurfaces.length; i++) {
                    _loop_1(i);
                }
                return ripples;
            };
            return MDCSlider;
        }(MDCComponent);
        var lodash = __webpack_require__(486);
        function MBSlider_init(elem, dotNetObject, eventType, delay) {
            elem._slider = MDCSlider.attachTo(elem);
            elem._eventType = eventType;
            var debounceNotify = lodash.debounce((function() {
                dotNetObject.invokeMethodAsync("NotifyChanged", elem._slider.getValue());
            }), delay);
            var throttleNotify = lodash.throttle((function() {
                dotNetObject.invokeMethodAsync("NotifyChanged", elem._slider.getValue());
            }), delay);
            var thumbUpCallback = function thumbUpCallback() {
                dotNetObject.invokeMethodAsync("NotifyChanged", elem._slider.getValue());
            };
            var debounceCallback = function debounceCallback() {
                debounceNotify();
            };
            var throttleCallback = function throttleCallback() {
                throttleNotify();
            };
            if (eventType == 0) {
                elem._slider.listen("MDCSlider:change", thumbUpCallback);
            } else if (eventType == 1) {
                elem._slider.listen("MDCSlider:input", debounceCallback);
            } else {
                elem._slider.listen("MDCSlider:input", throttleCallback);
            }
        }
        function MBSlider_setValue(elem, value) {
            elem._slider.setValue(value);
        }
        function MBSlider_setDisabled(elem, value) {
            elem._slider.setDisabled(value);
        }
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var snackbar_constants_cssClasses = {
            CLOSING: "mdc-snackbar--closing",
            OPEN: "mdc-snackbar--open",
            OPENING: "mdc-snackbar--opening"
        };
        var snackbar_constants_strings = {
            ACTION_SELECTOR: ".mdc-snackbar__action",
            ARIA_LIVE_LABEL_TEXT_ATTR: "data-mdc-snackbar-label-text",
            CLOSED_EVENT: "MDCSnackbar:closed",
            CLOSING_EVENT: "MDCSnackbar:closing",
            DISMISS_SELECTOR: ".mdc-snackbar__dismiss",
            LABEL_SELECTOR: ".mdc-snackbar__label",
            OPENED_EVENT: "MDCSnackbar:opened",
            OPENING_EVENT: "MDCSnackbar:opening",
            REASON_ACTION: "action",
            REASON_DISMISS: "dismiss",
            SURFACE_SELECTOR: ".mdc-snackbar__surface"
        };
        var snackbar_constants_numbers = {
            DEFAULT_AUTO_DISMISS_TIMEOUT_MS: 5e3,
            INDETERMINATE: -1,
            MAX_AUTO_DISMISS_TIMEOUT_MS: 1e4,
            MIN_AUTO_DISMISS_TIMEOUT_MS: 4e3,
            SNACKBAR_ANIMATION_CLOSE_TIME_MS: 75,
            SNACKBAR_ANIMATION_OPEN_TIME_MS: 150,
            ARIA_LIVE_DELAY_MS: 1e3
        };
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var OPENING = snackbar_constants_cssClasses.OPENING, OPEN = snackbar_constants_cssClasses.OPEN, CLOSING = snackbar_constants_cssClasses.CLOSING;
        var REASON_ACTION = snackbar_constants_strings.REASON_ACTION, REASON_DISMISS = snackbar_constants_strings.REASON_DISMISS;
        var MDCSnackbarFoundation = function(_super) {
            __extends(MDCSnackbarFoundation, _super);
            function MDCSnackbarFoundation(adapter) {
                var _this = _super.call(this, __assign(__assign({}, MDCSnackbarFoundation.defaultAdapter), adapter)) || this;
                _this.isOpen_ = false;
                _this.animationFrame_ = 0;
                _this.animationTimer_ = 0;
                _this.autoDismissTimer_ = 0;
                _this.autoDismissTimeoutMs_ = snackbar_constants_numbers.DEFAULT_AUTO_DISMISS_TIMEOUT_MS;
                _this.closeOnEscape_ = true;
                return _this;
            }
            Object.defineProperty(MDCSnackbarFoundation, "cssClasses", {
                get: function() {
                    return snackbar_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSnackbarFoundation, "strings", {
                get: function() {
                    return snackbar_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSnackbarFoundation, "numbers", {
                get: function() {
                    return snackbar_constants_numbers;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSnackbarFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClass: function() {
                            return undefined;
                        },
                        announce: function() {
                            return undefined;
                        },
                        notifyClosed: function() {
                            return undefined;
                        },
                        notifyClosing: function() {
                            return undefined;
                        },
                        notifyOpened: function() {
                            return undefined;
                        },
                        notifyOpening: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCSnackbarFoundation.prototype.destroy = function() {
                this.clearAutoDismissTimer_();
                cancelAnimationFrame(this.animationFrame_);
                this.animationFrame_ = 0;
                clearTimeout(this.animationTimer_);
                this.animationTimer_ = 0;
                this.adapter.removeClass(OPENING);
                this.adapter.removeClass(OPEN);
                this.adapter.removeClass(CLOSING);
            };
            MDCSnackbarFoundation.prototype.open = function() {
                var _this = this;
                this.clearAutoDismissTimer_();
                this.isOpen_ = true;
                this.adapter.notifyOpening();
                this.adapter.removeClass(CLOSING);
                this.adapter.addClass(OPENING);
                this.adapter.announce();
                this.runNextAnimationFrame_((function() {
                    _this.adapter.addClass(OPEN);
                    _this.animationTimer_ = setTimeout((function() {
                        var timeoutMs = _this.getTimeoutMs();
                        _this.handleAnimationTimerEnd_();
                        _this.adapter.notifyOpened();
                        if (timeoutMs !== snackbar_constants_numbers.INDETERMINATE) {
                            _this.autoDismissTimer_ = setTimeout((function() {
                                _this.close(REASON_DISMISS);
                            }), timeoutMs);
                        }
                    }), snackbar_constants_numbers.SNACKBAR_ANIMATION_OPEN_TIME_MS);
                }));
            };
            MDCSnackbarFoundation.prototype.close = function(reason) {
                var _this = this;
                if (reason === void 0) {
                    reason = "";
                }
                if (!this.isOpen_) {
                    return;
                }
                cancelAnimationFrame(this.animationFrame_);
                this.animationFrame_ = 0;
                this.clearAutoDismissTimer_();
                this.isOpen_ = false;
                this.adapter.notifyClosing(reason);
                this.adapter.addClass(snackbar_constants_cssClasses.CLOSING);
                this.adapter.removeClass(snackbar_constants_cssClasses.OPEN);
                this.adapter.removeClass(snackbar_constants_cssClasses.OPENING);
                clearTimeout(this.animationTimer_);
                this.animationTimer_ = setTimeout((function() {
                    _this.handleAnimationTimerEnd_();
                    _this.adapter.notifyClosed(reason);
                }), snackbar_constants_numbers.SNACKBAR_ANIMATION_CLOSE_TIME_MS);
            };
            MDCSnackbarFoundation.prototype.isOpen = function() {
                return this.isOpen_;
            };
            MDCSnackbarFoundation.prototype.getTimeoutMs = function() {
                return this.autoDismissTimeoutMs_;
            };
            MDCSnackbarFoundation.prototype.setTimeoutMs = function(timeoutMs) {
                var minValue = snackbar_constants_numbers.MIN_AUTO_DISMISS_TIMEOUT_MS;
                var maxValue = snackbar_constants_numbers.MAX_AUTO_DISMISS_TIMEOUT_MS;
                var indeterminateValue = snackbar_constants_numbers.INDETERMINATE;
                if (timeoutMs === snackbar_constants_numbers.INDETERMINATE || timeoutMs <= maxValue && timeoutMs >= minValue) {
                    this.autoDismissTimeoutMs_ = timeoutMs;
                } else {
                    throw new Error("\n        timeoutMs must be an integer in the range " + minValue + "–" + maxValue + "\n        (or " + indeterminateValue + " to disable), but got '" + timeoutMs + "'");
                }
            };
            MDCSnackbarFoundation.prototype.getCloseOnEscape = function() {
                return this.closeOnEscape_;
            };
            MDCSnackbarFoundation.prototype.setCloseOnEscape = function(closeOnEscape) {
                this.closeOnEscape_ = closeOnEscape;
            };
            MDCSnackbarFoundation.prototype.handleKeyDown = function(evt) {
                var isEscapeKey = evt.key === "Escape" || evt.keyCode === 27;
                if (isEscapeKey && this.getCloseOnEscape()) {
                    this.close(REASON_DISMISS);
                }
            };
            MDCSnackbarFoundation.prototype.handleActionButtonClick = function(_evt) {
                this.close(REASON_ACTION);
            };
            MDCSnackbarFoundation.prototype.handleActionIconClick = function(_evt) {
                this.close(REASON_DISMISS);
            };
            MDCSnackbarFoundation.prototype.clearAutoDismissTimer_ = function() {
                clearTimeout(this.autoDismissTimer_);
                this.autoDismissTimer_ = 0;
            };
            MDCSnackbarFoundation.prototype.handleAnimationTimerEnd_ = function() {
                this.animationTimer_ = 0;
                this.adapter.removeClass(snackbar_constants_cssClasses.OPENING);
                this.adapter.removeClass(snackbar_constants_cssClasses.CLOSING);
            };
            MDCSnackbarFoundation.prototype.runNextAnimationFrame_ = function(callback) {
                var _this = this;
                cancelAnimationFrame(this.animationFrame_);
                this.animationFrame_ = requestAnimationFrame((function() {
                    _this.animationFrame_ = 0;
                    clearTimeout(_this.animationTimer_);
                    _this.animationTimer_ = setTimeout(callback, 0);
                }));
            };
            return MDCSnackbarFoundation;
        }(MDCFoundation);
        const snackbar_foundation = null && MDCSnackbarFoundation;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var ARIA_LIVE_DELAY_MS = snackbar_constants_numbers.ARIA_LIVE_DELAY_MS;
        var ARIA_LIVE_LABEL_TEXT_ATTR = snackbar_constants_strings.ARIA_LIVE_LABEL_TEXT_ATTR;
        function util_announce(ariaEl, labelEl) {
            if (labelEl === void 0) {
                labelEl = ariaEl;
            }
            var priority = ariaEl.getAttribute("aria-live");
            var labelText = labelEl.textContent.trim();
            if (!labelText || !priority) {
                return;
            }
            ariaEl.setAttribute("aria-live", "off");
            labelEl.textContent = "";
            labelEl.innerHTML = '<span style="display: inline-block; width: 0; height: 1px;">&nbsp;</span>';
            labelEl.setAttribute(ARIA_LIVE_LABEL_TEXT_ATTR, labelText);
            setTimeout((function() {
                ariaEl.setAttribute("aria-live", priority);
                labelEl.removeAttribute(ARIA_LIVE_LABEL_TEXT_ATTR);
                labelEl.textContent = labelText;
            }), ARIA_LIVE_DELAY_MS);
        }
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var SURFACE_SELECTOR = snackbar_constants_strings.SURFACE_SELECTOR, LABEL_SELECTOR = snackbar_constants_strings.LABEL_SELECTOR, ACTION_SELECTOR = snackbar_constants_strings.ACTION_SELECTOR, DISMISS_SELECTOR = snackbar_constants_strings.DISMISS_SELECTOR, OPENING_EVENT = snackbar_constants_strings.OPENING_EVENT, OPENED_EVENT = snackbar_constants_strings.OPENED_EVENT, CLOSING_EVENT = snackbar_constants_strings.CLOSING_EVENT, CLOSED_EVENT = snackbar_constants_strings.CLOSED_EVENT;
        var MDCSnackbar = function(_super) {
            __extends(MDCSnackbar, _super);
            function MDCSnackbar() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCSnackbar.attachTo = function(root) {
                return new MDCSnackbar(root);
            };
            MDCSnackbar.prototype.initialize = function(announcerFactory) {
                if (announcerFactory === void 0) {
                    announcerFactory = function() {
                        return util_announce;
                    };
                }
                this.announce_ = announcerFactory();
            };
            MDCSnackbar.prototype.initialSyncWithDOM = function() {
                var _this = this;
                this.surfaceEl_ = this.root.querySelector(SURFACE_SELECTOR);
                this.labelEl_ = this.root.querySelector(LABEL_SELECTOR);
                this.actionEl_ = this.root.querySelector(ACTION_SELECTOR);
                this.handleKeyDown_ = function(evt) {
                    return _this.foundation.handleKeyDown(evt);
                };
                this.handleSurfaceClick_ = function(evt) {
                    var target = evt.target;
                    if (_this.isActionButton_(target)) {
                        _this.foundation.handleActionButtonClick(evt);
                    } else if (_this.isActionIcon_(target)) {
                        _this.foundation.handleActionIconClick(evt);
                    }
                };
                this.registerKeyDownHandler_(this.handleKeyDown_);
                this.registerSurfaceClickHandler_(this.handleSurfaceClick_);
            };
            MDCSnackbar.prototype.destroy = function() {
                _super.prototype.destroy.call(this);
                this.deregisterKeyDownHandler_(this.handleKeyDown_);
                this.deregisterSurfaceClickHandler_(this.handleSurfaceClick_);
            };
            MDCSnackbar.prototype.open = function() {
                this.foundation.open();
            };
            MDCSnackbar.prototype.close = function(reason) {
                if (reason === void 0) {
                    reason = "";
                }
                this.foundation.close(reason);
            };
            MDCSnackbar.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    addClass: function(className) {
                        return _this.root.classList.add(className);
                    },
                    announce: function() {
                        return _this.announce_(_this.labelEl_);
                    },
                    notifyClosed: function(reason) {
                        return _this.emit(CLOSED_EVENT, reason ? {
                            reason: reason
                        } : {});
                    },
                    notifyClosing: function(reason) {
                        return _this.emit(CLOSING_EVENT, reason ? {
                            reason: reason
                        } : {});
                    },
                    notifyOpened: function() {
                        return _this.emit(OPENED_EVENT, {});
                    },
                    notifyOpening: function() {
                        return _this.emit(OPENING_EVENT, {});
                    },
                    removeClass: function(className) {
                        return _this.root.classList.remove(className);
                    }
                };
                return new MDCSnackbarFoundation(adapter);
            };
            Object.defineProperty(MDCSnackbar.prototype, "timeoutMs", {
                get: function() {
                    return this.foundation.getTimeoutMs();
                },
                set: function(timeoutMs) {
                    this.foundation.setTimeoutMs(timeoutMs);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSnackbar.prototype, "closeOnEscape", {
                get: function() {
                    return this.foundation.getCloseOnEscape();
                },
                set: function(closeOnEscape) {
                    this.foundation.setCloseOnEscape(closeOnEscape);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSnackbar.prototype, "isOpen", {
                get: function() {
                    return this.foundation.isOpen();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSnackbar.prototype, "labelText", {
                get: function() {
                    return this.labelEl_.textContent;
                },
                set: function(labelText) {
                    this.labelEl_.textContent = labelText;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSnackbar.prototype, "actionButtonText", {
                get: function() {
                    return this.actionEl_.textContent;
                },
                set: function(actionButtonText) {
                    this.actionEl_.textContent = actionButtonText;
                },
                enumerable: true,
                configurable: true
            });
            MDCSnackbar.prototype.registerKeyDownHandler_ = function(handler) {
                this.listen("keydown", handler);
            };
            MDCSnackbar.prototype.deregisterKeyDownHandler_ = function(handler) {
                this.unlisten("keydown", handler);
            };
            MDCSnackbar.prototype.registerSurfaceClickHandler_ = function(handler) {
                this.surfaceEl_.addEventListener("click", handler);
            };
            MDCSnackbar.prototype.deregisterSurfaceClickHandler_ = function(handler) {
                this.surfaceEl_.removeEventListener("click", handler);
            };
            MDCSnackbar.prototype.isActionButton_ = function(target) {
                return Boolean(closest(target, ACTION_SELECTOR));
            };
            MDCSnackbar.prototype.isActionIcon_ = function(target) {
                return Boolean(closest(target, DISMISS_SELECTOR));
            };
            return MDCSnackbar;
        }(MDCComponent);
        function MBSnackbar_init(elem, dotnetReference, timeoutMs) {
            elem._snackbar = new MDCSnackbar(elem);
            elem._snackbar.listen("MDCSnackbar:closed", (function(r) {
                dotnetReference.invokeMethodAsync("Closed", r);
            }));
            elem._snackbar.timeoutMs = timeoutMs;
            elem._snackbar.open();
        }
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var switch_constants_cssClasses = {
            CHECKED: "mdc-switch--checked",
            DISABLED: "mdc-switch--disabled"
        };
        var switch_constants_strings = {
            ARIA_CHECKED_ATTR: "aria-checked",
            NATIVE_CONTROL_SELECTOR: ".mdc-switch__native-control",
            RIPPLE_SURFACE_SELECTOR: ".mdc-switch__thumb-underlay"
        };
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCSwitchFoundation = function(_super) {
            __extends(MDCSwitchFoundation, _super);
            function MDCSwitchFoundation(adapter) {
                return _super.call(this, __assign(__assign({}, MDCSwitchFoundation.defaultAdapter), adapter)) || this;
            }
            Object.defineProperty(MDCSwitchFoundation, "strings", {
                get: function() {
                    return switch_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSwitchFoundation, "cssClasses", {
                get: function() {
                    return switch_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSwitchFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClass: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        setNativeControlChecked: function() {
                            return undefined;
                        },
                        setNativeControlDisabled: function() {
                            return undefined;
                        },
                        setNativeControlAttr: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCSwitchFoundation.prototype.setChecked = function(checked) {
                this.adapter.setNativeControlChecked(checked);
                this.updateAriaChecked_(checked);
                this.updateCheckedStyling_(checked);
            };
            MDCSwitchFoundation.prototype.setDisabled = function(disabled) {
                this.adapter.setNativeControlDisabled(disabled);
                if (disabled) {
                    this.adapter.addClass(switch_constants_cssClasses.DISABLED);
                } else {
                    this.adapter.removeClass(switch_constants_cssClasses.DISABLED);
                }
            };
            MDCSwitchFoundation.prototype.handleChange = function(evt) {
                var nativeControl = evt.target;
                this.updateAriaChecked_(nativeControl.checked);
                this.updateCheckedStyling_(nativeControl.checked);
            };
            MDCSwitchFoundation.prototype.updateCheckedStyling_ = function(checked) {
                if (checked) {
                    this.adapter.addClass(switch_constants_cssClasses.CHECKED);
                } else {
                    this.adapter.removeClass(switch_constants_cssClasses.CHECKED);
                }
            };
            MDCSwitchFoundation.prototype.updateAriaChecked_ = function(checked) {
                this.adapter.setNativeControlAttr(switch_constants_strings.ARIA_CHECKED_ATTR, "" + !!checked);
            };
            return MDCSwitchFoundation;
        }(MDCFoundation);
        const switch_foundation = null && MDCSwitchFoundation;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCSwitch = function(_super) {
            __extends(MDCSwitch, _super);
            function MDCSwitch() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.ripple_ = _this.createRipple_();
                return _this;
            }
            MDCSwitch.attachTo = function(root) {
                return new MDCSwitch(root);
            };
            MDCSwitch.prototype.destroy = function() {
                _super.prototype.destroy.call(this);
                this.ripple_.destroy();
                this.nativeControl_.removeEventListener("change", this.changeHandler_);
            };
            MDCSwitch.prototype.initialSyncWithDOM = function() {
                var _this = this;
                this.changeHandler_ = function() {
                    var _a;
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    return (_a = _this.foundation).handleChange.apply(_a, __spread(args));
                };
                this.nativeControl_.addEventListener("change", this.changeHandler_);
                this.checked = this.checked;
            };
            MDCSwitch.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    addClass: function(className) {
                        return _this.root.classList.add(className);
                    },
                    removeClass: function(className) {
                        return _this.root.classList.remove(className);
                    },
                    setNativeControlChecked: function(checked) {
                        return _this.nativeControl_.checked = checked;
                    },
                    setNativeControlDisabled: function(disabled) {
                        return _this.nativeControl_.disabled = disabled;
                    },
                    setNativeControlAttr: function(attr, value) {
                        return _this.nativeControl_.setAttribute(attr, value);
                    }
                };
                return new MDCSwitchFoundation(adapter);
            };
            Object.defineProperty(MDCSwitch.prototype, "ripple", {
                get: function() {
                    return this.ripple_;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSwitch.prototype, "checked", {
                get: function() {
                    return this.nativeControl_.checked;
                },
                set: function(checked) {
                    this.foundation.setChecked(checked);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCSwitch.prototype, "disabled", {
                get: function() {
                    return this.nativeControl_.disabled;
                },
                set: function(disabled) {
                    this.foundation.setDisabled(disabled);
                },
                enumerable: true,
                configurable: true
            });
            MDCSwitch.prototype.createRipple_ = function() {
                var _this = this;
                var RIPPLE_SURFACE_SELECTOR = MDCSwitchFoundation.strings.RIPPLE_SURFACE_SELECTOR;
                var rippleSurface = this.root.querySelector(RIPPLE_SURFACE_SELECTOR);
                var adapter = __assign(__assign({}, MDCRipple.createAdapter(this)), {
                    addClass: function(className) {
                        return rippleSurface.classList.add(className);
                    },
                    computeBoundingRect: function() {
                        return rippleSurface.getBoundingClientRect();
                    },
                    deregisterInteractionHandler: function(evtType, handler) {
                        _this.nativeControl_.removeEventListener(evtType, handler, applyPassive());
                    },
                    isSurfaceActive: function() {
                        return matches(_this.nativeControl_, ":active");
                    },
                    isUnbounded: function() {
                        return true;
                    },
                    registerInteractionHandler: function(evtType, handler) {
                        _this.nativeControl_.addEventListener(evtType, handler, applyPassive());
                    },
                    removeClass: function(className) {
                        rippleSurface.classList.remove(className);
                    },
                    updateCssVariable: function(varName, value) {
                        rippleSurface.style.setProperty(varName, value);
                    }
                });
                return new MDCRipple(this.root, new MDCRippleFoundation(adapter));
            };
            Object.defineProperty(MDCSwitch.prototype, "nativeControl_", {
                get: function() {
                    var NATIVE_CONTROL_SELECTOR = MDCSwitchFoundation.strings.NATIVE_CONTROL_SELECTOR;
                    return this.root.querySelector(NATIVE_CONTROL_SELECTOR);
                },
                enumerable: true,
                configurable: true
            });
            return MDCSwitch;
        }(MDCComponent);
        function MBSwitch_init(elem, checked) {
            elem._switch = MDCSwitch.attachTo(elem);
            elem._switch.checked = checked;
        }
        function MBSwitch_setChecked(elem, checked) {
            elem._switch.checked = checked;
        }
        function MBSwitch_setDisabled(elem, disabled) {
            elem._switch.disabled = disabled;
        }
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var tab_scroller_constants_cssClasses = {
            ANIMATING: "mdc-tab-scroller--animating",
            SCROLL_AREA_SCROLL: "mdc-tab-scroller__scroll-area--scroll",
            SCROLL_TEST: "mdc-tab-scroller__test"
        };
        var tab_scroller_constants_strings = {
            AREA_SELECTOR: ".mdc-tab-scroller__scroll-area",
            CONTENT_SELECTOR: ".mdc-tab-scroller__scroll-content"
        };
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCTabScrollerRTL = function() {
            function MDCTabScrollerRTL(adapter) {
                this.adapter = adapter;
            }
            return MDCTabScrollerRTL;
        }();
        const rtl_scroller = null && MDCTabScrollerRTL;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCTabScrollerRTLDefault = function(_super) {
            __extends(MDCTabScrollerRTLDefault, _super);
            function MDCTabScrollerRTLDefault() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCTabScrollerRTLDefault.prototype.getScrollPositionRTL = function() {
                var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
                var right = this.calculateScrollEdges_().right;
                return Math.round(right - currentScrollLeft);
            };
            MDCTabScrollerRTLDefault.prototype.scrollToRTL = function(scrollX) {
                var edges = this.calculateScrollEdges_();
                var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
                var clampedScrollLeft = this.clampScrollValue_(edges.right - scrollX);
                return {
                    finalScrollPosition: clampedScrollLeft,
                    scrollDelta: clampedScrollLeft - currentScrollLeft
                };
            };
            MDCTabScrollerRTLDefault.prototype.incrementScrollRTL = function(scrollX) {
                var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
                var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft - scrollX);
                return {
                    finalScrollPosition: clampedScrollLeft,
                    scrollDelta: clampedScrollLeft - currentScrollLeft
                };
            };
            MDCTabScrollerRTLDefault.prototype.getAnimatingScrollPosition = function(scrollX) {
                return scrollX;
            };
            MDCTabScrollerRTLDefault.prototype.calculateScrollEdges_ = function() {
                var contentWidth = this.adapter.getScrollContentOffsetWidth();
                var rootWidth = this.adapter.getScrollAreaOffsetWidth();
                return {
                    left: 0,
                    right: contentWidth - rootWidth
                };
            };
            MDCTabScrollerRTLDefault.prototype.clampScrollValue_ = function(scrollX) {
                var edges = this.calculateScrollEdges_();
                return Math.min(Math.max(edges.left, scrollX), edges.right);
            };
            return MDCTabScrollerRTLDefault;
        }(MDCTabScrollerRTL);
        const rtl_default_scroller = null && MDCTabScrollerRTLDefault;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCTabScrollerRTLNegative = function(_super) {
            __extends(MDCTabScrollerRTLNegative, _super);
            function MDCTabScrollerRTLNegative() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCTabScrollerRTLNegative.prototype.getScrollPositionRTL = function(translateX) {
                var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
                return Math.round(translateX - currentScrollLeft);
            };
            MDCTabScrollerRTLNegative.prototype.scrollToRTL = function(scrollX) {
                var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
                var clampedScrollLeft = this.clampScrollValue_(-scrollX);
                return {
                    finalScrollPosition: clampedScrollLeft,
                    scrollDelta: clampedScrollLeft - currentScrollLeft
                };
            };
            MDCTabScrollerRTLNegative.prototype.incrementScrollRTL = function(scrollX) {
                var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
                var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft - scrollX);
                return {
                    finalScrollPosition: clampedScrollLeft,
                    scrollDelta: clampedScrollLeft - currentScrollLeft
                };
            };
            MDCTabScrollerRTLNegative.prototype.getAnimatingScrollPosition = function(scrollX, translateX) {
                return scrollX - translateX;
            };
            MDCTabScrollerRTLNegative.prototype.calculateScrollEdges_ = function() {
                var contentWidth = this.adapter.getScrollContentOffsetWidth();
                var rootWidth = this.adapter.getScrollAreaOffsetWidth();
                return {
                    left: rootWidth - contentWidth,
                    right: 0
                };
            };
            MDCTabScrollerRTLNegative.prototype.clampScrollValue_ = function(scrollX) {
                var edges = this.calculateScrollEdges_();
                return Math.max(Math.min(edges.right, scrollX), edges.left);
            };
            return MDCTabScrollerRTLNegative;
        }(MDCTabScrollerRTL);
        const rtl_negative_scroller = null && MDCTabScrollerRTLNegative;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCTabScrollerRTLReverse = function(_super) {
            __extends(MDCTabScrollerRTLReverse, _super);
            function MDCTabScrollerRTLReverse() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCTabScrollerRTLReverse.prototype.getScrollPositionRTL = function(translateX) {
                var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
                return Math.round(currentScrollLeft - translateX);
            };
            MDCTabScrollerRTLReverse.prototype.scrollToRTL = function(scrollX) {
                var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
                var clampedScrollLeft = this.clampScrollValue_(scrollX);
                return {
                    finalScrollPosition: clampedScrollLeft,
                    scrollDelta: currentScrollLeft - clampedScrollLeft
                };
            };
            MDCTabScrollerRTLReverse.prototype.incrementScrollRTL = function(scrollX) {
                var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
                var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft + scrollX);
                return {
                    finalScrollPosition: clampedScrollLeft,
                    scrollDelta: currentScrollLeft - clampedScrollLeft
                };
            };
            MDCTabScrollerRTLReverse.prototype.getAnimatingScrollPosition = function(scrollX, translateX) {
                return scrollX + translateX;
            };
            MDCTabScrollerRTLReverse.prototype.calculateScrollEdges_ = function() {
                var contentWidth = this.adapter.getScrollContentOffsetWidth();
                var rootWidth = this.adapter.getScrollAreaOffsetWidth();
                return {
                    left: contentWidth - rootWidth,
                    right: 0
                };
            };
            MDCTabScrollerRTLReverse.prototype.clampScrollValue_ = function(scrollX) {
                var edges = this.calculateScrollEdges_();
                return Math.min(Math.max(edges.right, scrollX), edges.left);
            };
            return MDCTabScrollerRTLReverse;
        }(MDCTabScrollerRTL);
        const rtl_reverse_scroller = null && MDCTabScrollerRTLReverse;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCTabScrollerFoundation = function(_super) {
            __extends(MDCTabScrollerFoundation, _super);
            function MDCTabScrollerFoundation(adapter) {
                var _this = _super.call(this, __assign(__assign({}, MDCTabScrollerFoundation.defaultAdapter), adapter)) || this;
                _this.isAnimating_ = false;
                return _this;
            }
            Object.defineProperty(MDCTabScrollerFoundation, "cssClasses", {
                get: function() {
                    return tab_scroller_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTabScrollerFoundation, "strings", {
                get: function() {
                    return tab_scroller_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTabScrollerFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        eventTargetMatchesSelector: function() {
                            return false;
                        },
                        addClass: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        addScrollAreaClass: function() {
                            return undefined;
                        },
                        setScrollAreaStyleProperty: function() {
                            return undefined;
                        },
                        setScrollContentStyleProperty: function() {
                            return undefined;
                        },
                        getScrollContentStyleValue: function() {
                            return "";
                        },
                        setScrollAreaScrollLeft: function() {
                            return undefined;
                        },
                        getScrollAreaScrollLeft: function() {
                            return 0;
                        },
                        getScrollContentOffsetWidth: function() {
                            return 0;
                        },
                        getScrollAreaOffsetWidth: function() {
                            return 0;
                        },
                        computeScrollAreaClientRect: function() {
                            return {
                                top: 0,
                                right: 0,
                                bottom: 0,
                                left: 0,
                                width: 0,
                                height: 0
                            };
                        },
                        computeScrollContentClientRect: function() {
                            return {
                                top: 0,
                                right: 0,
                                bottom: 0,
                                left: 0,
                                width: 0,
                                height: 0
                            };
                        },
                        computeHorizontalScrollbarHeight: function() {
                            return 0;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCTabScrollerFoundation.prototype.init = function() {
                var horizontalScrollbarHeight = this.adapter.computeHorizontalScrollbarHeight();
                this.adapter.setScrollAreaStyleProperty("margin-bottom", -horizontalScrollbarHeight + "px");
                this.adapter.addScrollAreaClass(MDCTabScrollerFoundation.cssClasses.SCROLL_AREA_SCROLL);
            };
            MDCTabScrollerFoundation.prototype.getScrollPosition = function() {
                if (this.isRTL_()) {
                    return this.computeCurrentScrollPositionRTL_();
                }
                var currentTranslateX = this.calculateCurrentTranslateX_();
                var scrollLeft = this.adapter.getScrollAreaScrollLeft();
                return scrollLeft - currentTranslateX;
            };
            MDCTabScrollerFoundation.prototype.handleInteraction = function() {
                if (!this.isAnimating_) {
                    return;
                }
                this.stopScrollAnimation_();
            };
            MDCTabScrollerFoundation.prototype.handleTransitionEnd = function(evt) {
                var evtTarget = evt.target;
                if (!this.isAnimating_ || !this.adapter.eventTargetMatchesSelector(evtTarget, MDCTabScrollerFoundation.strings.CONTENT_SELECTOR)) {
                    return;
                }
                this.isAnimating_ = false;
                this.adapter.removeClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
            };
            MDCTabScrollerFoundation.prototype.incrementScroll = function(scrollXIncrement) {
                if (scrollXIncrement === 0) {
                    return;
                }
                this.animate_(this.getIncrementScrollOperation_(scrollXIncrement));
            };
            MDCTabScrollerFoundation.prototype.incrementScrollImmediate = function(scrollXIncrement) {
                if (scrollXIncrement === 0) {
                    return;
                }
                var operation = this.getIncrementScrollOperation_(scrollXIncrement);
                if (operation.scrollDelta === 0) {
                    return;
                }
                this.stopScrollAnimation_();
                this.adapter.setScrollAreaScrollLeft(operation.finalScrollPosition);
            };
            MDCTabScrollerFoundation.prototype.scrollTo = function(scrollX) {
                if (this.isRTL_()) {
                    return this.scrollToRTL_(scrollX);
                }
                this.scrollTo_(scrollX);
            };
            MDCTabScrollerFoundation.prototype.getRTLScroller = function() {
                if (!this.rtlScrollerInstance_) {
                    this.rtlScrollerInstance_ = this.rtlScrollerFactory_();
                }
                return this.rtlScrollerInstance_;
            };
            MDCTabScrollerFoundation.prototype.calculateCurrentTranslateX_ = function() {
                var transformValue = this.adapter.getScrollContentStyleValue("transform");
                if (transformValue === "none") {
                    return 0;
                }
                var match = /\((.+?)\)/.exec(transformValue);
                if (!match) {
                    return 0;
                }
                var matrixParams = match[1];
                var _a = __read(matrixParams.split(","), 6), a = _a[0], b = _a[1], c = _a[2], d = _a[3], tx = _a[4], ty = _a[5];
                return parseFloat(tx);
            };
            MDCTabScrollerFoundation.prototype.clampScrollValue_ = function(scrollX) {
                var edges = this.calculateScrollEdges_();
                return Math.min(Math.max(edges.left, scrollX), edges.right);
            };
            MDCTabScrollerFoundation.prototype.computeCurrentScrollPositionRTL_ = function() {
                var translateX = this.calculateCurrentTranslateX_();
                return this.getRTLScroller().getScrollPositionRTL(translateX);
            };
            MDCTabScrollerFoundation.prototype.calculateScrollEdges_ = function() {
                var contentWidth = this.adapter.getScrollContentOffsetWidth();
                var rootWidth = this.adapter.getScrollAreaOffsetWidth();
                return {
                    left: 0,
                    right: contentWidth - rootWidth
                };
            };
            MDCTabScrollerFoundation.prototype.scrollTo_ = function(scrollX) {
                var currentScrollX = this.getScrollPosition();
                var safeScrollX = this.clampScrollValue_(scrollX);
                var scrollDelta = safeScrollX - currentScrollX;
                this.animate_({
                    finalScrollPosition: safeScrollX,
                    scrollDelta: scrollDelta
                });
            };
            MDCTabScrollerFoundation.prototype.scrollToRTL_ = function(scrollX) {
                var animation = this.getRTLScroller().scrollToRTL(scrollX);
                this.animate_(animation);
            };
            MDCTabScrollerFoundation.prototype.getIncrementScrollOperation_ = function(scrollX) {
                if (this.isRTL_()) {
                    return this.getRTLScroller().incrementScrollRTL(scrollX);
                }
                var currentScrollX = this.getScrollPosition();
                var targetScrollX = scrollX + currentScrollX;
                var safeScrollX = this.clampScrollValue_(targetScrollX);
                var scrollDelta = safeScrollX - currentScrollX;
                return {
                    finalScrollPosition: safeScrollX,
                    scrollDelta: scrollDelta
                };
            };
            MDCTabScrollerFoundation.prototype.animate_ = function(animation) {
                var _this = this;
                if (animation.scrollDelta === 0) {
                    return;
                }
                this.stopScrollAnimation_();
                this.adapter.setScrollAreaScrollLeft(animation.finalScrollPosition);
                this.adapter.setScrollContentStyleProperty("transform", "translateX(" + animation.scrollDelta + "px)");
                this.adapter.computeScrollAreaClientRect();
                requestAnimationFrame((function() {
                    _this.adapter.addClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
                    _this.adapter.setScrollContentStyleProperty("transform", "none");
                }));
                this.isAnimating_ = true;
            };
            MDCTabScrollerFoundation.prototype.stopScrollAnimation_ = function() {
                this.isAnimating_ = false;
                var currentScrollPosition = this.getAnimatingScrollPosition_();
                this.adapter.removeClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
                this.adapter.setScrollContentStyleProperty("transform", "translateX(0px)");
                this.adapter.setScrollAreaScrollLeft(currentScrollPosition);
            };
            MDCTabScrollerFoundation.prototype.getAnimatingScrollPosition_ = function() {
                var currentTranslateX = this.calculateCurrentTranslateX_();
                var scrollLeft = this.adapter.getScrollAreaScrollLeft();
                if (this.isRTL_()) {
                    return this.getRTLScroller().getAnimatingScrollPosition(scrollLeft, currentTranslateX);
                }
                return scrollLeft - currentTranslateX;
            };
            MDCTabScrollerFoundation.prototype.rtlScrollerFactory_ = function() {
                var initialScrollLeft = this.adapter.getScrollAreaScrollLeft();
                this.adapter.setScrollAreaScrollLeft(initialScrollLeft - 1);
                var newScrollLeft = this.adapter.getScrollAreaScrollLeft();
                if (newScrollLeft < 0) {
                    this.adapter.setScrollAreaScrollLeft(initialScrollLeft);
                    return new MDCTabScrollerRTLNegative(this.adapter);
                }
                var rootClientRect = this.adapter.computeScrollAreaClientRect();
                var contentClientRect = this.adapter.computeScrollContentClientRect();
                var rightEdgeDelta = Math.round(contentClientRect.right - rootClientRect.right);
                this.adapter.setScrollAreaScrollLeft(initialScrollLeft);
                if (rightEdgeDelta === newScrollLeft) {
                    return new MDCTabScrollerRTLReverse(this.adapter);
                }
                return new MDCTabScrollerRTLDefault(this.adapter);
            };
            MDCTabScrollerFoundation.prototype.isRTL_ = function() {
                return this.adapter.getScrollContentStyleValue("direction") === "rtl";
            };
            return MDCTabScrollerFoundation;
        }(MDCFoundation);
        const tab_scroller_foundation = null && MDCTabScrollerFoundation;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var horizontalScrollbarHeight_;
        function computeHorizontalScrollbarHeight(documentObj, shouldCacheResult) {
            if (shouldCacheResult === void 0) {
                shouldCacheResult = true;
            }
            if (shouldCacheResult && typeof horizontalScrollbarHeight_ !== "undefined") {
                return horizontalScrollbarHeight_;
            }
            var el = documentObj.createElement("div");
            el.classList.add(tab_scroller_constants_cssClasses.SCROLL_TEST);
            documentObj.body.appendChild(el);
            var horizontalScrollbarHeight = el.offsetHeight - el.clientHeight;
            documentObj.body.removeChild(el);
            if (shouldCacheResult) {
                horizontalScrollbarHeight_ = horizontalScrollbarHeight;
            }
            return horizontalScrollbarHeight;
        }
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCTabScroller = function(_super) {
            __extends(MDCTabScroller, _super);
            function MDCTabScroller() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCTabScroller.attachTo = function(root) {
                return new MDCTabScroller(root);
            };
            MDCTabScroller.prototype.initialize = function() {
                this.area_ = this.root.querySelector(MDCTabScrollerFoundation.strings.AREA_SELECTOR);
                this.content_ = this.root.querySelector(MDCTabScrollerFoundation.strings.CONTENT_SELECTOR);
            };
            MDCTabScroller.prototype.initialSyncWithDOM = function() {
                var _this = this;
                this.handleInteraction_ = function() {
                    return _this.foundation.handleInteraction();
                };
                this.handleTransitionEnd_ = function(evt) {
                    return _this.foundation.handleTransitionEnd(evt);
                };
                this.area_.addEventListener("wheel", this.handleInteraction_, applyPassive());
                this.area_.addEventListener("touchstart", this.handleInteraction_, applyPassive());
                this.area_.addEventListener("pointerdown", this.handleInteraction_, applyPassive());
                this.area_.addEventListener("mousedown", this.handleInteraction_, applyPassive());
                this.area_.addEventListener("keydown", this.handleInteraction_, applyPassive());
                this.content_.addEventListener("transitionend", this.handleTransitionEnd_);
            };
            MDCTabScroller.prototype.destroy = function() {
                _super.prototype.destroy.call(this);
                this.area_.removeEventListener("wheel", this.handleInteraction_, applyPassive());
                this.area_.removeEventListener("touchstart", this.handleInteraction_, applyPassive());
                this.area_.removeEventListener("pointerdown", this.handleInteraction_, applyPassive());
                this.area_.removeEventListener("mousedown", this.handleInteraction_, applyPassive());
                this.area_.removeEventListener("keydown", this.handleInteraction_, applyPassive());
                this.content_.removeEventListener("transitionend", this.handleTransitionEnd_);
            };
            MDCTabScroller.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    eventTargetMatchesSelector: function(evtTarget, selector) {
                        return matches(evtTarget, selector);
                    },
                    addClass: function(className) {
                        return _this.root.classList.add(className);
                    },
                    removeClass: function(className) {
                        return _this.root.classList.remove(className);
                    },
                    addScrollAreaClass: function(className) {
                        return _this.area_.classList.add(className);
                    },
                    setScrollAreaStyleProperty: function(prop, value) {
                        return _this.area_.style.setProperty(prop, value);
                    },
                    setScrollContentStyleProperty: function(prop, value) {
                        return _this.content_.style.setProperty(prop, value);
                    },
                    getScrollContentStyleValue: function(propName) {
                        return window.getComputedStyle(_this.content_).getPropertyValue(propName);
                    },
                    setScrollAreaScrollLeft: function(scrollX) {
                        return _this.area_.scrollLeft = scrollX;
                    },
                    getScrollAreaScrollLeft: function() {
                        return _this.area_.scrollLeft;
                    },
                    getScrollContentOffsetWidth: function() {
                        return _this.content_.offsetWidth;
                    },
                    getScrollAreaOffsetWidth: function() {
                        return _this.area_.offsetWidth;
                    },
                    computeScrollAreaClientRect: function() {
                        return _this.area_.getBoundingClientRect();
                    },
                    computeScrollContentClientRect: function() {
                        return _this.content_.getBoundingClientRect();
                    },
                    computeHorizontalScrollbarHeight: function() {
                        return computeHorizontalScrollbarHeight(document);
                    }
                };
                return new MDCTabScrollerFoundation(adapter);
            };
            MDCTabScroller.prototype.getScrollPosition = function() {
                return this.foundation.getScrollPosition();
            };
            MDCTabScroller.prototype.getScrollContentWidth = function() {
                return this.content_.offsetWidth;
            };
            MDCTabScroller.prototype.incrementScroll = function(scrollXIncrement) {
                this.foundation.incrementScroll(scrollXIncrement);
            };
            MDCTabScroller.prototype.scrollTo = function(scrollX) {
                this.foundation.scrollTo(scrollX);
            };
            return MDCTabScroller;
        }(MDCComponent);
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var tab_indicator_constants_cssClasses = {
            ACTIVE: "mdc-tab-indicator--active",
            FADE: "mdc-tab-indicator--fade",
            NO_TRANSITION: "mdc-tab-indicator--no-transition"
        };
        var tab_indicator_constants_strings = {
            CONTENT_SELECTOR: ".mdc-tab-indicator__content"
        };
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCTabIndicatorFoundation = function(_super) {
            __extends(MDCTabIndicatorFoundation, _super);
            function MDCTabIndicatorFoundation(adapter) {
                return _super.call(this, __assign(__assign({}, MDCTabIndicatorFoundation.defaultAdapter), adapter)) || this;
            }
            Object.defineProperty(MDCTabIndicatorFoundation, "cssClasses", {
                get: function() {
                    return tab_indicator_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTabIndicatorFoundation, "strings", {
                get: function() {
                    return tab_indicator_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTabIndicatorFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClass: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        computeContentClientRect: function() {
                            return {
                                top: 0,
                                right: 0,
                                bottom: 0,
                                left: 0,
                                width: 0,
                                height: 0
                            };
                        },
                        setContentStyleProperty: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCTabIndicatorFoundation.prototype.computeContentClientRect = function() {
                return this.adapter.computeContentClientRect();
            };
            return MDCTabIndicatorFoundation;
        }(MDCFoundation);
        const tab_indicator_foundation = null && MDCTabIndicatorFoundation;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCFadingTabIndicatorFoundation = function(_super) {
            __extends(MDCFadingTabIndicatorFoundation, _super);
            function MDCFadingTabIndicatorFoundation() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCFadingTabIndicatorFoundation.prototype.activate = function() {
                this.adapter.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
            };
            MDCFadingTabIndicatorFoundation.prototype.deactivate = function() {
                this.adapter.removeClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
            };
            return MDCFadingTabIndicatorFoundation;
        }(MDCTabIndicatorFoundation);
        const fading_foundation = null && MDCFadingTabIndicatorFoundation;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCSlidingTabIndicatorFoundation = function(_super) {
            __extends(MDCSlidingTabIndicatorFoundation, _super);
            function MDCSlidingTabIndicatorFoundation() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCSlidingTabIndicatorFoundation.prototype.activate = function(previousIndicatorClientRect) {
                if (!previousIndicatorClientRect) {
                    this.adapter.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
                    return;
                }
                var currentClientRect = this.computeContentClientRect();
                var widthDelta = previousIndicatorClientRect.width / currentClientRect.width;
                var xPosition = previousIndicatorClientRect.left - currentClientRect.left;
                this.adapter.addClass(MDCTabIndicatorFoundation.cssClasses.NO_TRANSITION);
                this.adapter.setContentStyleProperty("transform", "translateX(" + xPosition + "px) scaleX(" + widthDelta + ")");
                this.computeContentClientRect();
                this.adapter.removeClass(MDCTabIndicatorFoundation.cssClasses.NO_TRANSITION);
                this.adapter.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
                this.adapter.setContentStyleProperty("transform", "");
            };
            MDCSlidingTabIndicatorFoundation.prototype.deactivate = function() {
                this.adapter.removeClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
            };
            return MDCSlidingTabIndicatorFoundation;
        }(MDCTabIndicatorFoundation);
        const sliding_foundation = null && MDCSlidingTabIndicatorFoundation;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCTabIndicator = function(_super) {
            __extends(MDCTabIndicator, _super);
            function MDCTabIndicator() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCTabIndicator.attachTo = function(root) {
                return new MDCTabIndicator(root);
            };
            MDCTabIndicator.prototype.initialize = function() {
                this.content_ = this.root.querySelector(MDCTabIndicatorFoundation.strings.CONTENT_SELECTOR);
            };
            MDCTabIndicator.prototype.computeContentClientRect = function() {
                return this.foundation.computeContentClientRect();
            };
            MDCTabIndicator.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    addClass: function(className) {
                        return _this.root.classList.add(className);
                    },
                    removeClass: function(className) {
                        return _this.root.classList.remove(className);
                    },
                    computeContentClientRect: function() {
                        return _this.content_.getBoundingClientRect();
                    },
                    setContentStyleProperty: function(prop, value) {
                        return _this.content_.style.setProperty(prop, value);
                    }
                };
                if (this.root.classList.contains(MDCTabIndicatorFoundation.cssClasses.FADE)) {
                    return new MDCFadingTabIndicatorFoundation(adapter);
                }
                return new MDCSlidingTabIndicatorFoundation(adapter);
            };
            MDCTabIndicator.prototype.activate = function(previousIndicatorClientRect) {
                this.foundation.activate(previousIndicatorClientRect);
            };
            MDCTabIndicator.prototype.deactivate = function() {
                this.foundation.deactivate();
            };
            return MDCTabIndicator;
        }(MDCComponent);
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var tab_constants_cssClasses = {
            ACTIVE: "mdc-tab--active"
        };
        var tab_constants_strings = {
            ARIA_SELECTED: "aria-selected",
            CONTENT_SELECTOR: ".mdc-tab__content",
            INTERACTED_EVENT: "MDCTab:interacted",
            RIPPLE_SELECTOR: ".mdc-tab__ripple",
            TABINDEX: "tabIndex",
            TAB_INDICATOR_SELECTOR: ".mdc-tab-indicator"
        };
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCTabFoundation = function(_super) {
            __extends(MDCTabFoundation, _super);
            function MDCTabFoundation(adapter) {
                var _this = _super.call(this, __assign(__assign({}, MDCTabFoundation.defaultAdapter), adapter)) || this;
                _this.focusOnActivate_ = true;
                return _this;
            }
            Object.defineProperty(MDCTabFoundation, "cssClasses", {
                get: function() {
                    return tab_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTabFoundation, "strings", {
                get: function() {
                    return tab_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTabFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClass: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        hasClass: function() {
                            return false;
                        },
                        setAttr: function() {
                            return undefined;
                        },
                        activateIndicator: function() {
                            return undefined;
                        },
                        deactivateIndicator: function() {
                            return undefined;
                        },
                        notifyInteracted: function() {
                            return undefined;
                        },
                        getOffsetLeft: function() {
                            return 0;
                        },
                        getOffsetWidth: function() {
                            return 0;
                        },
                        getContentOffsetLeft: function() {
                            return 0;
                        },
                        getContentOffsetWidth: function() {
                            return 0;
                        },
                        focus: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCTabFoundation.prototype.handleClick = function() {
                this.adapter.notifyInteracted();
            };
            MDCTabFoundation.prototype.isActive = function() {
                return this.adapter.hasClass(tab_constants_cssClasses.ACTIVE);
            };
            MDCTabFoundation.prototype.setFocusOnActivate = function(focusOnActivate) {
                this.focusOnActivate_ = focusOnActivate;
            };
            MDCTabFoundation.prototype.activate = function(previousIndicatorClientRect) {
                this.adapter.addClass(tab_constants_cssClasses.ACTIVE);
                this.adapter.setAttr(tab_constants_strings.ARIA_SELECTED, "true");
                this.adapter.setAttr(tab_constants_strings.TABINDEX, "0");
                this.adapter.activateIndicator(previousIndicatorClientRect);
                if (this.focusOnActivate_) {
                    this.adapter.focus();
                }
            };
            MDCTabFoundation.prototype.deactivate = function() {
                if (!this.isActive()) {
                    return;
                }
                this.adapter.removeClass(tab_constants_cssClasses.ACTIVE);
                this.adapter.setAttr(tab_constants_strings.ARIA_SELECTED, "false");
                this.adapter.setAttr(tab_constants_strings.TABINDEX, "-1");
                this.adapter.deactivateIndicator();
            };
            MDCTabFoundation.prototype.computeDimensions = function() {
                var rootWidth = this.adapter.getOffsetWidth();
                var rootLeft = this.adapter.getOffsetLeft();
                var contentWidth = this.adapter.getContentOffsetWidth();
                var contentLeft = this.adapter.getContentOffsetLeft();
                return {
                    contentLeft: rootLeft + contentLeft,
                    contentRight: rootLeft + contentLeft + contentWidth,
                    rootLeft: rootLeft,
                    rootRight: rootLeft + rootWidth
                };
            };
            return MDCTabFoundation;
        }(MDCFoundation);
        const tab_foundation = null && MDCTabFoundation;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCTab = function(_super) {
            __extends(MDCTab, _super);
            function MDCTab() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCTab.attachTo = function(root) {
                return new MDCTab(root);
            };
            MDCTab.prototype.initialize = function(rippleFactory, tabIndicatorFactory) {
                if (rippleFactory === void 0) {
                    rippleFactory = function(el, foundation) {
                        return new MDCRipple(el, foundation);
                    };
                }
                if (tabIndicatorFactory === void 0) {
                    tabIndicatorFactory = function(el) {
                        return new MDCTabIndicator(el);
                    };
                }
                this.id = this.root.id;
                var rippleSurface = this.root.querySelector(MDCTabFoundation.strings.RIPPLE_SELECTOR);
                var rippleAdapter = __assign(__assign({}, MDCRipple.createAdapter(this)), {
                    addClass: function(className) {
                        return rippleSurface.classList.add(className);
                    },
                    removeClass: function(className) {
                        return rippleSurface.classList.remove(className);
                    },
                    updateCssVariable: function(varName, value) {
                        return rippleSurface.style.setProperty(varName, value);
                    }
                });
                var rippleFoundation = new MDCRippleFoundation(rippleAdapter);
                this.ripple_ = rippleFactory(this.root, rippleFoundation);
                var tabIndicatorElement = this.root.querySelector(MDCTabFoundation.strings.TAB_INDICATOR_SELECTOR);
                this.tabIndicator_ = tabIndicatorFactory(tabIndicatorElement);
                this.content_ = this.root.querySelector(MDCTabFoundation.strings.CONTENT_SELECTOR);
            };
            MDCTab.prototype.initialSyncWithDOM = function() {
                var _this = this;
                this.handleClick_ = function() {
                    return _this.foundation.handleClick();
                };
                this.listen("click", this.handleClick_);
            };
            MDCTab.prototype.destroy = function() {
                this.unlisten("click", this.handleClick_);
                this.ripple_.destroy();
                _super.prototype.destroy.call(this);
            };
            MDCTab.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    setAttr: function(attr, value) {
                        return _this.root.setAttribute(attr, value);
                    },
                    addClass: function(className) {
                        return _this.root.classList.add(className);
                    },
                    removeClass: function(className) {
                        return _this.root.classList.remove(className);
                    },
                    hasClass: function(className) {
                        return _this.root.classList.contains(className);
                    },
                    activateIndicator: function(previousIndicatorClientRect) {
                        return _this.tabIndicator_.activate(previousIndicatorClientRect);
                    },
                    deactivateIndicator: function() {
                        return _this.tabIndicator_.deactivate();
                    },
                    notifyInteracted: function() {
                        return _this.emit(MDCTabFoundation.strings.INTERACTED_EVENT, {
                            tabId: _this.id
                        }, true);
                    },
                    getOffsetLeft: function() {
                        return _this.root.offsetLeft;
                    },
                    getOffsetWidth: function() {
                        return _this.root.offsetWidth;
                    },
                    getContentOffsetLeft: function() {
                        return _this.content_.offsetLeft;
                    },
                    getContentOffsetWidth: function() {
                        return _this.content_.offsetWidth;
                    },
                    focus: function() {
                        return _this.root.focus();
                    }
                };
                return new MDCTabFoundation(adapter);
            };
            Object.defineProperty(MDCTab.prototype, "active", {
                get: function() {
                    return this.foundation.isActive();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTab.prototype, "focusOnActivate", {
                set: function(focusOnActivate) {
                    this.foundation.setFocusOnActivate(focusOnActivate);
                },
                enumerable: true,
                configurable: true
            });
            MDCTab.prototype.activate = function(computeIndicatorClientRect) {
                this.foundation.activate(computeIndicatorClientRect);
            };
            MDCTab.prototype.deactivate = function() {
                this.foundation.deactivate();
            };
            MDCTab.prototype.computeIndicatorClientRect = function() {
                return this.tabIndicator_.computeContentClientRect();
            };
            MDCTab.prototype.computeDimensions = function() {
                return this.foundation.computeDimensions();
            };
            MDCTab.prototype.focus = function() {
                this.root.focus();
            };
            return MDCTab;
        }(MDCComponent);
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var tab_bar_constants_strings = {
            ARROW_LEFT_KEY: "ArrowLeft",
            ARROW_RIGHT_KEY: "ArrowRight",
            END_KEY: "End",
            ENTER_KEY: "Enter",
            HOME_KEY: "Home",
            SPACE_KEY: "Space",
            TAB_ACTIVATED_EVENT: "MDCTabBar:activated",
            TAB_SCROLLER_SELECTOR: ".mdc-tab-scroller",
            TAB_SELECTOR: ".mdc-tab"
        };
        var tab_bar_constants_numbers = {
            ARROW_LEFT_KEYCODE: 37,
            ARROW_RIGHT_KEYCODE: 39,
            END_KEYCODE: 35,
            ENTER_KEYCODE: 13,
            EXTRA_SCROLL_AMOUNT: 20,
            HOME_KEYCODE: 36,
            SPACE_KEYCODE: 32
        };
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var ACCEPTABLE_KEYS = new Set;
        ACCEPTABLE_KEYS.add(tab_bar_constants_strings.ARROW_LEFT_KEY);
        ACCEPTABLE_KEYS.add(tab_bar_constants_strings.ARROW_RIGHT_KEY);
        ACCEPTABLE_KEYS.add(tab_bar_constants_strings.END_KEY);
        ACCEPTABLE_KEYS.add(tab_bar_constants_strings.HOME_KEY);
        ACCEPTABLE_KEYS.add(tab_bar_constants_strings.ENTER_KEY);
        ACCEPTABLE_KEYS.add(tab_bar_constants_strings.SPACE_KEY);
        var KEYCODE_MAP = new Map;
        KEYCODE_MAP.set(tab_bar_constants_numbers.ARROW_LEFT_KEYCODE, tab_bar_constants_strings.ARROW_LEFT_KEY);
        KEYCODE_MAP.set(tab_bar_constants_numbers.ARROW_RIGHT_KEYCODE, tab_bar_constants_strings.ARROW_RIGHT_KEY);
        KEYCODE_MAP.set(tab_bar_constants_numbers.END_KEYCODE, tab_bar_constants_strings.END_KEY);
        KEYCODE_MAP.set(tab_bar_constants_numbers.HOME_KEYCODE, tab_bar_constants_strings.HOME_KEY);
        KEYCODE_MAP.set(tab_bar_constants_numbers.ENTER_KEYCODE, tab_bar_constants_strings.ENTER_KEY);
        KEYCODE_MAP.set(tab_bar_constants_numbers.SPACE_KEYCODE, tab_bar_constants_strings.SPACE_KEY);
        var MDCTabBarFoundation = function(_super) {
            __extends(MDCTabBarFoundation, _super);
            function MDCTabBarFoundation(adapter) {
                var _this = _super.call(this, __assign(__assign({}, MDCTabBarFoundation.defaultAdapter), adapter)) || this;
                _this.useAutomaticActivation_ = false;
                return _this;
            }
            Object.defineProperty(MDCTabBarFoundation, "strings", {
                get: function() {
                    return tab_bar_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTabBarFoundation, "numbers", {
                get: function() {
                    return tab_bar_constants_numbers;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTabBarFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        scrollTo: function() {
                            return undefined;
                        },
                        incrementScroll: function() {
                            return undefined;
                        },
                        getScrollPosition: function() {
                            return 0;
                        },
                        getScrollContentWidth: function() {
                            return 0;
                        },
                        getOffsetWidth: function() {
                            return 0;
                        },
                        isRTL: function() {
                            return false;
                        },
                        setActiveTab: function() {
                            return undefined;
                        },
                        activateTabAtIndex: function() {
                            return undefined;
                        },
                        deactivateTabAtIndex: function() {
                            return undefined;
                        },
                        focusTabAtIndex: function() {
                            return undefined;
                        },
                        getTabIndicatorClientRectAtIndex: function() {
                            return {
                                top: 0,
                                right: 0,
                                bottom: 0,
                                left: 0,
                                width: 0,
                                height: 0
                            };
                        },
                        getTabDimensionsAtIndex: function() {
                            return {
                                rootLeft: 0,
                                rootRight: 0,
                                contentLeft: 0,
                                contentRight: 0
                            };
                        },
                        getPreviousActiveTabIndex: function() {
                            return -1;
                        },
                        getFocusedTabIndex: function() {
                            return -1;
                        },
                        getIndexOfTabById: function() {
                            return -1;
                        },
                        getTabListLength: function() {
                            return 0;
                        },
                        notifyTabActivated: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCTabBarFoundation.prototype.setUseAutomaticActivation = function(useAutomaticActivation) {
                this.useAutomaticActivation_ = useAutomaticActivation;
            };
            MDCTabBarFoundation.prototype.activateTab = function(index) {
                var previousActiveIndex = this.adapter.getPreviousActiveTabIndex();
                if (!this.indexIsInRange_(index) || index === previousActiveIndex) {
                    return;
                }
                var previousClientRect;
                if (previousActiveIndex !== -1) {
                    this.adapter.deactivateTabAtIndex(previousActiveIndex);
                    previousClientRect = this.adapter.getTabIndicatorClientRectAtIndex(previousActiveIndex);
                }
                this.adapter.activateTabAtIndex(index, previousClientRect);
                this.scrollIntoView(index);
                this.adapter.notifyTabActivated(index);
            };
            MDCTabBarFoundation.prototype.handleKeyDown = function(evt) {
                var key = this.getKeyFromEvent_(evt);
                if (key === undefined) {
                    return;
                }
                if (!this.isActivationKey_(key)) {
                    evt.preventDefault();
                }
                if (this.useAutomaticActivation_) {
                    if (this.isActivationKey_(key)) {
                        return;
                    }
                    var index = this.determineTargetFromKey_(this.adapter.getPreviousActiveTabIndex(), key);
                    this.adapter.setActiveTab(index);
                    this.scrollIntoView(index);
                } else {
                    var focusedTabIndex = this.adapter.getFocusedTabIndex();
                    if (this.isActivationKey_(key)) {
                        this.adapter.setActiveTab(focusedTabIndex);
                    } else {
                        var index = this.determineTargetFromKey_(focusedTabIndex, key);
                        this.adapter.focusTabAtIndex(index);
                        this.scrollIntoView(index);
                    }
                }
            };
            MDCTabBarFoundation.prototype.handleTabInteraction = function(evt) {
                this.adapter.setActiveTab(this.adapter.getIndexOfTabById(evt.detail.tabId));
            };
            MDCTabBarFoundation.prototype.scrollIntoView = function(index) {
                if (!this.indexIsInRange_(index)) {
                    return;
                }
                if (index === 0) {
                    return this.adapter.scrollTo(0);
                }
                if (index === this.adapter.getTabListLength() - 1) {
                    return this.adapter.scrollTo(this.adapter.getScrollContentWidth());
                }
                if (this.isRTL_()) {
                    return this.scrollIntoViewRTL_(index);
                }
                this.scrollIntoView_(index);
            };
            MDCTabBarFoundation.prototype.determineTargetFromKey_ = function(origin, key) {
                var isRTL = this.isRTL_();
                var maxIndex = this.adapter.getTabListLength() - 1;
                var shouldGoToEnd = key === tab_bar_constants_strings.END_KEY;
                var shouldDecrement = key === tab_bar_constants_strings.ARROW_LEFT_KEY && !isRTL || key === tab_bar_constants_strings.ARROW_RIGHT_KEY && isRTL;
                var shouldIncrement = key === tab_bar_constants_strings.ARROW_RIGHT_KEY && !isRTL || key === tab_bar_constants_strings.ARROW_LEFT_KEY && isRTL;
                var index = origin;
                if (shouldGoToEnd) {
                    index = maxIndex;
                } else if (shouldDecrement) {
                    index -= 1;
                } else if (shouldIncrement) {
                    index += 1;
                } else {
                    index = 0;
                }
                if (index < 0) {
                    index = maxIndex;
                } else if (index > maxIndex) {
                    index = 0;
                }
                return index;
            };
            MDCTabBarFoundation.prototype.calculateScrollIncrement_ = function(index, nextIndex, scrollPosition, barWidth) {
                var nextTabDimensions = this.adapter.getTabDimensionsAtIndex(nextIndex);
                var relativeContentLeft = nextTabDimensions.contentLeft - scrollPosition - barWidth;
                var relativeContentRight = nextTabDimensions.contentRight - scrollPosition;
                var leftIncrement = relativeContentRight - tab_bar_constants_numbers.EXTRA_SCROLL_AMOUNT;
                var rightIncrement = relativeContentLeft + tab_bar_constants_numbers.EXTRA_SCROLL_AMOUNT;
                if (nextIndex < index) {
                    return Math.min(leftIncrement, 0);
                }
                return Math.max(rightIncrement, 0);
            };
            MDCTabBarFoundation.prototype.calculateScrollIncrementRTL_ = function(index, nextIndex, scrollPosition, barWidth, scrollContentWidth) {
                var nextTabDimensions = this.adapter.getTabDimensionsAtIndex(nextIndex);
                var relativeContentLeft = scrollContentWidth - nextTabDimensions.contentLeft - scrollPosition;
                var relativeContentRight = scrollContentWidth - nextTabDimensions.contentRight - scrollPosition - barWidth;
                var leftIncrement = relativeContentRight + tab_bar_constants_numbers.EXTRA_SCROLL_AMOUNT;
                var rightIncrement = relativeContentLeft - tab_bar_constants_numbers.EXTRA_SCROLL_AMOUNT;
                if (nextIndex > index) {
                    return Math.max(leftIncrement, 0);
                }
                return Math.min(rightIncrement, 0);
            };
            MDCTabBarFoundation.prototype.findAdjacentTabIndexClosestToEdge_ = function(index, tabDimensions, scrollPosition, barWidth) {
                var relativeRootLeft = tabDimensions.rootLeft - scrollPosition;
                var relativeRootRight = tabDimensions.rootRight - scrollPosition - barWidth;
                var relativeRootDelta = relativeRootLeft + relativeRootRight;
                var leftEdgeIsCloser = relativeRootLeft < 0 || relativeRootDelta < 0;
                var rightEdgeIsCloser = relativeRootRight > 0 || relativeRootDelta > 0;
                if (leftEdgeIsCloser) {
                    return index - 1;
                }
                if (rightEdgeIsCloser) {
                    return index + 1;
                }
                return -1;
            };
            MDCTabBarFoundation.prototype.findAdjacentTabIndexClosestToEdgeRTL_ = function(index, tabDimensions, scrollPosition, barWidth, scrollContentWidth) {
                var rootLeft = scrollContentWidth - tabDimensions.rootLeft - barWidth - scrollPosition;
                var rootRight = scrollContentWidth - tabDimensions.rootRight - scrollPosition;
                var rootDelta = rootLeft + rootRight;
                var leftEdgeIsCloser = rootLeft > 0 || rootDelta > 0;
                var rightEdgeIsCloser = rootRight < 0 || rootDelta < 0;
                if (leftEdgeIsCloser) {
                    return index + 1;
                }
                if (rightEdgeIsCloser) {
                    return index - 1;
                }
                return -1;
            };
            MDCTabBarFoundation.prototype.getKeyFromEvent_ = function(evt) {
                if (ACCEPTABLE_KEYS.has(evt.key)) {
                    return evt.key;
                }
                return KEYCODE_MAP.get(evt.keyCode);
            };
            MDCTabBarFoundation.prototype.isActivationKey_ = function(key) {
                return key === tab_bar_constants_strings.SPACE_KEY || key === tab_bar_constants_strings.ENTER_KEY;
            };
            MDCTabBarFoundation.prototype.indexIsInRange_ = function(index) {
                return index >= 0 && index < this.adapter.getTabListLength();
            };
            MDCTabBarFoundation.prototype.isRTL_ = function() {
                return this.adapter.isRTL();
            };
            MDCTabBarFoundation.prototype.scrollIntoView_ = function(index) {
                var scrollPosition = this.adapter.getScrollPosition();
                var barWidth = this.adapter.getOffsetWidth();
                var tabDimensions = this.adapter.getTabDimensionsAtIndex(index);
                var nextIndex = this.findAdjacentTabIndexClosestToEdge_(index, tabDimensions, scrollPosition, barWidth);
                if (!this.indexIsInRange_(nextIndex)) {
                    return;
                }
                var scrollIncrement = this.calculateScrollIncrement_(index, nextIndex, scrollPosition, barWidth);
                this.adapter.incrementScroll(scrollIncrement);
            };
            MDCTabBarFoundation.prototype.scrollIntoViewRTL_ = function(index) {
                var scrollPosition = this.adapter.getScrollPosition();
                var barWidth = this.adapter.getOffsetWidth();
                var tabDimensions = this.adapter.getTabDimensionsAtIndex(index);
                var scrollWidth = this.adapter.getScrollContentWidth();
                var nextIndex = this.findAdjacentTabIndexClosestToEdgeRTL_(index, tabDimensions, scrollPosition, barWidth, scrollWidth);
                if (!this.indexIsInRange_(nextIndex)) {
                    return;
                }
                var scrollIncrement = this.calculateScrollIncrementRTL_(index, nextIndex, scrollPosition, barWidth, scrollWidth);
                this.adapter.incrementScroll(scrollIncrement);
            };
            return MDCTabBarFoundation;
        }(MDCFoundation);
        const tab_bar_foundation = null && MDCTabBarFoundation;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var tab_bar_component_strings = MDCTabBarFoundation.strings;
        var tabIdCounter = 0;
        var MDCTabBar = function(_super) {
            __extends(MDCTabBar, _super);
            function MDCTabBar() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCTabBar.attachTo = function(root) {
                return new MDCTabBar(root);
            };
            Object.defineProperty(MDCTabBar.prototype, "focusOnActivate", {
                set: function(focusOnActivate) {
                    this.tabList_.forEach((function(tab) {
                        return tab.focusOnActivate = focusOnActivate;
                    }));
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTabBar.prototype, "useAutomaticActivation", {
                set: function(useAutomaticActivation) {
                    this.foundation.setUseAutomaticActivation(useAutomaticActivation);
                },
                enumerable: true,
                configurable: true
            });
            MDCTabBar.prototype.initialize = function(tabFactory, tabScrollerFactory) {
                if (tabFactory === void 0) {
                    tabFactory = function(el) {
                        return new MDCTab(el);
                    };
                }
                if (tabScrollerFactory === void 0) {
                    tabScrollerFactory = function(el) {
                        return new MDCTabScroller(el);
                    };
                }
                this.tabList_ = this.instantiateTabs_(tabFactory);
                this.tabScroller_ = this.instantiateTabScroller_(tabScrollerFactory);
            };
            MDCTabBar.prototype.initialSyncWithDOM = function() {
                var _this = this;
                this.handleTabInteraction_ = function(evt) {
                    return _this.foundation.handleTabInteraction(evt);
                };
                this.handleKeyDown_ = function(evt) {
                    return _this.foundation.handleKeyDown(evt);
                };
                this.listen(MDCTabFoundation.strings.INTERACTED_EVENT, this.handleTabInteraction_);
                this.listen("keydown", this.handleKeyDown_);
                for (var i = 0; i < this.tabList_.length; i++) {
                    if (this.tabList_[i].active) {
                        this.scrollIntoView(i);
                        break;
                    }
                }
            };
            MDCTabBar.prototype.destroy = function() {
                _super.prototype.destroy.call(this);
                this.unlisten(MDCTabFoundation.strings.INTERACTED_EVENT, this.handleTabInteraction_);
                this.unlisten("keydown", this.handleKeyDown_);
                this.tabList_.forEach((function(tab) {
                    return tab.destroy();
                }));
                if (this.tabScroller_) {
                    this.tabScroller_.destroy();
                }
            };
            MDCTabBar.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    scrollTo: function(scrollX) {
                        return _this.tabScroller_.scrollTo(scrollX);
                    },
                    incrementScroll: function(scrollXIncrement) {
                        return _this.tabScroller_.incrementScroll(scrollXIncrement);
                    },
                    getScrollPosition: function() {
                        return _this.tabScroller_.getScrollPosition();
                    },
                    getScrollContentWidth: function() {
                        return _this.tabScroller_.getScrollContentWidth();
                    },
                    getOffsetWidth: function() {
                        return _this.root.offsetWidth;
                    },
                    isRTL: function() {
                        return window.getComputedStyle(_this.root).getPropertyValue("direction") === "rtl";
                    },
                    setActiveTab: function(index) {
                        return _this.foundation.activateTab(index);
                    },
                    activateTabAtIndex: function(index, clientRect) {
                        return _this.tabList_[index].activate(clientRect);
                    },
                    deactivateTabAtIndex: function(index) {
                        return _this.tabList_[index].deactivate();
                    },
                    focusTabAtIndex: function(index) {
                        return _this.tabList_[index].focus();
                    },
                    getTabIndicatorClientRectAtIndex: function(index) {
                        return _this.tabList_[index].computeIndicatorClientRect();
                    },
                    getTabDimensionsAtIndex: function(index) {
                        return _this.tabList_[index].computeDimensions();
                    },
                    getPreviousActiveTabIndex: function() {
                        for (var i = 0; i < _this.tabList_.length; i++) {
                            if (_this.tabList_[i].active) {
                                return i;
                            }
                        }
                        return -1;
                    },
                    getFocusedTabIndex: function() {
                        var tabElements = _this.getTabElements_();
                        var activeElement = document.activeElement;
                        return tabElements.indexOf(activeElement);
                    },
                    getIndexOfTabById: function(id) {
                        for (var i = 0; i < _this.tabList_.length; i++) {
                            if (_this.tabList_[i].id === id) {
                                return i;
                            }
                        }
                        return -1;
                    },
                    getTabListLength: function() {
                        return _this.tabList_.length;
                    },
                    notifyTabActivated: function(index) {
                        return _this.emit(tab_bar_component_strings.TAB_ACTIVATED_EVENT, {
                            index: index
                        }, true);
                    }
                };
                return new MDCTabBarFoundation(adapter);
            };
            MDCTabBar.prototype.activateTab = function(index) {
                this.foundation.activateTab(index);
            };
            MDCTabBar.prototype.scrollIntoView = function(index) {
                this.foundation.scrollIntoView(index);
            };
            MDCTabBar.prototype.getTabElements_ = function() {
                return [].slice.call(this.root.querySelectorAll(tab_bar_component_strings.TAB_SELECTOR));
            };
            MDCTabBar.prototype.instantiateTabs_ = function(tabFactory) {
                return this.getTabElements_().map((function(el) {
                    el.id = el.id || "mdc-tab-" + ++tabIdCounter;
                    return tabFactory(el);
                }));
            };
            MDCTabBar.prototype.instantiateTabScroller_ = function(tabScrollerFactory) {
                var tabScrollerElement = this.root.querySelector(tab_bar_component_strings.TAB_SCROLLER_SELECTOR);
                if (tabScrollerElement) {
                    return tabScrollerFactory(tabScrollerElement);
                }
                return null;
            };
            return MDCTabBar;
        }(MDCComponent);
        function MBTabBar_init(elem, dotNetObject) {
            elem._tabBar = MDCTabBar.attachTo(elem);
            elem._callback = function() {
                var index = elem._tabBar.foundation.adapter.getFocusedTabIndex();
                dotNetObject.invokeMethodAsync("NotifyActivated", index);
            };
            elem._tabBar.listen("MDCTabBar:activated", elem._callback);
        }
        function activateTab(elem, index) {
            elem._tabBar.unlisten("MDCTabBar:activated", elem._callback);
            elem._tabBar.activateTab(index);
            elem._tabBar.listen("MDCTabBar:activated", elem._callback);
        }
        function MBTextField_init(elem, helperTextElem, helperText, helperTextPersistent, performsValidation) {
            elem._textField = MDCTextField.attachTo(elem);
            setHelperText(elem, helperTextElem, helperText, helperTextPersistent, performsValidation, false, "");
        }
        function MBTextField_setValue(elem, value) {
            elem._textField.value = value;
        }
        function MBTextField_setDisabled(elem, value) {
            elem._textField.disabled = value;
        }
        function setHelperText(elem, helperTextElem, helperText, helperTextPersistent, performsValidation, shakeLabel, validationMessage) {
            if (!elem || !helperTextElem) {
                return;
            }
            if (helperText !== "" || performsValidation === true) {
                if (!elem._helperText) {
                    elem._helperText = MDCTextFieldHelperText.attachTo(helperTextElem);
                }
                if (validationMessage !== "") {
                    elem._helperText.root.innerHTML = sanitizeHTMLWithBreaks(validationMessage);
                    elem._helperText.foundation.setPersistent(true);
                    elem._helperText.foundation.setValidation(true);
                    elem._helperText.foundation.setValidity(false);
                    elem._textField.foundation.setValid(false);
                    if (shakeLabel) {
                        elem._textField.foundation.adapter.shakeLabel(true);
                    }
                } else if (helperText !== "") {
                    elem._helperText.foundation.setContent(helperText);
                    elem._helperText.foundation.setPersistent(helperTextPersistent);
                    elem._helperText.foundation.setValidation(false);
                    elem._helperText.foundation.setValidity(true);
                    elem._textField.foundation.setValid(true);
                } else {
                    elem._helperText.foundation.setContent("");
                    elem._helperText.foundation.setPersistent(false);
                    elem._helperText.foundation.setValidation(false);
                    elem._helperText.foundation.setValidity(true);
                    elem._textField.foundation.setValid(true);
                }
            }
        }
        function setType(elem, value, inputElem, type, formNoValidate) {
            if (elem && inputElem) {
                inputElem.setAttribute("type", type);
                inputElem.setAttribute("formnovalidate", formNoValidate);
                elem._textField.value = value;
                if (formNoValidate) {
                    inputElem.focus();
                    inputElem.select();
                }
            }
        }
        /*!
 * Sanitize and encode all HTML in a user-submitted string
 * (c) 2018 Chris Ferdinandi, MIT License, https://gomakethings.com
 * @param  {String} str  The user-submitted string
 * @return {String} str  The sanitized string
 */        function sanitizeHTMLWithBreaks(str) {
            var tempDiv = document.createElement("div");
            tempDiv.textContent = str;
            var sanitized = tempDiv.innerHTML;
            tempDiv.remove();
            return sanitized.replace(new RegExp(escapeRegExp("&lt;br /&gt;"), "g"), "<br />");
        }
        function escapeRegExp(str) {
            return str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
        }
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var CssClasses;
        (function(CssClasses) {
            CssClasses["RICH"] = "mdc-tooltip--rich";
            CssClasses["SHOWN"] = "mdc-tooltip--shown";
            CssClasses["SHOWING"] = "mdc-tooltip--showing";
            CssClasses["SHOWING_TRANSITION"] = "mdc-tooltip--showing-transition";
            CssClasses["HIDE"] = "mdc-tooltip--hide";
            CssClasses["HIDE_TRANSITION"] = "mdc-tooltip--hide-transition";
            CssClasses["MULTILINE_TOOLTIP"] = "mdc-tooltip--multiline";
        })(CssClasses || (CssClasses = {}));
        var tooltip_constants_numbers = {
            BOUNDED_ANCHOR_GAP: 4,
            UNBOUNDED_ANCHOR_GAP: 8,
            MIN_VIEWPORT_TOOLTIP_THRESHOLD: 8,
            HIDE_DELAY_MS: 600,
            SHOW_DELAY_MS: 500,
            MIN_HEIGHT: 24,
            MAX_WIDTH: 200
        };
        var tooltip_constants_attributes = {
            ARIA_EXPANDED: "aria-expanded",
            ARIA_HASPOPUP: "aria-haspopup",
            PERSISTENT: "data-mdc-tooltip-persistent"
        };
        var tooltip_constants_events = {
            HIDDEN: "MDCTooltip:hidden"
        };
        var XPosition;
        (function(XPosition) {
            XPosition[XPosition["DETECTED"] = 0] = "DETECTED";
            XPosition[XPosition["START"] = 1] = "START";
            XPosition[XPosition["CENTER"] = 2] = "CENTER";
            XPosition[XPosition["END"] = 3] = "END";
        })(XPosition || (XPosition = {}));
        var YPosition;
        (function(YPosition) {
            YPosition[YPosition["DETECTED"] = 0] = "DETECTED";
            YPosition[YPosition["ABOVE"] = 1] = "ABOVE";
            YPosition[YPosition["BELOW"] = 2] = "BELOW";
        })(YPosition || (YPosition = {}));
        var AnchorBoundaryType;
        (function(AnchorBoundaryType) {
            AnchorBoundaryType[AnchorBoundaryType["BOUNDED"] = 0] = "BOUNDED";
            AnchorBoundaryType[AnchorBoundaryType["UNBOUNDED"] = 1] = "UNBOUNDED";
        })(AnchorBoundaryType || (AnchorBoundaryType = {}));
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var AnimationFrame = function() {
            function AnimationFrame() {
                this.rafIDs = new Map;
            }
            AnimationFrame.prototype.request = function(key, callback) {
                var _this = this;
                this.cancel(key);
                var frameID = requestAnimationFrame((function(frame) {
                    _this.rafIDs.delete(key);
                    callback(frame);
                }));
                this.rafIDs.set(key, frameID);
            };
            AnimationFrame.prototype.cancel = function(key) {
                var rafID = this.rafIDs.get(key);
                if (rafID) {
                    cancelAnimationFrame(rafID);
                    this.rafIDs.delete(key);
                }
            };
            AnimationFrame.prototype.cancelAll = function() {
                var _this = this;
                this.rafIDs.forEach((function(_, key) {
                    _this.cancel(key);
                }));
            };
            AnimationFrame.prototype.getQueue = function() {
                var queue = [];
                this.rafIDs.forEach((function(_, key) {
                    queue.push(key);
                }));
                return queue;
            };
            return AnimationFrame;
        }();
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var RICH = CssClasses.RICH, SHOWN = CssClasses.SHOWN, SHOWING = CssClasses.SHOWING, SHOWING_TRANSITION = CssClasses.SHOWING_TRANSITION, HIDE = CssClasses.HIDE, HIDE_TRANSITION = CssClasses.HIDE_TRANSITION, MULTILINE_TOOLTIP = CssClasses.MULTILINE_TOOLTIP;
        var AnimationKeys;
        (function(AnimationKeys) {
            AnimationKeys["POLL_ANCHOR"] = "poll_anchor";
        })(AnimationKeys || (AnimationKeys = {}));
        var MDCTooltipFoundation = function(_super) {
            __extends(MDCTooltipFoundation, _super);
            function MDCTooltipFoundation(adapter) {
                var _this = _super.call(this, __assign(__assign({}, MDCTooltipFoundation.defaultAdapter), adapter)) || this;
                _this.isShown = false;
                _this.anchorGap = tooltip_constants_numbers.BOUNDED_ANCHOR_GAP;
                _this.xTooltipPos = XPosition.DETECTED;
                _this.yTooltipPos = YPosition.DETECTED;
                _this.minViewportTooltipThreshold = tooltip_constants_numbers.MIN_VIEWPORT_TOOLTIP_THRESHOLD;
                _this.hideDelayMs = tooltip_constants_numbers.HIDE_DELAY_MS;
                _this.showDelayMs = tooltip_constants_numbers.SHOW_DELAY_MS;
                _this.anchorRect = null;
                _this.frameId = null;
                _this.hideTimeout = null;
                _this.showTimeout = null;
                _this.animFrame = new AnimationFrame;
                _this.documentClickHandler = function(evt) {
                    _this.handleDocumentClick(evt);
                };
                _this.documentKeydownHandler = function(evt) {
                    _this.handleKeydown(evt);
                };
                _this.richTooltipMouseEnterHandler = function() {
                    _this.handleRichTooltipMouseEnter();
                };
                _this.richTooltipMouseLeaveHandler = function() {
                    _this.handleRichTooltipMouseLeave();
                };
                _this.richTooltipFocusOutHandler = function(evt) {
                    _this.handleRichTooltipFocusOut(evt);
                };
                _this.windowScrollHandler = function() {
                    _this.handleWindowChangeEvent();
                };
                _this.windowResizeHandler = function() {
                    _this.handleWindowChangeEvent();
                };
                return _this;
            }
            Object.defineProperty(MDCTooltipFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        getAttribute: function() {
                            return null;
                        },
                        setAttribute: function() {
                            return undefined;
                        },
                        addClass: function() {
                            return undefined;
                        },
                        hasClass: function() {
                            return false;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        setStyleProperty: function() {
                            return undefined;
                        },
                        getViewportWidth: function() {
                            return 0;
                        },
                        getViewportHeight: function() {
                            return 0;
                        },
                        getTooltipSize: function() {
                            return {
                                width: 0,
                                height: 0
                            };
                        },
                        getAnchorBoundingRect: function() {
                            return {
                                top: 0,
                                right: 0,
                                bottom: 0,
                                left: 0,
                                width: 0,
                                height: 0
                            };
                        },
                        getAnchorAttribute: function() {
                            return null;
                        },
                        setAnchorAttribute: function() {
                            return null;
                        },
                        isRTL: function() {
                            return false;
                        },
                        anchorContainsElement: function() {
                            return false;
                        },
                        tooltipContainsElement: function() {
                            return false;
                        },
                        focusAnchorElement: function() {
                            return undefined;
                        },
                        registerEventHandler: function() {
                            return undefined;
                        },
                        deregisterEventHandler: function() {
                            return undefined;
                        },
                        registerDocumentEventHandler: function() {
                            return undefined;
                        },
                        deregisterDocumentEventHandler: function() {
                            return undefined;
                        },
                        registerWindowEventHandler: function() {
                            return undefined;
                        },
                        deregisterWindowEventHandler: function() {
                            return undefined;
                        },
                        notifyHidden: function() {
                            return undefined;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCTooltipFoundation.prototype.init = function() {
                this.isRich = this.adapter.hasClass(RICH);
                this.isPersistent = this.adapter.getAttribute(tooltip_constants_attributes.PERSISTENT) === "true";
                this.isInteractive = !!this.adapter.getAnchorAttribute(tooltip_constants_attributes.ARIA_EXPANDED) && this.adapter.getAnchorAttribute(tooltip_constants_attributes.ARIA_HASPOPUP) === "true";
            };
            MDCTooltipFoundation.prototype.getIsRich = function() {
                return this.isRich;
            };
            MDCTooltipFoundation.prototype.getIsPersistent = function() {
                return this.isPersistent;
            };
            MDCTooltipFoundation.prototype.handleAnchorMouseEnter = function() {
                var _this = this;
                if (this.isShown) {
                    this.show();
                } else {
                    this.showTimeout = setTimeout((function() {
                        _this.show();
                    }), this.showDelayMs);
                }
            };
            MDCTooltipFoundation.prototype.handleAnchorFocus = function(evt) {
                var _this = this;
                var relatedTarget = evt.relatedTarget;
                var tooltipContainsRelatedTarget = relatedTarget instanceof HTMLElement && this.adapter.tooltipContainsElement(relatedTarget);
                if (tooltipContainsRelatedTarget) {
                    return;
                }
                this.showTimeout = setTimeout((function() {
                    _this.show();
                }), this.showDelayMs);
            };
            MDCTooltipFoundation.prototype.handleAnchorMouseLeave = function() {
                var _this = this;
                this.clearShowTimeout();
                this.hideTimeout = setTimeout((function() {
                    _this.hide();
                }), this.hideDelayMs);
            };
            MDCTooltipFoundation.prototype.handleAnchorBlur = function(evt) {
                if (this.isRich) {
                    var tooltipContainsRelatedTargetElement = evt.relatedTarget instanceof HTMLElement && this.adapter.tooltipContainsElement(evt.relatedTarget);
                    if (tooltipContainsRelatedTargetElement) {
                        return;
                    }
                }
                this.hide();
            };
            MDCTooltipFoundation.prototype.handleAnchorClick = function() {
                if (this.isShown) {
                    this.hide();
                } else {
                    this.show();
                }
            };
            MDCTooltipFoundation.prototype.handleDocumentClick = function(evt) {
                var anchorOrTooltipContainsTargetElement = evt.target instanceof HTMLElement && (this.adapter.anchorContainsElement(evt.target) || this.adapter.tooltipContainsElement(evt.target));
                if (this.isRich && this.isPersistent && anchorOrTooltipContainsTargetElement) {
                    return;
                }
                this.hide();
            };
            MDCTooltipFoundation.prototype.handleKeydown = function(evt) {
                var key = normalizeKey(evt);
                if (key === KEY.ESCAPE) {
                    var tooltipContainsActiveElement = document.activeElement instanceof HTMLElement && this.adapter.tooltipContainsElement(document.activeElement);
                    if (tooltipContainsActiveElement) {
                        this.adapter.focusAnchorElement();
                    }
                    this.hide();
                }
            };
            MDCTooltipFoundation.prototype.handleRichTooltipMouseEnter = function() {
                this.show();
            };
            MDCTooltipFoundation.prototype.handleRichTooltipMouseLeave = function() {
                var _this = this;
                this.clearShowTimeout();
                this.hideTimeout = setTimeout((function() {
                    _this.hide();
                }), this.hideDelayMs);
            };
            MDCTooltipFoundation.prototype.handleRichTooltipFocusOut = function(evt) {
                var anchorOrTooltipContainsRelatedTargetElement = evt.relatedTarget instanceof HTMLElement && (this.adapter.anchorContainsElement(evt.relatedTarget) || this.adapter.tooltipContainsElement(evt.relatedTarget));
                if (anchorOrTooltipContainsRelatedTargetElement) {
                    return;
                }
                this.hide();
            };
            MDCTooltipFoundation.prototype.handleWindowChangeEvent = function() {
                var _this = this;
                this.animFrame.request(AnimationKeys.POLL_ANCHOR, (function() {
                    _this.repositionTooltipOnAnchorMove();
                }));
            };
            MDCTooltipFoundation.prototype.show = function() {
                var _this = this;
                this.clearHideTimeout();
                this.clearShowTimeout();
                if (this.isShown) {
                    return;
                }
                this.isShown = true;
                var showTooltipOptions = this.parseShowTooltipOptions();
                if (!showTooltipOptions.hideFromScreenreader) {
                    this.adapter.setAttribute("aria-hidden", "false");
                }
                if (this.isRich) {
                    if (this.isInteractive) {
                        this.adapter.setAnchorAttribute("aria-expanded", "true");
                    }
                    this.adapter.registerEventHandler("focusout", this.richTooltipFocusOutHandler);
                    if (!this.isPersistent) {
                        this.adapter.registerEventHandler("mouseenter", this.richTooltipMouseEnterHandler);
                        this.adapter.registerEventHandler("mouseleave", this.richTooltipMouseLeaveHandler);
                    }
                }
                this.adapter.removeClass(HIDE);
                this.adapter.addClass(SHOWING);
                if (this.isTooltipMultiline() && !this.isRich) {
                    this.adapter.addClass(MULTILINE_TOOLTIP);
                }
                this.anchorRect = this.adapter.getAnchorBoundingRect();
                this.positionTooltip();
                this.adapter.registerDocumentEventHandler("click", this.documentClickHandler);
                this.adapter.registerDocumentEventHandler("keydown", this.documentKeydownHandler);
                this.adapter.registerWindowEventHandler("scroll", this.windowScrollHandler);
                this.adapter.registerWindowEventHandler("resize", this.windowResizeHandler);
                this.frameId = requestAnimationFrame((function() {
                    _this.clearAllAnimationClasses();
                    _this.adapter.addClass(SHOWN);
                    _this.adapter.addClass(SHOWING_TRANSITION);
                }));
            };
            MDCTooltipFoundation.prototype.hide = function() {
                this.clearHideTimeout();
                this.clearShowTimeout();
                if (!this.isShown) {
                    return;
                }
                if (this.frameId) {
                    cancelAnimationFrame(this.frameId);
                }
                this.isShown = false;
                this.adapter.setAttribute("aria-hidden", "true");
                this.adapter.deregisterEventHandler("focusout", this.richTooltipFocusOutHandler);
                if (this.isRich) {
                    if (this.isInteractive) {
                        this.adapter.setAnchorAttribute("aria-expanded", "false");
                    }
                    if (!this.isPersistent) {
                        this.adapter.deregisterEventHandler("mouseenter", this.richTooltipMouseEnterHandler);
                        this.adapter.deregisterEventHandler("mouseleave", this.richTooltipMouseLeaveHandler);
                    }
                }
                this.clearAllAnimationClasses();
                this.adapter.addClass(HIDE);
                this.adapter.addClass(HIDE_TRANSITION);
                this.adapter.removeClass(SHOWN);
                this.adapter.deregisterDocumentEventHandler("click", this.documentClickHandler);
                this.adapter.deregisterDocumentEventHandler("keydown", this.documentKeydownHandler);
                this.adapter.deregisterWindowEventHandler("scroll", this.windowScrollHandler);
                this.adapter.deregisterWindowEventHandler("resize", this.windowResizeHandler);
            };
            MDCTooltipFoundation.prototype.handleTransitionEnd = function() {
                var isHidingTooltip = this.adapter.hasClass(HIDE);
                this.adapter.removeClass(SHOWING);
                this.adapter.removeClass(SHOWING_TRANSITION);
                this.adapter.removeClass(HIDE);
                this.adapter.removeClass(HIDE_TRANSITION);
                if (isHidingTooltip) {
                    this.adapter.notifyHidden();
                }
            };
            MDCTooltipFoundation.prototype.clearAllAnimationClasses = function() {
                this.adapter.removeClass(SHOWING_TRANSITION);
                this.adapter.removeClass(HIDE_TRANSITION);
            };
            MDCTooltipFoundation.prototype.setTooltipPosition = function(position) {
                var xPos = position.xPos, yPos = position.yPos;
                if (xPos) {
                    this.xTooltipPos = xPos;
                }
                if (yPos) {
                    this.yTooltipPos = yPos;
                }
            };
            MDCTooltipFoundation.prototype.setAnchorBoundaryType = function(type) {
                if (type === AnchorBoundaryType.UNBOUNDED) {
                    this.anchorGap = tooltip_constants_numbers.UNBOUNDED_ANCHOR_GAP;
                } else {
                    this.anchorGap = tooltip_constants_numbers.BOUNDED_ANCHOR_GAP;
                }
            };
            MDCTooltipFoundation.prototype.parseShowTooltipOptions = function() {
                var hideFromScreenreader = Boolean(this.adapter.getAnchorAttribute("data-tooltip-id"));
                return {
                    hideFromScreenreader: hideFromScreenreader
                };
            };
            MDCTooltipFoundation.prototype.isTooltipMultiline = function() {
                var tooltipSize = this.adapter.getTooltipSize();
                return tooltipSize.height > tooltip_constants_numbers.MIN_HEIGHT && tooltipSize.width >= tooltip_constants_numbers.MAX_WIDTH;
            };
            MDCTooltipFoundation.prototype.positionTooltip = function() {
                var _a = this.calculateTooltipDistance(this.anchorRect), top = _a.top, left = _a.left;
                this.adapter.setStyleProperty("top", top + "px");
                this.adapter.setStyleProperty("left", left + "px");
            };
            MDCTooltipFoundation.prototype.calculateTooltipDistance = function(anchorRect) {
                if (!anchorRect) {
                    return {
                        top: 0,
                        left: 0
                    };
                }
                var tooltipSize = this.adapter.getTooltipSize();
                var top = this.calculateYTooltipDistance(anchorRect, tooltipSize.height);
                var left = this.calculateXTooltipDistance(anchorRect, tooltipSize.width);
                return {
                    top: top,
                    left: left
                };
            };
            MDCTooltipFoundation.prototype.calculateXTooltipDistance = function(anchorRect, tooltipWidth) {
                var isLTR = !this.adapter.isRTL();
                var startPos, endPos, centerPos;
                if (this.isRich) {
                    startPos = isLTR ? anchorRect.left - tooltipWidth : anchorRect.right;
                    endPos = isLTR ? anchorRect.right : anchorRect.left - tooltipWidth;
                } else {
                    startPos = isLTR ? anchorRect.left : anchorRect.right - tooltipWidth;
                    endPos = isLTR ? anchorRect.right - tooltipWidth : anchorRect.left;
                    centerPos = anchorRect.left + (anchorRect.width - tooltipWidth) / 2;
                }
                var positionOptions = this.isRich ? this.determineValidPositionOptions(startPos, endPos) : this.determineValidPositionOptions(centerPos, startPos, endPos);
                if (this.xTooltipPos === XPosition.START && positionOptions.has(startPos)) {
                    return startPos;
                }
                if (this.xTooltipPos === XPosition.END && positionOptions.has(endPos)) {
                    return endPos;
                }
                if (this.xTooltipPos === XPosition.CENTER && positionOptions.has(centerPos)) {
                    return centerPos;
                }
                var possiblePositions = this.isRich ? [ endPos, startPos ] : [ centerPos, startPos, endPos ];
                var validPosition = possiblePositions.find((function(pos) {
                    return positionOptions.has(pos);
                }));
                if (validPosition) {
                    return validPosition;
                }
                if (anchorRect.left < 0) {
                    return this.minViewportTooltipThreshold;
                } else {
                    var viewportWidth = this.adapter.getViewportWidth();
                    return viewportWidth - (tooltipWidth + this.minViewportTooltipThreshold);
                }
            };
            MDCTooltipFoundation.prototype.determineValidPositionOptions = function() {
                var e_1, _a;
                var positions = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    positions[_i] = arguments[_i];
                }
                var posWithinThreshold = new Set;
                var posWithinViewport = new Set;
                try {
                    for (var positions_1 = __values(positions), positions_1_1 = positions_1.next(); !positions_1_1.done; positions_1_1 = positions_1.next()) {
                        var position = positions_1_1.value;
                        if (this.positionHonorsViewportThreshold(position)) {
                            posWithinThreshold.add(position);
                        } else if (this.positionDoesntCollideWithViewport(position)) {
                            posWithinViewport.add(position);
                        }
                    }
                } catch (e_1_1) {
                    e_1 = {
                        error: e_1_1
                    };
                } finally {
                    try {
                        if (positions_1_1 && !positions_1_1.done && (_a = positions_1.return)) _a.call(positions_1);
                    } finally {
                        if (e_1) throw e_1.error;
                    }
                }
                return posWithinThreshold.size ? posWithinThreshold : posWithinViewport;
            };
            MDCTooltipFoundation.prototype.positionHonorsViewportThreshold = function(leftPos) {
                var viewportWidth = this.adapter.getViewportWidth();
                var tooltipWidth = this.adapter.getTooltipSize().width;
                return leftPos + tooltipWidth <= viewportWidth - this.minViewportTooltipThreshold && leftPos >= this.minViewportTooltipThreshold;
            };
            MDCTooltipFoundation.prototype.positionDoesntCollideWithViewport = function(leftPos) {
                var viewportWidth = this.adapter.getViewportWidth();
                var tooltipWidth = this.adapter.getTooltipSize().width;
                return leftPos + tooltipWidth <= viewportWidth && leftPos >= 0;
            };
            MDCTooltipFoundation.prototype.calculateYTooltipDistance = function(anchorRect, tooltipHeight) {
                var belowYPos = anchorRect.bottom + this.anchorGap;
                var aboveYPos = anchorRect.top - (this.anchorGap + tooltipHeight);
                var yPositionOptions = this.determineValidYPositionOptions(aboveYPos, belowYPos);
                if (this.yTooltipPos === YPosition.ABOVE && yPositionOptions.has(aboveYPos)) {
                    return aboveYPos;
                } else if (this.yTooltipPos === YPosition.BELOW && yPositionOptions.has(belowYPos)) {
                    return belowYPos;
                }
                if (yPositionOptions.has(belowYPos)) {
                    return belowYPos;
                }
                if (yPositionOptions.has(aboveYPos)) {
                    return aboveYPos;
                }
                return belowYPos;
            };
            MDCTooltipFoundation.prototype.determineValidYPositionOptions = function(aboveAnchorPos, belowAnchorPos) {
                var posWithinThreshold = new Set;
                var posWithinViewport = new Set;
                if (this.yPositionHonorsViewportThreshold(aboveAnchorPos)) {
                    posWithinThreshold.add(aboveAnchorPos);
                } else if (this.yPositionDoesntCollideWithViewport(aboveAnchorPos)) {
                    posWithinViewport.add(aboveAnchorPos);
                }
                if (this.yPositionHonorsViewportThreshold(belowAnchorPos)) {
                    posWithinThreshold.add(belowAnchorPos);
                } else if (this.yPositionDoesntCollideWithViewport(belowAnchorPos)) {
                    posWithinViewport.add(belowAnchorPos);
                }
                return posWithinThreshold.size ? posWithinThreshold : posWithinViewport;
            };
            MDCTooltipFoundation.prototype.yPositionHonorsViewportThreshold = function(yPos) {
                var viewportHeight = this.adapter.getViewportHeight();
                var tooltipHeight = this.adapter.getTooltipSize().height;
                return yPos + tooltipHeight + this.minViewportTooltipThreshold <= viewportHeight && yPos >= this.minViewportTooltipThreshold;
            };
            MDCTooltipFoundation.prototype.yPositionDoesntCollideWithViewport = function(yPos) {
                var viewportHeight = this.adapter.getViewportHeight();
                var tooltipHeight = this.adapter.getTooltipSize().height;
                return yPos + tooltipHeight <= viewportHeight && yPos >= 0;
            };
            MDCTooltipFoundation.prototype.repositionTooltipOnAnchorMove = function() {
                var newAnchorRect = this.adapter.getAnchorBoundingRect();
                if (!newAnchorRect || !this.anchorRect) return;
                if (newAnchorRect.top !== this.anchorRect.top || newAnchorRect.left !== this.anchorRect.left || newAnchorRect.height !== this.anchorRect.height || newAnchorRect.width !== this.anchorRect.width) {
                    this.anchorRect = newAnchorRect;
                    this.positionTooltip();
                }
            };
            MDCTooltipFoundation.prototype.clearShowTimeout = function() {
                if (this.showTimeout) {
                    clearTimeout(this.showTimeout);
                    this.showTimeout = null;
                }
            };
            MDCTooltipFoundation.prototype.clearHideTimeout = function() {
                if (this.hideTimeout) {
                    clearTimeout(this.hideTimeout);
                    this.hideTimeout = null;
                }
            };
            MDCTooltipFoundation.prototype.destroy = function() {
                if (this.frameId) {
                    cancelAnimationFrame(this.frameId);
                    this.frameId = null;
                }
                this.clearHideTimeout();
                this.clearShowTimeout();
                this.adapter.removeClass(SHOWN);
                this.adapter.removeClass(SHOWING_TRANSITION);
                this.adapter.removeClass(SHOWING);
                this.adapter.removeClass(HIDE);
                this.adapter.removeClass(HIDE_TRANSITION);
                if (this.isRich) {
                    this.adapter.deregisterEventHandler("focusout", this.richTooltipFocusOutHandler);
                    if (!this.isPersistent) {
                        this.adapter.deregisterEventHandler("mouseenter", this.richTooltipMouseEnterHandler);
                        this.adapter.deregisterEventHandler("mouseleave", this.richTooltipMouseLeaveHandler);
                    }
                }
                this.adapter.deregisterDocumentEventHandler("click", this.documentClickHandler);
                this.adapter.deregisterDocumentEventHandler("keydown", this.documentKeydownHandler);
                this.adapter.deregisterWindowEventHandler("scroll", this.windowScrollHandler);
                this.adapter.deregisterWindowEventHandler("resize", this.windowResizeHandler);
                this.animFrame.cancelAll();
            };
            return MDCTooltipFoundation;
        }(MDCFoundation);
        const tooltip_foundation = null && MDCTooltipFoundation;
        /**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCTooltip = function(_super) {
            __extends(MDCTooltip, _super);
            function MDCTooltip() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCTooltip.attachTo = function(root) {
                return new MDCTooltip(root);
            };
            MDCTooltip.prototype.initialize = function() {
                var tooltipId = this.root.getAttribute("id");
                if (!tooltipId) {
                    throw new Error("MDCTooltip: Tooltip component must have an id.");
                }
                var anchorElem = document.querySelector('[aria-describedby="' + tooltipId + '"]') || document.querySelector('[data-tooltip-id="' + tooltipId + '"]');
                if (!anchorElem) {
                    throw new Error("MDCTooltip: Tooltip component requires an anchor element annotated with [aria-describedby] or [data-tooltip-id] anchor element.");
                }
                this.anchorElem = anchorElem;
            };
            MDCTooltip.prototype.initialSyncWithDOM = function() {
                var _this = this;
                this.isTooltipRich = this.foundation.getIsRich();
                this.isTooltipPersistent = this.foundation.getIsPersistent();
                this.handleMouseEnter = function() {
                    _this.foundation.handleAnchorMouseEnter();
                };
                this.handleFocus = function(evt) {
                    _this.foundation.handleAnchorFocus(evt);
                };
                this.handleMouseLeave = function() {
                    _this.foundation.handleAnchorMouseLeave();
                };
                this.handleBlur = function(evt) {
                    _this.foundation.handleAnchorBlur(evt);
                };
                this.handleTransitionEnd = function() {
                    _this.foundation.handleTransitionEnd();
                };
                this.handleClick = function() {
                    _this.foundation.handleAnchorClick();
                };
                this.anchorElem.addEventListener("blur", this.handleBlur);
                if (this.isTooltipRich && this.isTooltipPersistent) {
                    this.anchorElem.addEventListener("click", this.handleClick);
                } else {
                    this.anchorElem.addEventListener("mouseenter", this.handleMouseEnter);
                    this.anchorElem.addEventListener("focus", this.handleFocus);
                    this.anchorElem.addEventListener("mouseleave", this.handleMouseLeave);
                }
                this.listen("transitionend", this.handleTransitionEnd);
            };
            MDCTooltip.prototype.destroy = function() {
                if (this.anchorElem) {
                    this.anchorElem.removeEventListener("blur", this.handleBlur);
                    if (this.isTooltipRich && this.isTooltipPersistent) {
                        this.anchorElem.removeEventListener("click", this.handleClick);
                    } else {
                        this.anchorElem.removeEventListener("mouseenter", this.handleMouseEnter);
                        this.anchorElem.removeEventListener("focus", this.handleFocus);
                        this.anchorElem.removeEventListener("mouseleave", this.handleMouseLeave);
                    }
                }
                this.unlisten("transitionend", this.handleTransitionEnd);
                _super.prototype.destroy.call(this);
            };
            MDCTooltip.prototype.setTooltipPosition = function(position) {
                this.foundation.setTooltipPosition(position);
            };
            MDCTooltip.prototype.setAnchorBoundaryType = function(type) {
                this.foundation.setAnchorBoundaryType(type);
            };
            MDCTooltip.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    getAttribute: function(attr) {
                        return _this.root.getAttribute(attr);
                    },
                    setAttribute: function(attr, value) {
                        _this.root.setAttribute(attr, value);
                    },
                    addClass: function(className) {
                        _this.root.classList.add(className);
                    },
                    hasClass: function(className) {
                        return _this.root.classList.contains(className);
                    },
                    removeClass: function(className) {
                        _this.root.classList.remove(className);
                    },
                    setStyleProperty: function(propertyName, value) {
                        _this.root.style.setProperty(propertyName, value);
                    },
                    getViewportWidth: function() {
                        return window.innerWidth;
                    },
                    getViewportHeight: function() {
                        return window.innerHeight;
                    },
                    getTooltipSize: function() {
                        return {
                            width: _this.root.offsetWidth,
                            height: _this.root.offsetHeight
                        };
                    },
                    getAnchorBoundingRect: function() {
                        return _this.anchorElem ? _this.anchorElem.getBoundingClientRect() : null;
                    },
                    getAnchorAttribute: function(attr) {
                        return _this.anchorElem ? _this.anchorElem.getAttribute(attr) : null;
                    },
                    setAnchorAttribute: function(attr, value) {
                        var _a;
                        (_a = _this.anchorElem) === null || _a === void 0 ? void 0 : _a.setAttribute(attr, value);
                    },
                    isRTL: function() {
                        return getComputedStyle(_this.root).direction === "rtl";
                    },
                    anchorContainsElement: function(element) {
                        var _a;
                        return !!((_a = _this.anchorElem) === null || _a === void 0 ? void 0 : _a.contains(element));
                    },
                    tooltipContainsElement: function(element) {
                        return _this.root.contains(element);
                    },
                    focusAnchorElement: function() {
                        var _a;
                        (_a = _this.anchorElem) === null || _a === void 0 ? void 0 : _a.focus();
                    },
                    registerEventHandler: function(evt, handler) {
                        if (_this.root instanceof HTMLElement) {
                            _this.root.addEventListener(evt, handler);
                        }
                    },
                    deregisterEventHandler: function(evt, handler) {
                        if (_this.root instanceof HTMLElement) {
                            _this.root.removeEventListener(evt, handler);
                        }
                    },
                    registerDocumentEventHandler: function(evt, handler) {
                        document.body.addEventListener(evt, handler);
                    },
                    deregisterDocumentEventHandler: function(evt, handler) {
                        document.body.removeEventListener(evt, handler);
                    },
                    registerWindowEventHandler: function(evt, handler) {
                        window.addEventListener(evt, handler);
                    },
                    deregisterWindowEventHandler: function(evt, handler) {
                        window.removeEventListener(evt, handler);
                    },
                    notifyHidden: function() {
                        _this.emit(tooltip_constants_events.HIDDEN, {});
                    }
                };
                return new MDCTooltipFoundation(adapter);
            };
            return MDCTooltip;
        }(MDCComponent);
        function _createForOfIteratorHelper(o, allowArrayLike) {
            var it;
            if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it) o = it;
                    var i = 0;
                    var F = function F() {};
                    return {
                        s: F,
                        n: function n() {
                            if (i >= o.length) return {
                                done: true
                            };
                            return {
                                done: false,
                                value: o[i++]
                            };
                        },
                        e: function e(_e) {
                            throw _e;
                        },
                        f: F
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var normalCompletion = true, didErr = false, err;
            return {
                s: function s() {
                    it = o[Symbol.iterator]();
                },
                n: function n() {
                    var step = it.next();
                    normalCompletion = step.done;
                    return step;
                },
                e: function e(_e2) {
                    didErr = true;
                    err = _e2;
                },
                f: function f() {
                    try {
                        if (!normalCompletion && it["return"] != null) it["return"]();
                    } finally {
                        if (didErr) throw err;
                    }
                }
            };
        }
        function _unsupportedIterableToArray(o, minLen) {
            if (!o) return;
            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor) n = o.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;
            for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
            }
            return arr2;
        }
        function MBTooltip_init(arrayOfReferences) {
            var _iterator = _createForOfIteratorHelper(arrayOfReferences), _step;
            try {
                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                    var elem = _step.value;
                    try {
                        MDCTooltip.attachTo(elem);
                    } catch (e) {}
                }
            } catch (err) {
                _iterator.e(err);
            } finally {
                _iterator.f();
            }
        }
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var top_app_bar_constants_cssClasses = {
            FIXED_CLASS: "mdc-top-app-bar--fixed",
            FIXED_SCROLLED_CLASS: "mdc-top-app-bar--fixed-scrolled",
            SHORT_CLASS: "mdc-top-app-bar--short",
            SHORT_COLLAPSED_CLASS: "mdc-top-app-bar--short-collapsed",
            SHORT_HAS_ACTION_ITEM_CLASS: "mdc-top-app-bar--short-has-action-item"
        };
        var top_app_bar_constants_numbers = {
            DEBOUNCE_THROTTLE_RESIZE_TIME_MS: 100,
            MAX_TOP_APP_BAR_HEIGHT: 128
        };
        var top_app_bar_constants_strings = {
            ACTION_ITEM_SELECTOR: ".mdc-top-app-bar__action-item",
            NAVIGATION_EVENT: "MDCTopAppBar:nav",
            NAVIGATION_ICON_SELECTOR: ".mdc-top-app-bar__navigation-icon",
            ROOT_SELECTOR: ".mdc-top-app-bar",
            TITLE_SELECTOR: ".mdc-top-app-bar__title"
        };
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCTopAppBarBaseFoundation = function(_super) {
            __extends(MDCTopAppBarBaseFoundation, _super);
            function MDCTopAppBarBaseFoundation(adapter) {
                return _super.call(this, __assign(__assign({}, MDCTopAppBarBaseFoundation.defaultAdapter), adapter)) || this;
            }
            Object.defineProperty(MDCTopAppBarBaseFoundation, "strings", {
                get: function() {
                    return top_app_bar_constants_strings;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTopAppBarBaseFoundation, "cssClasses", {
                get: function() {
                    return top_app_bar_constants_cssClasses;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTopAppBarBaseFoundation, "numbers", {
                get: function() {
                    return top_app_bar_constants_numbers;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MDCTopAppBarBaseFoundation, "defaultAdapter", {
                get: function() {
                    return {
                        addClass: function() {
                            return undefined;
                        },
                        removeClass: function() {
                            return undefined;
                        },
                        hasClass: function() {
                            return false;
                        },
                        setStyle: function() {
                            return undefined;
                        },
                        getTopAppBarHeight: function() {
                            return 0;
                        },
                        notifyNavigationIconClicked: function() {
                            return undefined;
                        },
                        getViewportScrollY: function() {
                            return 0;
                        },
                        getTotalActionItems: function() {
                            return 0;
                        }
                    };
                },
                enumerable: true,
                configurable: true
            });
            MDCTopAppBarBaseFoundation.prototype.handleTargetScroll = function() {};
            MDCTopAppBarBaseFoundation.prototype.handleWindowResize = function() {};
            MDCTopAppBarBaseFoundation.prototype.handleNavigationClick = function() {
                this.adapter.notifyNavigationIconClicked();
            };
            return MDCTopAppBarBaseFoundation;
        }(MDCFoundation);
        const top_app_bar_foundation = null && MDCTopAppBarBaseFoundation;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var INITIAL_VALUE = 0;
        var MDCTopAppBarFoundation = function(_super) {
            __extends(MDCTopAppBarFoundation, _super);
            function MDCTopAppBarFoundation(adapter) {
                var _this = _super.call(this, adapter) || this;
                _this.wasDocked_ = true;
                _this.isDockedShowing_ = true;
                _this.currentAppBarOffsetTop_ = 0;
                _this.isCurrentlyBeingResized_ = false;
                _this.resizeThrottleId_ = INITIAL_VALUE;
                _this.resizeDebounceId_ = INITIAL_VALUE;
                _this.lastScrollPosition_ = _this.adapter.getViewportScrollY();
                _this.topAppBarHeight_ = _this.adapter.getTopAppBarHeight();
                return _this;
            }
            MDCTopAppBarFoundation.prototype.destroy = function() {
                _super.prototype.destroy.call(this);
                this.adapter.setStyle("top", "");
            };
            MDCTopAppBarFoundation.prototype.handleTargetScroll = function() {
                var currentScrollPosition = Math.max(this.adapter.getViewportScrollY(), 0);
                var diff = currentScrollPosition - this.lastScrollPosition_;
                this.lastScrollPosition_ = currentScrollPosition;
                if (!this.isCurrentlyBeingResized_) {
                    this.currentAppBarOffsetTop_ -= diff;
                    if (this.currentAppBarOffsetTop_ > 0) {
                        this.currentAppBarOffsetTop_ = 0;
                    } else if (Math.abs(this.currentAppBarOffsetTop_) > this.topAppBarHeight_) {
                        this.currentAppBarOffsetTop_ = -this.topAppBarHeight_;
                    }
                    this.moveTopAppBar_();
                }
            };
            MDCTopAppBarFoundation.prototype.handleWindowResize = function() {
                var _this = this;
                if (!this.resizeThrottleId_) {
                    this.resizeThrottleId_ = setTimeout((function() {
                        _this.resizeThrottleId_ = INITIAL_VALUE;
                        _this.throttledResizeHandler_();
                    }), top_app_bar_constants_numbers.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
                }
                this.isCurrentlyBeingResized_ = true;
                if (this.resizeDebounceId_) {
                    clearTimeout(this.resizeDebounceId_);
                }
                this.resizeDebounceId_ = setTimeout((function() {
                    _this.handleTargetScroll();
                    _this.isCurrentlyBeingResized_ = false;
                    _this.resizeDebounceId_ = INITIAL_VALUE;
                }), top_app_bar_constants_numbers.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
            };
            MDCTopAppBarFoundation.prototype.checkForUpdate_ = function() {
                var offscreenBoundaryTop = -this.topAppBarHeight_;
                var hasAnyPixelsOffscreen = this.currentAppBarOffsetTop_ < 0;
                var hasAnyPixelsOnscreen = this.currentAppBarOffsetTop_ > offscreenBoundaryTop;
                var partiallyShowing = hasAnyPixelsOffscreen && hasAnyPixelsOnscreen;
                if (partiallyShowing) {
                    this.wasDocked_ = false;
                } else {
                    if (!this.wasDocked_) {
                        this.wasDocked_ = true;
                        return true;
                    } else if (this.isDockedShowing_ !== hasAnyPixelsOnscreen) {
                        this.isDockedShowing_ = hasAnyPixelsOnscreen;
                        return true;
                    }
                }
                return partiallyShowing;
            };
            MDCTopAppBarFoundation.prototype.moveTopAppBar_ = function() {
                if (this.checkForUpdate_()) {
                    var offset = this.currentAppBarOffsetTop_;
                    if (Math.abs(offset) >= this.topAppBarHeight_) {
                        offset = -top_app_bar_constants_numbers.MAX_TOP_APP_BAR_HEIGHT;
                    }
                    this.adapter.setStyle("top", offset + "px");
                }
            };
            MDCTopAppBarFoundation.prototype.throttledResizeHandler_ = function() {
                var currentHeight = this.adapter.getTopAppBarHeight();
                if (this.topAppBarHeight_ !== currentHeight) {
                    this.wasDocked_ = false;
                    this.currentAppBarOffsetTop_ -= this.topAppBarHeight_ - currentHeight;
                    this.topAppBarHeight_ = currentHeight;
                }
                this.handleTargetScroll();
            };
            return MDCTopAppBarFoundation;
        }(MDCTopAppBarBaseFoundation);
        const standard_foundation = null && MDCTopAppBarFoundation;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCFixedTopAppBarFoundation = function(_super) {
            __extends(MDCFixedTopAppBarFoundation, _super);
            function MDCFixedTopAppBarFoundation() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.wasScrolled_ = false;
                return _this;
            }
            MDCFixedTopAppBarFoundation.prototype.handleTargetScroll = function() {
                var currentScroll = this.adapter.getViewportScrollY();
                if (currentScroll <= 0) {
                    if (this.wasScrolled_) {
                        this.adapter.removeClass(top_app_bar_constants_cssClasses.FIXED_SCROLLED_CLASS);
                        this.wasScrolled_ = false;
                    }
                } else {
                    if (!this.wasScrolled_) {
                        this.adapter.addClass(top_app_bar_constants_cssClasses.FIXED_SCROLLED_CLASS);
                        this.wasScrolled_ = true;
                    }
                }
            };
            return MDCFixedTopAppBarFoundation;
        }(MDCTopAppBarFoundation);
        const fixed_foundation = null && MDCFixedTopAppBarFoundation;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCShortTopAppBarFoundation = function(_super) {
            __extends(MDCShortTopAppBarFoundation, _super);
            function MDCShortTopAppBarFoundation(adapter) {
                var _this = _super.call(this, adapter) || this;
                _this.isCollapsed_ = false;
                _this.isAlwaysCollapsed_ = false;
                return _this;
            }
            Object.defineProperty(MDCShortTopAppBarFoundation.prototype, "isCollapsed", {
                get: function() {
                    return this.isCollapsed_;
                },
                enumerable: true,
                configurable: true
            });
            MDCShortTopAppBarFoundation.prototype.init = function() {
                _super.prototype.init.call(this);
                if (this.adapter.getTotalActionItems() > 0) {
                    this.adapter.addClass(top_app_bar_constants_cssClasses.SHORT_HAS_ACTION_ITEM_CLASS);
                }
                this.setAlwaysCollapsed(this.adapter.hasClass(top_app_bar_constants_cssClasses.SHORT_COLLAPSED_CLASS));
            };
            MDCShortTopAppBarFoundation.prototype.setAlwaysCollapsed = function(value) {
                this.isAlwaysCollapsed_ = !!value;
                if (this.isAlwaysCollapsed_) {
                    this.collapse_();
                } else {
                    this.maybeCollapseBar_();
                }
            };
            MDCShortTopAppBarFoundation.prototype.getAlwaysCollapsed = function() {
                return this.isAlwaysCollapsed_;
            };
            MDCShortTopAppBarFoundation.prototype.handleTargetScroll = function() {
                this.maybeCollapseBar_();
            };
            MDCShortTopAppBarFoundation.prototype.maybeCollapseBar_ = function() {
                if (this.isAlwaysCollapsed_) {
                    return;
                }
                var currentScroll = this.adapter.getViewportScrollY();
                if (currentScroll <= 0) {
                    if (this.isCollapsed_) {
                        this.uncollapse_();
                    }
                } else {
                    if (!this.isCollapsed_) {
                        this.collapse_();
                    }
                }
            };
            MDCShortTopAppBarFoundation.prototype.uncollapse_ = function() {
                this.adapter.removeClass(top_app_bar_constants_cssClasses.SHORT_COLLAPSED_CLASS);
                this.isCollapsed_ = false;
            };
            MDCShortTopAppBarFoundation.prototype.collapse_ = function() {
                this.adapter.addClass(top_app_bar_constants_cssClasses.SHORT_COLLAPSED_CLASS);
                this.isCollapsed_ = true;
            };
            return MDCShortTopAppBarFoundation;
        }(MDCTopAppBarBaseFoundation);
        const short_foundation = null && MDCShortTopAppBarFoundation;
        /**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
        var MDCTopAppBar = function(_super) {
            __extends(MDCTopAppBar, _super);
            function MDCTopAppBar() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            MDCTopAppBar.attachTo = function(root) {
                return new MDCTopAppBar(root);
            };
            MDCTopAppBar.prototype.initialize = function(rippleFactory) {
                if (rippleFactory === void 0) {
                    rippleFactory = function(el) {
                        return MDCRipple.attachTo(el);
                    };
                }
                this.navIcon_ = this.root.querySelector(top_app_bar_constants_strings.NAVIGATION_ICON_SELECTOR);
                var icons = [].slice.call(this.root.querySelectorAll(top_app_bar_constants_strings.ACTION_ITEM_SELECTOR));
                if (this.navIcon_) {
                    icons.push(this.navIcon_);
                }
                this.iconRipples_ = icons.map((function(icon) {
                    var ripple = rippleFactory(icon);
                    ripple.unbounded = true;
                    return ripple;
                }));
                this.scrollTarget_ = window;
            };
            MDCTopAppBar.prototype.initialSyncWithDOM = function() {
                this.handleNavigationClick_ = this.foundation.handleNavigationClick.bind(this.foundation);
                this.handleWindowResize_ = this.foundation.handleWindowResize.bind(this.foundation);
                this.handleTargetScroll_ = this.foundation.handleTargetScroll.bind(this.foundation);
                this.scrollTarget_.addEventListener("scroll", this.handleTargetScroll_);
                if (this.navIcon_) {
                    this.navIcon_.addEventListener("click", this.handleNavigationClick_);
                }
                var isFixed = this.root.classList.contains(top_app_bar_constants_cssClasses.FIXED_CLASS);
                var isShort = this.root.classList.contains(top_app_bar_constants_cssClasses.SHORT_CLASS);
                if (!isShort && !isFixed) {
                    window.addEventListener("resize", this.handleWindowResize_);
                }
            };
            MDCTopAppBar.prototype.destroy = function() {
                this.iconRipples_.forEach((function(iconRipple) {
                    return iconRipple.destroy();
                }));
                this.scrollTarget_.removeEventListener("scroll", this.handleTargetScroll_);
                if (this.navIcon_) {
                    this.navIcon_.removeEventListener("click", this.handleNavigationClick_);
                }
                var isFixed = this.root.classList.contains(top_app_bar_constants_cssClasses.FIXED_CLASS);
                var isShort = this.root.classList.contains(top_app_bar_constants_cssClasses.SHORT_CLASS);
                if (!isShort && !isFixed) {
                    window.removeEventListener("resize", this.handleWindowResize_);
                }
                _super.prototype.destroy.call(this);
            };
            MDCTopAppBar.prototype.setScrollTarget = function(target) {
                this.scrollTarget_.removeEventListener("scroll", this.handleTargetScroll_);
                this.scrollTarget_ = target;
                this.handleTargetScroll_ = this.foundation.handleTargetScroll.bind(this.foundation);
                this.scrollTarget_.addEventListener("scroll", this.handleTargetScroll_);
            };
            MDCTopAppBar.prototype.getDefaultFoundation = function() {
                var _this = this;
                var adapter = {
                    hasClass: function(className) {
                        return _this.root.classList.contains(className);
                    },
                    addClass: function(className) {
                        return _this.root.classList.add(className);
                    },
                    removeClass: function(className) {
                        return _this.root.classList.remove(className);
                    },
                    setStyle: function(property, value) {
                        return _this.root.style.setProperty(property, value);
                    },
                    getTopAppBarHeight: function() {
                        return _this.root.clientHeight;
                    },
                    notifyNavigationIconClicked: function() {
                        return _this.emit(top_app_bar_constants_strings.NAVIGATION_EVENT, {});
                    },
                    getViewportScrollY: function() {
                        var win = _this.scrollTarget_;
                        var el = _this.scrollTarget_;
                        return win.pageYOffset !== undefined ? win.pageYOffset : el.scrollTop;
                    },
                    getTotalActionItems: function() {
                        return _this.root.querySelectorAll(top_app_bar_constants_strings.ACTION_ITEM_SELECTOR).length;
                    }
                };
                var foundation;
                if (this.root.classList.contains(top_app_bar_constants_cssClasses.SHORT_CLASS)) {
                    foundation = new MDCShortTopAppBarFoundation(adapter);
                } else if (this.root.classList.contains(top_app_bar_constants_cssClasses.FIXED_CLASS)) {
                    foundation = new MDCFixedTopAppBarFoundation(adapter);
                } else {
                    foundation = new MDCTopAppBarFoundation(adapter);
                }
                return foundation;
            };
            return MDCTopAppBar;
        }(MDCComponent);
        function MBTopAppBar_init(elem, scrollTarget) {
            elem._topAppBar = MDCTopAppBar.attachTo(elem);
            if (scrollTarget) {
                elem._topAppBar.setScrollTarget(document.querySelector(scrollTarget));
            }
        }
        var Batching = __webpack_require__(854);
        window.MaterialBlazor = {
            Batching: Batching,
            MBAutoCompleteTextField: MBAutocompleteTextField_namespaceObject,
            MBBladeSet: MBBladeSet_namespaceObject,
            MBButton: MBButton_namespaceObject,
            MBCard: MBCard_namespaceObject,
            MBChipsSelectMulti: MBChipsSelectMulti_namespaceObject,
            MBCheckbox: MBCheckbox_namespaceObject,
            MBCircularProgress: MBCircularProgress_namespaceObject,
            MBDataTable: MBDataTable_namespaceObject,
            MBDatePicker: MBDatePicker_namespaceObject,
            MBDialog: MBDialog_namespaceObject,
            MBDrawer: MBDrawer_namespaceObject,
            MBFloatingActionButton: MBFloatingActionButton_namespaceObject,
            MBGrid: MBGrid_namespaceObject,
            MBIconButton: MBIconButton_namespaceObject,
            MBIconButtonToggle: MBIconButtonToggle_namespaceObject,
            MBLinearProgress: MBLinearProgress_namespaceObject,
            MBList: MBList_namespaceObject,
            MBMenu: MBMenu_namespaceObject,
            MBMenuSurface: MBMenuSurface_namespaceObject,
            MBRadioButton: MBRadioButton_namespaceObject,
            MBSegmentedButtonMulti: MBSegmentedButtonMulti_namespaceObject,
            MBSelect: MBSelect_namespaceObject,
            MBSlider: MBSlider_namespaceObject,
            MBSnackbar: MBSnackbar_namespaceObject,
            MBSwitch: MBSwitch_namespaceObject,
            MBTabBar: MBTabBar_namespaceObject,
            MBTextField: MBTextField_namespaceObject,
            MBTooltip: MBTooltip_namespaceObject,
            MBTopAppBar: MBTopAppBar_namespaceObject
        };
    })();
})();